// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: syscontract/dpos_stake.proto

package syscontract

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// methods of DPoS stake contract
type DPoSStakeFunction int32

const (
	// get all validator candidates
	DPoSStakeFunction_GET_ALL_CANDIDATES DPoSStakeFunction = 0
	// get validator by address
	DPoSStakeFunction_GET_VALIDATOR_BY_ADDRESS DPoSStakeFunction = 1
	// delegate
	DPoSStakeFunction_DELEGATE DPoSStakeFunction = 2
	// get delegate by address
	DPoSStakeFunction_GET_DELEGATIONS_BY_ADDRESS DPoSStakeFunction = 3
	// get user delegation by validator
	DPoSStakeFunction_GET_USER_DELEGATION_BY_VALIDATOR DPoSStakeFunction = 4
	// undelegate
	DPoSStakeFunction_UNDELEGATE DPoSStakeFunction = 5
	// read epoch by id
	DPoSStakeFunction_READ_EPOCH_BY_ID DPoSStakeFunction = 6
	// read latest epoch
	DPoSStakeFunction_READ_LATEST_EPOCH DPoSStakeFunction = 7
	// set node id before join network
	DPoSStakeFunction_SET_NODE_ID DPoSStakeFunction = 8
	// get node id after join network
	DPoSStakeFunction_GET_NODE_ID DPoSStakeFunction = 9
	// update min self delegation
	DPoSStakeFunction_UPDATE_MIN_SELF_DELEGATION DPoSStakeFunction = 10
	// read min self delegation
	DPoSStakeFunction_READ_MIN_SELF_DELEGATION DPoSStakeFunction = 11
	// update epoch validator number
	DPoSStakeFunction_UPDATE_EPOCH_VALIDATOR_NUMBER DPoSStakeFunction = 12
	// read epoch validator number
	DPoSStakeFunction_READ_EPOCH_VALIDATOR_NUMBER DPoSStakeFunction = 13
	// update epoch block number
	DPoSStakeFunction_UPDATE_EPOCH_BLOCK_NUMBER DPoSStakeFunction = 14
	// read epoch block number
	DPoSStakeFunction_READ_EPOCH_BLOCK_NUMBER DPoSStakeFunction = 15
	// read complete unbounding epoch number
	DPoSStakeFunction_READ_COMPLETE_UNBOUNDING_EPOCH_NUMBER DPoSStakeFunction = 16
	// read system contract address
	DPoSStakeFunction_READ_SYSTEM_CONTRACT_ADDR DPoSStakeFunction = 18
)

var DPoSStakeFunction_name = map[int32]string{
	0:  "GET_ALL_CANDIDATES",
	1:  "GET_VALIDATOR_BY_ADDRESS",
	2:  "DELEGATE",
	3:  "GET_DELEGATIONS_BY_ADDRESS",
	4:  "GET_USER_DELEGATION_BY_VALIDATOR",
	5:  "UNDELEGATE",
	6:  "READ_EPOCH_BY_ID",
	7:  "READ_LATEST_EPOCH",
	8:  "SET_NODE_ID",
	9:  "GET_NODE_ID",
	10: "UPDATE_MIN_SELF_DELEGATION",
	11: "READ_MIN_SELF_DELEGATION",
	12: "UPDATE_EPOCH_VALIDATOR_NUMBER",
	13: "READ_EPOCH_VALIDATOR_NUMBER",
	14: "UPDATE_EPOCH_BLOCK_NUMBER",
	15: "READ_EPOCH_BLOCK_NUMBER",
	16: "READ_COMPLETE_UNBOUNDING_EPOCH_NUMBER",
	18: "READ_SYSTEM_CONTRACT_ADDR",
}

var DPoSStakeFunction_value = map[string]int32{
	"GET_ALL_CANDIDATES":                    0,
	"GET_VALIDATOR_BY_ADDRESS":              1,
	"DELEGATE":                              2,
	"GET_DELEGATIONS_BY_ADDRESS":            3,
	"GET_USER_DELEGATION_BY_VALIDATOR":      4,
	"UNDELEGATE":                            5,
	"READ_EPOCH_BY_ID":                      6,
	"READ_LATEST_EPOCH":                     7,
	"SET_NODE_ID":                           8,
	"GET_NODE_ID":                           9,
	"UPDATE_MIN_SELF_DELEGATION":            10,
	"READ_MIN_SELF_DELEGATION":              11,
	"UPDATE_EPOCH_VALIDATOR_NUMBER":         12,
	"READ_EPOCH_VALIDATOR_NUMBER":           13,
	"UPDATE_EPOCH_BLOCK_NUMBER":             14,
	"READ_EPOCH_BLOCK_NUMBER":               15,
	"READ_COMPLETE_UNBOUNDING_EPOCH_NUMBER": 16,
	"READ_SYSTEM_CONTRACT_ADDR":             18,
}

func (x DPoSStakeFunction) String() string {
	return proto.EnumName(DPoSStakeFunction_name, int32(x))
}

func (DPoSStakeFunction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0d4f0ac2537ae6c4, []int{0}
}

type BondStatus int32

const (
	BondStatus_BONDED    BondStatus = 0
	BondStatus_UNBONDING BondStatus = 1
	BondStatus_UNBONDED  BondStatus = 2
)

var BondStatus_name = map[int32]string{
	0: "BONDED",
	1: "UNBONDING",
	2: "UNBONDED",
}

var BondStatus_value = map[string]int32{
	"BONDED":    0,
	"UNBONDING": 1,
	"UNBONDED":  2,
}

func (x BondStatus) String() string {
	return proto.EnumName(BondStatus_name, int32(x))
}

func (BondStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0d4f0ac2537ae6c4, []int{1}
}

type Epoch struct {
	// ID with auto-increment
	EpochId uint64 `protobuf:"varint,1,opt,name=epoch_id,json=epochId,proto3" json:"epoch_id,omitempty"`
	// A collection of validators for the current generation
	ProposerVector []string `protobuf:"bytes,2,rep,name=proposer_vector,json=proposerVector,proto3" json:"proposer_vector,omitempty"`
	// Next epoch switch height
	NextEpochCreateHeight uint64 `protobuf:"varint,3,opt,name=next_epoch_create_height,json=nextEpochCreateHeight,proto3" json:"next_epoch_create_height,omitempty"`
}

func (m *Epoch) Reset()         { *m = Epoch{} }
func (m *Epoch) String() string { return proto.CompactTextString(m) }
func (*Epoch) ProtoMessage()    {}
func (*Epoch) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d4f0ac2537ae6c4, []int{0}
}
func (m *Epoch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Epoch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Epoch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Epoch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Epoch.Merge(m, src)
}
func (m *Epoch) XXX_Size() int {
	return m.Size()
}
func (m *Epoch) XXX_DiscardUnknown() {
	xxx_messageInfo_Epoch.DiscardUnknown(m)
}

var xxx_messageInfo_Epoch proto.InternalMessageInfo

func (m *Epoch) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

func (m *Epoch) GetProposerVector() []string {
	if m != nil {
		return m.ProposerVector
	}
	return nil
}

func (m *Epoch) GetNextEpochCreateHeight() uint64 {
	if m != nil {
		return m.NextEpochCreateHeight
	}
	return 0
}

type Validator struct {
	// The address of the verifier: base58.Encode(sha256(pubkey))
	ValidatorAddress string `protobuf:"bytes,1,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
	// active punishment tags whether validator is jailed or not
	Jailed bool `protobuf:"varint,2,opt,name=jailed,proto3" json:"jailed,omitempty"`
	// validator status: Bonded / Unbonding / Unbonded
	Status BondStatus `protobuf:"varint,3,opt,name=status,proto3,enum=syscontract.BondStatus" json:"status,omitempty"`
	// delegate token amount
	Tokens string `protobuf:"bytes,4,opt,name=tokens,proto3" json:"tokens,omitempty"`
	// delegate share amount
	DelegatorShares string `protobuf:"bytes,5,opt,name=delegator_shares,json=delegatorShares,proto3" json:"delegator_shares,omitempty"`
	// undelegate entry epoch id
	UnbondingEpochId uint64 `protobuf:"varint,6,opt,name=unbonding_epoch_id,json=unbondingEpochId,proto3" json:"unbonding_epoch_id,omitempty"`
	// undelegate entry complete epoch id
	UnbondingCompletionEpochId uint64 `protobuf:"varint,7,opt,name=unbonding_completion_epoch_id,json=unbondingCompletionEpochId,proto3" json:"unbonding_completion_epoch_id,omitempty"`
	// validator self delegate token amount
	SelfDelegation string `protobuf:"bytes,8,opt,name=self_delegation,json=selfDelegation,proto3" json:"self_delegation,omitempty"`
}

func (m *Validator) Reset()         { *m = Validator{} }
func (m *Validator) String() string { return proto.CompactTextString(m) }
func (*Validator) ProtoMessage()    {}
func (*Validator) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d4f0ac2537ae6c4, []int{1}
}
func (m *Validator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Validator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Validator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Validator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Validator.Merge(m, src)
}
func (m *Validator) XXX_Size() int {
	return m.Size()
}
func (m *Validator) XXX_DiscardUnknown() {
	xxx_messageInfo_Validator.DiscardUnknown(m)
}

var xxx_messageInfo_Validator proto.InternalMessageInfo

func (m *Validator) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *Validator) GetJailed() bool {
	if m != nil {
		return m.Jailed
	}
	return false
}

func (m *Validator) GetStatus() BondStatus {
	if m != nil {
		return m.Status
	}
	return BondStatus_BONDED
}

func (m *Validator) GetTokens() string {
	if m != nil {
		return m.Tokens
	}
	return ""
}

func (m *Validator) GetDelegatorShares() string {
	if m != nil {
		return m.DelegatorShares
	}
	return ""
}

func (m *Validator) GetUnbondingEpochId() uint64 {
	if m != nil {
		return m.UnbondingEpochId
	}
	return 0
}

func (m *Validator) GetUnbondingCompletionEpochId() uint64 {
	if m != nil {
		return m.UnbondingCompletionEpochId
	}
	return 0
}

func (m *Validator) GetSelfDelegation() string {
	if m != nil {
		return m.SelfDelegation
	}
	return ""
}

type Delegation struct {
	// delegator cert hash
	DelegatorAddress string `protobuf:"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3" json:"delegator_address,omitempty"`
	// validator cert hash
	ValidatorAddress string `protobuf:"bytes,2,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
	// share amount
	Shares string `protobuf:"bytes,3,opt,name=shares,proto3" json:"shares,omitempty"`
}

func (m *Delegation) Reset()         { *m = Delegation{} }
func (m *Delegation) String() string { return proto.CompactTextString(m) }
func (*Delegation) ProtoMessage()    {}
func (*Delegation) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d4f0ac2537ae6c4, []int{2}
}
func (m *Delegation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Delegation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Delegation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Delegation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Delegation.Merge(m, src)
}
func (m *Delegation) XXX_Size() int {
	return m.Size()
}
func (m *Delegation) XXX_DiscardUnknown() {
	xxx_messageInfo_Delegation.DiscardUnknown(m)
}

var xxx_messageInfo_Delegation proto.InternalMessageInfo

func (m *Delegation) GetDelegatorAddress() string {
	if m != nil {
		return m.DelegatorAddress
	}
	return ""
}

func (m *Delegation) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *Delegation) GetShares() string {
	if m != nil {
		return m.Shares
	}
	return ""
}

type UnbondingDelegation struct {
	// epoch id
	EpochId string `protobuf:"bytes,1,opt,name=epoch_id,json=epochId,proto3" json:"epoch_id,omitempty"`
	// delegator cert hash
	DelegatorAddress string `protobuf:"bytes,2,opt,name=delegator_address,json=delegatorAddress,proto3" json:"delegator_address,omitempty"`
	// validator cert hash
	ValidatorAddress string `protobuf:"bytes,3,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
	// unbond entry records
	Entries []*UnbondingDelegationEntry `protobuf:"bytes,4,rep,name=entries,proto3" json:"entries,omitempty"`
}

func (m *UnbondingDelegation) Reset()         { *m = UnbondingDelegation{} }
func (m *UnbondingDelegation) String() string { return proto.CompactTextString(m) }
func (*UnbondingDelegation) ProtoMessage()    {}
func (*UnbondingDelegation) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d4f0ac2537ae6c4, []int{3}
}
func (m *UnbondingDelegation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnbondingDelegation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnbondingDelegation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnbondingDelegation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnbondingDelegation.Merge(m, src)
}
func (m *UnbondingDelegation) XXX_Size() int {
	return m.Size()
}
func (m *UnbondingDelegation) XXX_DiscardUnknown() {
	xxx_messageInfo_UnbondingDelegation.DiscardUnknown(m)
}

var xxx_messageInfo_UnbondingDelegation proto.InternalMessageInfo

func (m *UnbondingDelegation) GetEpochId() string {
	if m != nil {
		return m.EpochId
	}
	return ""
}

func (m *UnbondingDelegation) GetDelegatorAddress() string {
	if m != nil {
		return m.DelegatorAddress
	}
	return ""
}

func (m *UnbondingDelegation) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *UnbondingDelegation) GetEntries() []*UnbondingDelegationEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type UnbondingDelegationEntry struct {
	// create epoch id
	CreationEpochId uint64 `protobuf:"varint,1,opt,name=creation_epoch_id,json=creationEpochId,proto3" json:"creation_epoch_id,omitempty"`
	// complete epoch id
	CompletionEpochId uint64 `protobuf:"varint,2,opt,name=completion_epoch_id,json=completionEpochId,proto3" json:"completion_epoch_id,omitempty"`
	// undelegate amount
	Amount string `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *UnbondingDelegationEntry) Reset()         { *m = UnbondingDelegationEntry{} }
func (m *UnbondingDelegationEntry) String() string { return proto.CompactTextString(m) }
func (*UnbondingDelegationEntry) ProtoMessage()    {}
func (*UnbondingDelegationEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d4f0ac2537ae6c4, []int{4}
}
func (m *UnbondingDelegationEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnbondingDelegationEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnbondingDelegationEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnbondingDelegationEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnbondingDelegationEntry.Merge(m, src)
}
func (m *UnbondingDelegationEntry) XXX_Size() int {
	return m.Size()
}
func (m *UnbondingDelegationEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_UnbondingDelegationEntry.DiscardUnknown(m)
}

var xxx_messageInfo_UnbondingDelegationEntry proto.InternalMessageInfo

func (m *UnbondingDelegationEntry) GetCreationEpochId() uint64 {
	if m != nil {
		return m.CreationEpochId
	}
	return 0
}

func (m *UnbondingDelegationEntry) GetCompletionEpochId() uint64 {
	if m != nil {
		return m.CompletionEpochId
	}
	return 0
}

func (m *UnbondingDelegationEntry) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

type ValidatorVector struct {
	// validator cert hash vector
	Vector []string `protobuf:"bytes,1,rep,name=vector,proto3" json:"vector,omitempty"`
}

func (m *ValidatorVector) Reset()         { *m = ValidatorVector{} }
func (m *ValidatorVector) String() string { return proto.CompactTextString(m) }
func (*ValidatorVector) ProtoMessage()    {}
func (*ValidatorVector) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d4f0ac2537ae6c4, []int{5}
}
func (m *ValidatorVector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorVector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorVector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorVector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorVector.Merge(m, src)
}
func (m *ValidatorVector) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorVector) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorVector.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorVector proto.InternalMessageInfo

func (m *ValidatorVector) GetVector() []string {
	if m != nil {
		return m.Vector
	}
	return nil
}

type DelegationInfo struct {
	// delegate slice
	Infos []*Delegation `protobuf:"bytes,1,rep,name=infos,proto3" json:"infos,omitempty"`
}

func (m *DelegationInfo) Reset()         { *m = DelegationInfo{} }
func (m *DelegationInfo) String() string { return proto.CompactTextString(m) }
func (*DelegationInfo) ProtoMessage()    {}
func (*DelegationInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d4f0ac2537ae6c4, []int{6}
}
func (m *DelegationInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegationInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegationInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegationInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegationInfo.Merge(m, src)
}
func (m *DelegationInfo) XXX_Size() int {
	return m.Size()
}
func (m *DelegationInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegationInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DelegationInfo proto.InternalMessageInfo

func (m *DelegationInfo) GetInfos() []*Delegation {
	if m != nil {
		return m.Infos
	}
	return nil
}

func init() {
	proto.RegisterEnum("syscontract.DPoSStakeFunction", DPoSStakeFunction_name, DPoSStakeFunction_value)
	proto.RegisterEnum("syscontract.BondStatus", BondStatus_name, BondStatus_value)
	proto.RegisterType((*Epoch)(nil), "syscontract.Epoch")
	proto.RegisterType((*Validator)(nil), "syscontract.Validator")
	proto.RegisterType((*Delegation)(nil), "syscontract.Delegation")
	proto.RegisterType((*UnbondingDelegation)(nil), "syscontract.UnbondingDelegation")
	proto.RegisterType((*UnbondingDelegationEntry)(nil), "syscontract.UnbondingDelegationEntry")
	proto.RegisterType((*ValidatorVector)(nil), "syscontract.ValidatorVector")
	proto.RegisterType((*DelegationInfo)(nil), "syscontract.DelegationInfo")
}

func init() { proto.RegisterFile("syscontract/dpos_stake.proto", fileDescriptor_0d4f0ac2537ae6c4) }

var fileDescriptor_0d4f0ac2537ae6c4 = []byte{
	// 884 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0x4d, 0x6f, 0xdb, 0x46,
	0x10, 0x15, 0x25, 0x5b, 0x96, 0x46, 0x89, 0x44, 0x6d, 0x1a, 0x87, 0xf9, 0xb0, 0xea, 0x0a, 0x0d,
	0xea, 0xb8, 0x8d, 0x04, 0xb8, 0x28, 0x7a, 0x0c, 0x28, 0x71, 0xe3, 0x08, 0x95, 0x49, 0x83, 0xa4,
	0x0c, 0xa4, 0x97, 0x05, 0x4d, 0xae, 0x25, 0xd6, 0x32, 0x57, 0x20, 0x69, 0xa3, 0xb9, 0xf4, 0x94,
	0x73, 0xd1, 0x9f, 0x55, 0xa0, 0x97, 0x1c, 0x7b, 0x2a, 0x0a, 0xfb, 0x8f, 0x14, 0xbb, 0xfc, 0xb4,
	0x23, 0x1f, 0x7a, 0xd3, 0xbc, 0xf7, 0x76, 0xf6, 0xcd, 0xcc, 0x0e, 0x05, 0x2f, 0xa2, 0x0f, 0x91,
	0xcb, 0x82, 0x38, 0x74, 0xdc, 0x78, 0xe8, 0xad, 0x58, 0x44, 0xa2, 0xd8, 0x39, 0xa7, 0x83, 0x55,
	0xc8, 0x62, 0x86, 0x5a, 0x25, 0xb6, 0xff, 0x51, 0x82, 0x4d, 0xbc, 0x62, 0xee, 0x02, 0x3d, 0x85,
	0x06, 0xe5, 0x3f, 0x88, 0xef, 0x29, 0xd2, 0xae, 0xb4, 0xb7, 0x61, 0x6e, 0x89, 0x78, 0xe2, 0xa1,
	0x6f, 0xa0, 0xb3, 0x0a, 0xd9, 0x8a, 0x45, 0x34, 0x24, 0x57, 0xd4, 0x8d, 0x59, 0xa8, 0x54, 0x77,
	0x6b, 0x7b, 0x4d, 0xb3, 0x9d, 0xc1, 0x27, 0x02, 0x45, 0x3f, 0x82, 0x12, 0xd0, 0x5f, 0x63, 0x92,
	0x24, 0x72, 0x43, 0xea, 0xc4, 0x94, 0x2c, 0xa8, 0x3f, 0x5f, 0xc4, 0x4a, 0x4d, 0xe4, 0x7c, 0xcc,
	0x79, 0x71, 0xe1, 0x58, 0xb0, 0xef, 0x04, 0xd9, 0xff, 0xa7, 0x0a, 0xcd, 0x13, 0x67, 0xe9, 0x7b,
	0x0e, 0x4f, 0xf3, 0x2d, 0x74, 0xaf, 0xb2, 0x80, 0x38, 0x9e, 0x17, 0xd2, 0x28, 0x12, 0x9e, 0x9a,
	0xa6, 0x9c, 0x13, 0x6a, 0x82, 0xa3, 0x6d, 0xa8, 0xff, 0xe2, 0xf8, 0x4b, 0xea, 0x29, 0xd5, 0x5d,
	0x69, 0xaf, 0x61, 0xa6, 0x11, 0x1a, 0x42, 0x3d, 0x8a, 0x9d, 0xf8, 0x32, 0x12, 0x37, 0xb7, 0x0f,
	0x9e, 0x0c, 0x4a, 0x75, 0x0f, 0x46, 0x2c, 0xf0, 0x2c, 0x41, 0x9b, 0xa9, 0x8c, 0x27, 0x8a, 0xd9,
	0x39, 0x0d, 0x22, 0x65, 0x43, 0x5c, 0x95, 0x46, 0xe8, 0x15, 0xc8, 0x1e, 0x5d, 0xd2, 0xb9, 0x70,
	0x13, 0x2d, 0x9c, 0x90, 0x46, 0xca, 0xa6, 0x50, 0x74, 0x72, 0xdc, 0x12, 0x30, 0xfa, 0x0e, 0xd0,
	0x65, 0x70, 0xca, 0x02, 0xcf, 0x0f, 0xe6, 0x24, 0xef, 0x66, 0x5d, 0x54, 0x2e, 0xe7, 0x0c, 0x4e,
	0xdb, 0xaa, 0xc2, 0x4e, 0xa1, 0x76, 0xd9, 0xc5, 0x6a, 0x49, 0x63, 0x9f, 0x05, 0xc5, 0xc1, 0x2d,
	0x71, 0xf0, 0x59, 0x2e, 0x1a, 0xe7, 0x1a, 0x5c, 0x4c, 0x26, 0xa2, 0xcb, 0x33, 0x92, 0x1a, 0xf1,
	0x59, 0xa0, 0x34, 0x84, 0xb5, 0x36, 0x87, 0xb5, 0x1c, 0xed, 0xff, 0x06, 0x50, 0x44, 0xbc, 0xc1,
	0x45, 0x49, 0x77, 0x1a, 0x9c, 0x13, 0x59, 0x83, 0xd7, 0x4e, 0xa3, 0x7a, 0xff, 0x34, 0xd2, 0x16,
	0xd5, 0x92, 0x26, 0x26, 0x51, 0xff, 0x2f, 0x09, 0x1e, 0xcd, 0xb2, 0x3a, 0x4a, 0x4e, 0xee, 0xbe,
	0xba, 0x66, 0xf1, 0xea, 0xd6, 0x9a, 0xac, 0xfe, 0x1f, 0x93, 0xb5, 0x7b, 0x4c, 0xbe, 0x81, 0x2d,
	0x1a, 0xc4, 0xa1, 0x4f, 0xf9, 0xa8, 0x6b, 0x7b, 0xad, 0x83, 0x97, 0xb7, 0xde, 0xc6, 0x1a, 0x9f,
	0x38, 0x88, 0xc3, 0x0f, 0x66, 0x76, 0xaa, 0xff, 0xbb, 0x04, 0xca, 0x7d, 0x2a, 0xb4, 0x0f, 0x5d,
	0xf1, 0xf2, 0x6f, 0x8d, 0x32, 0xd9, 0xa8, 0x4e, 0x46, 0x64, 0xf3, 0x1b, 0xc0, 0xa3, 0x75, 0x83,
	0xaf, 0x0a, 0x75, 0xd7, 0xfd, 0x6c, 0xde, 0xdb, 0x50, 0x77, 0x2e, 0xd8, 0x65, 0x10, 0x67, 0xed,
	0x4d, 0xa2, 0xfe, 0x2b, 0xe8, 0xe4, 0xeb, 0x93, 0xee, 0xe2, 0x36, 0xd4, 0xd3, 0x5d, 0x95, 0xc4,
	0xae, 0xa6, 0x51, 0xff, 0x0d, 0xb4, 0x0b, 0xc7, 0x93, 0xe0, 0x8c, 0xa1, 0xd7, 0xb0, 0xe9, 0x07,
	0x67, 0x2c, 0x12, 0xc2, 0xd6, 0x9d, 0x45, 0x29, 0xb4, 0x66, 0xa2, 0xda, 0xff, 0xb8, 0x01, 0x5d,
	0xed, 0x98, 0x59, 0x16, 0xff, 0xa6, 0xbc, 0xbd, 0x0c, 0x5c, 0x31, 0xc8, 0x6d, 0x40, 0x87, 0xd8,
	0x26, 0xea, 0x74, 0x4a, 0xc6, 0xaa, 0xae, 0x4d, 0x34, 0xd5, 0xc6, 0x96, 0x5c, 0x41, 0x2f, 0x40,
	0xe1, 0xf8, 0x89, 0x3a, 0xe5, 0x90, 0x61, 0x92, 0xd1, 0x7b, 0xa2, 0x6a, 0x9a, 0x89, 0x2d, 0x4b,
	0x96, 0xd0, 0x03, 0x68, 0x68, 0x78, 0x8a, 0x0f, 0x55, 0x1b, 0xcb, 0x55, 0xd4, 0x83, 0x67, 0x5c,
	0x9b, 0x22, 0x13, 0x43, 0xb7, 0xca, 0xea, 0x1a, 0xfa, 0x1a, 0x76, 0x39, 0x3f, 0xb3, 0xb0, 0x59,
	0x12, 0x71, 0x4d, 0x9e, 0x5e, 0xde, 0x40, 0x6d, 0x80, 0x99, 0x9e, 0x67, 0xdd, 0x44, 0x5f, 0x80,
	0x6c, 0x62, 0x55, 0x23, 0xf8, 0xd8, 0x18, 0xbf, 0xe3, 0xe2, 0x89, 0x26, 0xd7, 0xd1, 0x63, 0xe8,
	0x0a, 0x74, 0xca, 0x7d, 0xda, 0x09, 0x29, 0x6f, 0xa1, 0x0e, 0xb4, 0x2c, 0x6c, 0x13, 0xdd, 0xd0,
	0x30, 0xd7, 0x35, 0x38, 0x70, 0x58, 0x02, 0x9a, 0xdc, 0xe4, 0xec, 0x98, 0x57, 0x47, 0x8e, 0x26,
	0x3a, 0xb1, 0xf0, 0xf4, 0x6d, 0xc9, 0x8b, 0x0c, 0xbc, 0x60, 0x91, 0x78, 0x1d, 0xdb, 0x42, 0x5f,
	0xc1, 0x4e, 0x7a, 0x3a, 0xb1, 0x53, 0xf4, 0x45, 0x9f, 0x1d, 0x8d, 0xb0, 0x29, 0x3f, 0x40, 0x5f,
	0xc2, 0xf3, 0x92, 0xdf, 0xcf, 0x04, 0x0f, 0xd1, 0x0e, 0x3c, 0xbd, 0x95, 0x63, 0x34, 0x35, 0xc6,
	0x3f, 0x65, 0x74, 0x1b, 0x3d, 0x87, 0x27, 0xe5, 0x7a, 0xcb, 0x64, 0x07, 0xbd, 0x82, 0x97, 0x82,
	0x1c, 0x1b, 0x47, 0xc7, 0x53, 0x6c, 0x63, 0x32, 0xd3, 0x47, 0xc6, 0x4c, 0xd7, 0x26, 0xfa, 0x61,
	0x7a, 0x20, 0x95, 0xca, 0xfc, 0x1a, 0x21, 0xb5, 0xde, 0x5b, 0x36, 0x3e, 0x22, 0x63, 0x43, 0xb7,
	0x4d, 0x75, 0x6c, 0x8b, 0x79, 0xc8, 0x68, 0xff, 0x07, 0x80, 0xe2, 0x23, 0x8a, 0x00, 0xea, 0x23,
	0x43, 0xd7, 0xb0, 0x26, 0x57, 0xd0, 0x43, 0x68, 0xf2, 0xac, 0x22, 0x69, 0x32, 0xe3, 0x24, 0xc4,
	0x9a, 0x5c, 0x1d, 0xcd, 0xff, 0xbc, 0xee, 0x49, 0x9f, 0xae, 0x7b, 0xd2, 0xbf, 0xd7, 0x3d, 0xe9,
	0x8f, 0x9b, 0x5e, 0xe5, 0xd3, 0x4d, 0xaf, 0xf2, 0xf7, 0x4d, 0xaf, 0x02, 0x3b, 0x2c, 0x9c, 0x0f,
	0xdc, 0x85, 0xe3, 0x07, 0x17, 0xce, 0x39, 0x0d, 0x07, 0xab, 0xd3, 0xf2, 0x43, 0xfc, 0xb9, 0x4c,
	0xb1, 0x70, 0x3e, 0x2c, 0xc2, 0xe1, 0xea, 0xf4, 0xf5, 0x9c, 0x0d, 0xaf, 0x0e, 0x86, 0x25, 0xfd,
	0x69, 0x5d, 0xfc, 0xdb, 0x7d, 0xff, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf9, 0xd2, 0xfc, 0x0a,
	0x0d, 0x07, 0x00, 0x00,
}

func (m *Epoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Epoch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Epoch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NextEpochCreateHeight != 0 {
		i = encodeVarintDposStake(dAtA, i, uint64(m.NextEpochCreateHeight))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ProposerVector) > 0 {
		for iNdEx := len(m.ProposerVector) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ProposerVector[iNdEx])
			copy(dAtA[i:], m.ProposerVector[iNdEx])
			i = encodeVarintDposStake(dAtA, i, uint64(len(m.ProposerVector[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.EpochId != 0 {
		i = encodeVarintDposStake(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Validator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Validator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Validator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SelfDelegation) > 0 {
		i -= len(m.SelfDelegation)
		copy(dAtA[i:], m.SelfDelegation)
		i = encodeVarintDposStake(dAtA, i, uint64(len(m.SelfDelegation)))
		i--
		dAtA[i] = 0x42
	}
	if m.UnbondingCompletionEpochId != 0 {
		i = encodeVarintDposStake(dAtA, i, uint64(m.UnbondingCompletionEpochId))
		i--
		dAtA[i] = 0x38
	}
	if m.UnbondingEpochId != 0 {
		i = encodeVarintDposStake(dAtA, i, uint64(m.UnbondingEpochId))
		i--
		dAtA[i] = 0x30
	}
	if len(m.DelegatorShares) > 0 {
		i -= len(m.DelegatorShares)
		copy(dAtA[i:], m.DelegatorShares)
		i = encodeVarintDposStake(dAtA, i, uint64(len(m.DelegatorShares)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Tokens) > 0 {
		i -= len(m.Tokens)
		copy(dAtA[i:], m.Tokens)
		i = encodeVarintDposStake(dAtA, i, uint64(len(m.Tokens)))
		i--
		dAtA[i] = 0x22
	}
	if m.Status != 0 {
		i = encodeVarintDposStake(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.Jailed {
		i--
		if m.Jailed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintDposStake(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Delegation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Delegation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Delegation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Shares) > 0 {
		i -= len(m.Shares)
		copy(dAtA[i:], m.Shares)
		i = encodeVarintDposStake(dAtA, i, uint64(len(m.Shares)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintDposStake(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DelegatorAddress) > 0 {
		i -= len(m.DelegatorAddress)
		copy(dAtA[i:], m.DelegatorAddress)
		i = encodeVarintDposStake(dAtA, i, uint64(len(m.DelegatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnbondingDelegation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnbondingDelegation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnbondingDelegation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDposStake(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintDposStake(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DelegatorAddress) > 0 {
		i -= len(m.DelegatorAddress)
		copy(dAtA[i:], m.DelegatorAddress)
		i = encodeVarintDposStake(dAtA, i, uint64(len(m.DelegatorAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EpochId) > 0 {
		i -= len(m.EpochId)
		copy(dAtA[i:], m.EpochId)
		i = encodeVarintDposStake(dAtA, i, uint64(len(m.EpochId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnbondingDelegationEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnbondingDelegationEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnbondingDelegationEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintDposStake(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	if m.CompletionEpochId != 0 {
		i = encodeVarintDposStake(dAtA, i, uint64(m.CompletionEpochId))
		i--
		dAtA[i] = 0x10
	}
	if m.CreationEpochId != 0 {
		i = encodeVarintDposStake(dAtA, i, uint64(m.CreationEpochId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorVector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorVector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorVector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Vector) > 0 {
		for iNdEx := len(m.Vector) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Vector[iNdEx])
			copy(dAtA[i:], m.Vector[iNdEx])
			i = encodeVarintDposStake(dAtA, i, uint64(len(m.Vector[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DelegationInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegationInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegationInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for iNdEx := len(m.Infos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Infos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDposStake(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintDposStake(dAtA []byte, offset int, v uint64) int {
	offset -= sovDposStake(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Epoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochId != 0 {
		n += 1 + sovDposStake(uint64(m.EpochId))
	}
	if len(m.ProposerVector) > 0 {
		for _, s := range m.ProposerVector {
			l = len(s)
			n += 1 + l + sovDposStake(uint64(l))
		}
	}
	if m.NextEpochCreateHeight != 0 {
		n += 1 + sovDposStake(uint64(m.NextEpochCreateHeight))
	}
	return n
}

func (m *Validator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovDposStake(uint64(l))
	}
	if m.Jailed {
		n += 2
	}
	if m.Status != 0 {
		n += 1 + sovDposStake(uint64(m.Status))
	}
	l = len(m.Tokens)
	if l > 0 {
		n += 1 + l + sovDposStake(uint64(l))
	}
	l = len(m.DelegatorShares)
	if l > 0 {
		n += 1 + l + sovDposStake(uint64(l))
	}
	if m.UnbondingEpochId != 0 {
		n += 1 + sovDposStake(uint64(m.UnbondingEpochId))
	}
	if m.UnbondingCompletionEpochId != 0 {
		n += 1 + sovDposStake(uint64(m.UnbondingCompletionEpochId))
	}
	l = len(m.SelfDelegation)
	if l > 0 {
		n += 1 + l + sovDposStake(uint64(l))
	}
	return n
}

func (m *Delegation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DelegatorAddress)
	if l > 0 {
		n += 1 + l + sovDposStake(uint64(l))
	}
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovDposStake(uint64(l))
	}
	l = len(m.Shares)
	if l > 0 {
		n += 1 + l + sovDposStake(uint64(l))
	}
	return n
}

func (m *UnbondingDelegation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EpochId)
	if l > 0 {
		n += 1 + l + sovDposStake(uint64(l))
	}
	l = len(m.DelegatorAddress)
	if l > 0 {
		n += 1 + l + sovDposStake(uint64(l))
	}
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovDposStake(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovDposStake(uint64(l))
		}
	}
	return n
}

func (m *UnbondingDelegationEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreationEpochId != 0 {
		n += 1 + sovDposStake(uint64(m.CreationEpochId))
	}
	if m.CompletionEpochId != 0 {
		n += 1 + sovDposStake(uint64(m.CompletionEpochId))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovDposStake(uint64(l))
	}
	return n
}

func (m *ValidatorVector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Vector) > 0 {
		for _, s := range m.Vector {
			l = len(s)
			n += 1 + l + sovDposStake(uint64(l))
		}
	}
	return n
}

func (m *DelegationInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for _, e := range m.Infos {
			l = e.Size()
			n += 1 + l + sovDposStake(uint64(l))
		}
	}
	return n
}

func sovDposStake(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDposStake(x uint64) (n int) {
	return sovDposStake(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Epoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDposStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Epoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Epoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDposStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposerVector", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDposStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDposStake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDposStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProposerVector = append(m.ProposerVector, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextEpochCreateHeight", wireType)
			}
			m.NextEpochCreateHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDposStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextEpochCreateHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDposStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDposStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Validator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDposStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Validator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Validator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDposStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDposStake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDposStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jailed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDposStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Jailed = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDposStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= BondStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokens", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDposStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDposStake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDposStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tokens = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorShares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDposStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDposStake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDposStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorShares = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingEpochId", wireType)
			}
			m.UnbondingEpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDposStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnbondingEpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingCompletionEpochId", wireType)
			}
			m.UnbondingCompletionEpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDposStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnbondingCompletionEpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfDelegation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDposStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDposStake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDposStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SelfDelegation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDposStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDposStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Delegation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDposStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Delegation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Delegation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDposStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDposStake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDposStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDposStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDposStake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDposStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDposStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDposStake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDposStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shares = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDposStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDposStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnbondingDelegation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDposStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnbondingDelegation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnbondingDelegation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDposStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDposStake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDposStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EpochId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDposStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDposStake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDposStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDposStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDposStake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDposStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDposStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDposStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDposStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &UnbondingDelegationEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDposStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDposStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnbondingDelegationEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDposStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnbondingDelegationEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnbondingDelegationEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationEpochId", wireType)
			}
			m.CreationEpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDposStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationEpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionEpochId", wireType)
			}
			m.CompletionEpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDposStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletionEpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDposStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDposStake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDposStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDposStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDposStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorVector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDposStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorVector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorVector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vector", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDposStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDposStake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDposStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vector = append(m.Vector, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDposStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDposStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegationInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDposStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelegationInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelegationInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDposStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDposStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDposStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Infos = append(m.Infos, &Delegation{})
			if err := m.Infos[len(m.Infos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDposStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDposStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDposStake(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDposStake
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDposStake
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDposStake
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDposStake
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDposStake
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDposStake
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDposStake        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDposStake          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDposStake = fmt.Errorf("proto: unexpected end of group")
)
