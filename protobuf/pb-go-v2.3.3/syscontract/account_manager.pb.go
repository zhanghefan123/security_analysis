// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: syscontract/account_manager.proto

package syscontract

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// methods of private compute contract
type GasAccountFunction int32

const (
	// set admin
	GasAccountFunction_SET_ADMIN GasAccountFunction = 0
	// get admin
	GasAccountFunction_GET_ADMIN GasAccountFunction = 1
	// recharge gas
	GasAccountFunction_RECHARGE_GAS GasAccountFunction = 2
	// get balance
	GasAccountFunction_GET_BALANCE GasAccountFunction = 3
	// charge gas
	GasAccountFunction_CHARGE_GAS GasAccountFunction = 4
	// frozen account
	GasAccountFunction_FROZEN_ACCOUNT GasAccountFunction = 5
	// unfrozen account
	GasAccountFunction_UNFROZEN_ACCOUNT GasAccountFunction = 6
	// account status
	GasAccountFunction_ACCOUNT_STATUS GasAccountFunction = 7
	// refund gas
	GasAccountFunction_REFUND_GAS GasAccountFunction = 8
	// refund gas for vm
	GasAccountFunction_REFUND_GAS_VM GasAccountFunction = 9
	// charge gas for multi accounts
	GasAccountFunction_CHARGE_GAS_FOR_MULTI_ACCOUNT GasAccountFunction = 10
)

var GasAccountFunction_name = map[int32]string{
	0:  "SET_ADMIN",
	1:  "GET_ADMIN",
	2:  "RECHARGE_GAS",
	3:  "GET_BALANCE",
	4:  "CHARGE_GAS",
	5:  "FROZEN_ACCOUNT",
	6:  "UNFROZEN_ACCOUNT",
	7:  "ACCOUNT_STATUS",
	8:  "REFUND_GAS",
	9:  "REFUND_GAS_VM",
	10: "CHARGE_GAS_FOR_MULTI_ACCOUNT",
}

var GasAccountFunction_value = map[string]int32{
	"SET_ADMIN":                    0,
	"GET_ADMIN":                    1,
	"RECHARGE_GAS":                 2,
	"GET_BALANCE":                  3,
	"CHARGE_GAS":                   4,
	"FROZEN_ACCOUNT":               5,
	"UNFROZEN_ACCOUNT":             6,
	"ACCOUNT_STATUS":               7,
	"REFUND_GAS":                   8,
	"REFUND_GAS_VM":                9,
	"CHARGE_GAS_FOR_MULTI_ACCOUNT": 10,
}

func (x GasAccountFunction) String() string {
	return proto.EnumName(GasAccountFunction_name, int32(x))
}

func (GasAccountFunction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_816aa64736f82c70, []int{0}
}

type AccountMultiSign struct {
	Payloads      []byte `protobuf:"bytes,1,opt,name=payloads,proto3" json:"payloads,omitempty"`
	ClientSign    []byte `protobuf:"bytes,2,opt,name=client_sign,json=clientSign,proto3" json:"client_sign,omitempty"`
	PublicKeyInfo []byte `protobuf:"bytes,3,opt,name=public_key_info,json=publicKeyInfo,proto3" json:"public_key_info,omitempty"`
}

func (m *AccountMultiSign) Reset()         { *m = AccountMultiSign{} }
func (m *AccountMultiSign) String() string { return proto.CompactTextString(m) }
func (*AccountMultiSign) ProtoMessage()    {}
func (*AccountMultiSign) Descriptor() ([]byte, []int) {
	return fileDescriptor_816aa64736f82c70, []int{0}
}
func (m *AccountMultiSign) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountMultiSign) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountMultiSign.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountMultiSign) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountMultiSign.Merge(m, src)
}
func (m *AccountMultiSign) XXX_Size() int {
	return m.Size()
}
func (m *AccountMultiSign) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountMultiSign.DiscardUnknown(m)
}

var xxx_messageInfo_AccountMultiSign proto.InternalMessageInfo

func (m *AccountMultiSign) GetPayloads() []byte {
	if m != nil {
		return m.Payloads
	}
	return nil
}

func (m *AccountMultiSign) GetClientSign() []byte {
	if m != nil {
		return m.ClientSign
	}
	return nil
}

func (m *AccountMultiSign) GetPublicKeyInfo() []byte {
	if m != nil {
		return m.PublicKeyInfo
	}
	return nil
}

// account multi sign req
type AccountMultiSignsReq struct {
	GasMultiSigns []*AccountMultiSign `protobuf:"bytes,1,rep,name=gas_multi_signs,json=gasMultiSigns,proto3" json:"gas_multi_signs,omitempty"`
}

func (m *AccountMultiSignsReq) Reset()         { *m = AccountMultiSignsReq{} }
func (m *AccountMultiSignsReq) String() string { return proto.CompactTextString(m) }
func (*AccountMultiSignsReq) ProtoMessage()    {}
func (*AccountMultiSignsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_816aa64736f82c70, []int{1}
}
func (m *AccountMultiSignsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountMultiSignsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountMultiSignsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountMultiSignsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountMultiSignsReq.Merge(m, src)
}
func (m *AccountMultiSignsReq) XXX_Size() int {
	return m.Size()
}
func (m *AccountMultiSignsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountMultiSignsReq.DiscardUnknown(m)
}

var xxx_messageInfo_AccountMultiSignsReq proto.InternalMessageInfo

func (m *AccountMultiSignsReq) GetGasMultiSigns() []*AccountMultiSign {
	if m != nil {
		return m.GasMultiSigns
	}
	return nil
}

type RechargeGas struct {
	Address   string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	GasAmount int64  `protobuf:"varint,2,opt,name=gas_amount,json=gasAmount,proto3" json:"gas_amount,omitempty"`
}

func (m *RechargeGas) Reset()         { *m = RechargeGas{} }
func (m *RechargeGas) String() string { return proto.CompactTextString(m) }
func (*RechargeGas) ProtoMessage()    {}
func (*RechargeGas) Descriptor() ([]byte, []int) {
	return fileDescriptor_816aa64736f82c70, []int{2}
}
func (m *RechargeGas) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RechargeGas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RechargeGas.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RechargeGas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RechargeGas.Merge(m, src)
}
func (m *RechargeGas) XXX_Size() int {
	return m.Size()
}
func (m *RechargeGas) XXX_DiscardUnknown() {
	xxx_messageInfo_RechargeGas.DiscardUnknown(m)
}

var xxx_messageInfo_RechargeGas proto.InternalMessageInfo

func (m *RechargeGas) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *RechargeGas) GetGasAmount() int64 {
	if m != nil {
		return m.GasAmount
	}
	return 0
}

type RechargeGasReq struct {
	BatchRechargeGas []*RechargeGas `protobuf:"bytes,1,rep,name=batch_recharge_gas,json=batchRechargeGas,proto3" json:"batch_recharge_gas,omitempty"`
}

func (m *RechargeGasReq) Reset()         { *m = RechargeGasReq{} }
func (m *RechargeGasReq) String() string { return proto.CompactTextString(m) }
func (*RechargeGasReq) ProtoMessage()    {}
func (*RechargeGasReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_816aa64736f82c70, []int{3}
}
func (m *RechargeGasReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RechargeGasReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RechargeGasReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RechargeGasReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RechargeGasReq.Merge(m, src)
}
func (m *RechargeGasReq) XXX_Size() int {
	return m.Size()
}
func (m *RechargeGasReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RechargeGasReq.DiscardUnknown(m)
}

var xxx_messageInfo_RechargeGasReq proto.InternalMessageInfo

func (m *RechargeGasReq) GetBatchRechargeGas() []*RechargeGas {
	if m != nil {
		return m.BatchRechargeGas
	}
	return nil
}

func init() {
	proto.RegisterEnum("syscontract.GasAccountFunction", GasAccountFunction_name, GasAccountFunction_value)
	proto.RegisterType((*AccountMultiSign)(nil), "syscontract.AccountMultiSign")
	proto.RegisterType((*AccountMultiSignsReq)(nil), "syscontract.AccountMultiSignsReq")
	proto.RegisterType((*RechargeGas)(nil), "syscontract.RechargeGas")
	proto.RegisterType((*RechargeGasReq)(nil), "syscontract.RechargeGasReq")
}

func init() { proto.RegisterFile("syscontract/account_manager.proto", fileDescriptor_816aa64736f82c70) }

var fileDescriptor_816aa64736f82c70 = []byte{
	// 486 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x5c, 0x52, 0xd1, 0x6e, 0xda, 0x30,
	0x14, 0x25, 0x65, 0x6b, 0xcb, 0xa5, 0x80, 0x67, 0xf5, 0x01, 0x4d, 0x23, 0xeb, 0x78, 0x98, 0xaa,
	0x49, 0x03, 0xa9, 0xfb, 0x82, 0x94, 0x26, 0x0c, 0xad, 0x04, 0xc9, 0x90, 0x69, 0xaa, 0x34, 0x59,
	0x8e, 0x49, 0x4d, 0x54, 0xb0, 0x59, 0x1c, 0x36, 0xf1, 0x17, 0xfb, 0xac, 0x3d, 0xf6, 0x71, 0x8f,
	0x13, 0xbc, 0xec, 0x33, 0x26, 0x07, 0x0a, 0x19, 0x8f, 0xe7, 0xf8, 0xdc, 0x73, 0xce, 0xb5, 0x2e,
	0xbc, 0xd1, 0x4b, 0xcd, 0x95, 0x4c, 0x13, 0xc6, 0xd3, 0x36, 0xe3, 0x5c, 0x2d, 0x64, 0x4a, 0x67,
	0x4c, 0x32, 0x11, 0x25, 0xad, 0x79, 0xa2, 0x52, 0x85, 0xcb, 0x39, 0x49, 0xf3, 0x07, 0x20, 0x67,
	0xa3, 0xea, 0x2f, 0xa6, 0x69, 0x3c, 0x8c, 0x85, 0xc4, 0x2f, 0xe1, 0x74, 0xce, 0x96, 0x53, 0xc5,
	0xc6, 0xba, 0x6e, 0x5d, 0x58, 0x97, 0x67, 0x64, 0x87, 0xf1, 0x6b, 0x28, 0xf3, 0x69, 0x1c, 0xc9,
	0x94, 0xea, 0x58, 0xc8, 0xfa, 0x51, 0xf6, 0x0c, 0x1b, 0x2a, 0x1b, 0x7e, 0x0b, 0xb5, 0xf9, 0x22,
	0x9c, 0xc6, 0x9c, 0x3e, 0x44, 0x4b, 0x1a, 0xcb, 0x7b, 0x55, 0x2f, 0x66, 0xa2, 0xca, 0x86, 0xfe,
	0x14, 0x2d, 0x7b, 0xf2, 0x5e, 0x35, 0xbf, 0xc2, 0xf9, 0x61, 0xb0, 0x26, 0xd1, 0x37, 0xec, 0x42,
	0x4d, 0x30, 0x4d, 0x67, 0x86, 0xcc, 0x32, 0x4c, 0x87, 0xe2, 0x65, 0xf9, 0xaa, 0xd1, 0xca, 0xf5,
	0x6e, 0x1d, 0xce, 0x92, 0x8a, 0x60, 0x7a, 0xef, 0xd4, 0xf4, 0xa0, 0x4c, 0x22, 0x3e, 0x61, 0x89,
	0x88, 0xba, 0x4c, 0xe3, 0x3a, 0x9c, 0xb0, 0xf1, 0x38, 0x89, 0xf4, 0x66, 0xa3, 0x12, 0x79, 0x82,
	0xb8, 0x01, 0x60, 0xf2, 0xd8, 0xcc, 0xd8, 0x65, 0xfb, 0x14, 0x49, 0x49, 0x30, 0xed, 0x64, 0x44,
	0xf3, 0x0b, 0x54, 0x73, 0x3e, 0xa6, 0xa0, 0x07, 0x38, 0x64, 0x29, 0x9f, 0xd0, 0x64, 0xcb, 0x53,
	0xc1, 0x9e, 0x3a, 0xd6, 0xff, 0xeb, 0x98, 0x1f, 0x44, 0xd9, 0x4c, 0x8e, 0x79, 0xf7, 0xd7, 0x02,
	0xdc, 0x65, 0x7a, 0xbb, 0x88, 0xb7, 0x90, 0x3c, 0x8d, 0x95, 0xc4, 0x15, 0x28, 0x0d, 0xdd, 0x11,
	0x75, 0x6e, 0xfa, 0x3d, 0x1f, 0x15, 0x0c, 0xec, 0xee, 0xa0, 0x85, 0x11, 0x9c, 0x11, 0xb7, 0xf3,
	0xd1, 0x21, 0x5d, 0x97, 0x76, 0x9d, 0x21, 0x3a, 0xc2, 0x35, 0x28, 0x1b, 0xc1, 0xb5, 0x73, 0xeb,
	0xf8, 0x1d, 0x17, 0x15, 0x71, 0x15, 0x20, 0x27, 0x78, 0x86, 0x31, 0x54, 0x3d, 0x32, 0xb8, 0x73,
	0x7d, 0xea, 0x74, 0x3a, 0x83, 0xc0, 0x1f, 0xa1, 0xe7, 0xf8, 0x1c, 0x50, 0xe0, 0x1f, 0xb0, 0xc7,
	0x46, 0xb9, 0x05, 0x74, 0x38, 0x72, 0x46, 0xc1, 0x10, 0x9d, 0x18, 0x37, 0xe2, 0x7a, 0x81, 0x7f,
	0x93, 0xb9, 0x9d, 0xe2, 0x17, 0x50, 0xd9, 0x63, 0xfa, 0xb9, 0x8f, 0x4a, 0xf8, 0x02, 0x5e, 0xed,
	0x03, 0xa9, 0x37, 0x20, 0xb4, 0x1f, 0xdc, 0x8e, 0x7a, 0x3b, 0x63, 0xb8, 0x16, 0xbf, 0x56, 0xb6,
	0xf5, 0xb8, 0xb2, 0xad, 0x3f, 0x2b, 0xdb, 0xfa, 0xb9, 0xb6, 0x0b, 0x8f, 0x6b, 0xbb, 0xf0, 0x7b,
	0x6d, 0x17, 0xa0, 0xa1, 0x12, 0xd1, 0xe2, 0x13, 0x16, 0xcb, 0x19, 0x7b, 0x30, 0x17, 0x1a, 0xe6,
	0x7f, 0xf0, 0x2e, 0xff, 0xa4, 0x12, 0xd1, 0xde, 0xc3, 0xf6, 0x3c, 0x7c, 0x2f, 0x54, 0xfb, 0xfb,
	0x55, 0x3b, 0xa7, 0x0f, 0x8f, 0xb3, 0x0b, 0xff, 0xf0, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x06, 0x05,
	0x84, 0x73, 0x06, 0x03, 0x00, 0x00,
}

func (m *AccountMultiSign) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountMultiSign) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountMultiSign) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PublicKeyInfo) > 0 {
		i -= len(m.PublicKeyInfo)
		copy(dAtA[i:], m.PublicKeyInfo)
		i = encodeVarintAccountManager(dAtA, i, uint64(len(m.PublicKeyInfo)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClientSign) > 0 {
		i -= len(m.ClientSign)
		copy(dAtA[i:], m.ClientSign)
		i = encodeVarintAccountManager(dAtA, i, uint64(len(m.ClientSign)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Payloads) > 0 {
		i -= len(m.Payloads)
		copy(dAtA[i:], m.Payloads)
		i = encodeVarintAccountManager(dAtA, i, uint64(len(m.Payloads)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccountMultiSignsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountMultiSignsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountMultiSignsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GasMultiSigns) > 0 {
		for iNdEx := len(m.GasMultiSigns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GasMultiSigns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAccountManager(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RechargeGas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RechargeGas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RechargeGas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GasAmount != 0 {
		i = encodeVarintAccountManager(dAtA, i, uint64(m.GasAmount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintAccountManager(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RechargeGasReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RechargeGasReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RechargeGasReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BatchRechargeGas) > 0 {
		for iNdEx := len(m.BatchRechargeGas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BatchRechargeGas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAccountManager(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintAccountManager(dAtA []byte, offset int, v uint64) int {
	offset -= sovAccountManager(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AccountMultiSign) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payloads)
	if l > 0 {
		n += 1 + l + sovAccountManager(uint64(l))
	}
	l = len(m.ClientSign)
	if l > 0 {
		n += 1 + l + sovAccountManager(uint64(l))
	}
	l = len(m.PublicKeyInfo)
	if l > 0 {
		n += 1 + l + sovAccountManager(uint64(l))
	}
	return n
}

func (m *AccountMultiSignsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GasMultiSigns) > 0 {
		for _, e := range m.GasMultiSigns {
			l = e.Size()
			n += 1 + l + sovAccountManager(uint64(l))
		}
	}
	return n
}

func (m *RechargeGas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAccountManager(uint64(l))
	}
	if m.GasAmount != 0 {
		n += 1 + sovAccountManager(uint64(m.GasAmount))
	}
	return n
}

func (m *RechargeGasReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BatchRechargeGas) > 0 {
		for _, e := range m.BatchRechargeGas {
			l = e.Size()
			n += 1 + l + sovAccountManager(uint64(l))
		}
	}
	return n
}

func sovAccountManager(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAccountManager(x uint64) (n int) {
	return sovAccountManager(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AccountMultiSign) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccountManager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountMultiSign: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountMultiSign: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payloads", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAccountManager
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payloads = append(m.Payloads[:0], dAtA[iNdEx:postIndex]...)
			if m.Payloads == nil {
				m.Payloads = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSign", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAccountManager
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientSign = append(m.ClientSign[:0], dAtA[iNdEx:postIndex]...)
			if m.ClientSign == nil {
				m.ClientSign = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeyInfo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAccountManager
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeyInfo = append(m.PublicKeyInfo[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKeyInfo == nil {
				m.PublicKeyInfo = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccountManager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAccountManager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountMultiSignsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccountManager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountMultiSignsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountMultiSignsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasMultiSigns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccountManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccountManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GasMultiSigns = append(m.GasMultiSigns, &AccountMultiSign{})
			if err := m.GasMultiSigns[len(m.GasMultiSigns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccountManager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAccountManager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RechargeGas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccountManager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RechargeGas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RechargeGas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountManager
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasAmount", wireType)
			}
			m.GasAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasAmount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccountManager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAccountManager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RechargeGasReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccountManager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RechargeGasReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RechargeGasReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchRechargeGas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccountManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccountManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchRechargeGas = append(m.BatchRechargeGas, &RechargeGas{})
			if err := m.BatchRechargeGas[len(m.BatchRechargeGas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccountManager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAccountManager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAccountManager(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAccountManager
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAccountManager
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAccountManager
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAccountManager
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAccountManager
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAccountManager
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAccountManager        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAccountManager          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAccountManager = fmt.Errorf("proto: unexpected end of group")
)
