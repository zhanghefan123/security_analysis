// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: config/chain_config.proto

package config

import (
	accesscontrol "zhanghefan123/security/protobuf/pb-go/accesscontrol"
	consensus "zhanghefan123/security/protobuf/pb-go/consensus"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type AddrType int32

const (
	AddrType_CHAINMAKER AddrType = 0
	AddrType_ZXL        AddrType = 1
	AddrType_ETHEREUM   AddrType = 2
)

var AddrType_name = map[int32]string{
	0: "CHAINMAKER",
	1: "ZXL",
	2: "ETHEREUM",
}

var AddrType_value = map[string]int32{
	"CHAINMAKER": 0,
	"ZXL":        1,
	"ETHEREUM":   2,
}

func (x AddrType) String() string {
	return proto.EnumName(AddrType_name, int32(x))
}

func (AddrType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{0}
}

// a string k-v pair for config
type ConfigKeyValue struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *ConfigKeyValue) Reset()         { *m = ConfigKeyValue{} }
func (m *ConfigKeyValue) String() string { return proto.CompactTextString(m) }
func (*ConfigKeyValue) ProtoMessage()    {}
func (*ConfigKeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{0}
}
func (m *ConfigKeyValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigKeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigKeyValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigKeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigKeyValue.Merge(m, src)
}
func (m *ConfigKeyValue) XXX_Size() int {
	return m.Size()
}
func (m *ConfigKeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigKeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigKeyValue proto.InternalMessageInfo

func (m *ConfigKeyValue) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *ConfigKeyValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// ChainConfig
type ChainConfig struct {
	// blockchain identifier
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// blockchain version
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// member type
	AuthType string `protobuf:"bytes,3,opt,name=auth_type,json=authType,proto3" json:"auth_type,omitempty"`
	// config sequence
	Sequence uint64 `protobuf:"varint,4,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// encryption algorithm related configuration
	Crypto *CryptoConfig `protobuf:"bytes,5,opt,name=crypto,proto3" json:"crypto,omitempty"`
	// block related configuration
	Block *BlockConfig `protobuf:"bytes,6,opt,name=block,proto3" json:"block,omitempty"`
	// core module related configuration
	Core *CoreConfig `protobuf:"bytes,7,opt,name=core,proto3" json:"core,omitempty"`
	// consensus related configuration
	Consensus *ConsensusConfig `protobuf:"bytes,8,opt,name=consensus,proto3" json:"consensus,omitempty"`
	// trusted root related configuration
	// for alliance members, the initial member's root info of the consortium; for public chain, there is no need to configure
	// Key: node_id; value: address, node public key / CA certificate
	TrustRoots   []*TrustRootConfig   `protobuf:"bytes,9,rep,name=trust_roots,json=trustRoots,proto3" json:"trust_roots,omitempty"`
	TrustMembers []*TrustMemberConfig `protobuf:"bytes,10,rep,name=trust_members,json=trustMembers,proto3" json:"trust_members,omitempty"`
	// permission related configuration
	ResourcePolicies []*ResourcePolicy `protobuf:"bytes,11,rep,name=resource_policies,json=resourcePolicies,proto3" json:"resource_policies,omitempty"`
	Contract         *ContractConfig   `protobuf:"bytes,12,opt,name=contract,proto3" json:"contract,omitempty"`
	// snapshot module related configuration
	Snapshot *SnapshotConfig `protobuf:"bytes,13,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
	// scheduler module related configuration
	Scheduler *SchedulerConfig `protobuf:"bytes,14,opt,name=scheduler,proto3" json:"scheduler,omitempty"`
	// tx sim context module related configuration
	Context *ContextConfig `protobuf:"bytes,15,opt,name=context,proto3" json:"context,omitempty"`
	// disabled native contracts list for permission control purposes
	DisabledNativeContract []string `protobuf:"bytes,16,rep,name=disabled_native_contract,json=disabledNativeContract,proto3" json:"disabled_native_contract,omitempty"`
	// gas account config
	AccountConfig *GasAccountConfig `protobuf:"bytes,18,opt,name=account_config,json=accountConfig,proto3" json:"account_config,omitempty"`
	// vm config
	Vm *Vm `protobuf:"bytes,17,opt,name=vm,proto3" json:"vm,omitempty"`
}

func (m *ChainConfig) Reset()         { *m = ChainConfig{} }
func (m *ChainConfig) String() string { return proto.CompactTextString(m) }
func (*ChainConfig) ProtoMessage()    {}
func (*ChainConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{1}
}
func (m *ChainConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChainConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainConfig.Merge(m, src)
}
func (m *ChainConfig) XXX_Size() int {
	return m.Size()
}
func (m *ChainConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ChainConfig proto.InternalMessageInfo

func (m *ChainConfig) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *ChainConfig) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ChainConfig) GetAuthType() string {
	if m != nil {
		return m.AuthType
	}
	return ""
}

func (m *ChainConfig) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *ChainConfig) GetCrypto() *CryptoConfig {
	if m != nil {
		return m.Crypto
	}
	return nil
}

func (m *ChainConfig) GetBlock() *BlockConfig {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *ChainConfig) GetCore() *CoreConfig {
	if m != nil {
		return m.Core
	}
	return nil
}

func (m *ChainConfig) GetConsensus() *ConsensusConfig {
	if m != nil {
		return m.Consensus
	}
	return nil
}

func (m *ChainConfig) GetTrustRoots() []*TrustRootConfig {
	if m != nil {
		return m.TrustRoots
	}
	return nil
}

func (m *ChainConfig) GetTrustMembers() []*TrustMemberConfig {
	if m != nil {
		return m.TrustMembers
	}
	return nil
}

func (m *ChainConfig) GetResourcePolicies() []*ResourcePolicy {
	if m != nil {
		return m.ResourcePolicies
	}
	return nil
}

func (m *ChainConfig) GetContract() *ContractConfig {
	if m != nil {
		return m.Contract
	}
	return nil
}

func (m *ChainConfig) GetSnapshot() *SnapshotConfig {
	if m != nil {
		return m.Snapshot
	}
	return nil
}

func (m *ChainConfig) GetScheduler() *SchedulerConfig {
	if m != nil {
		return m.Scheduler
	}
	return nil
}

func (m *ChainConfig) GetContext() *ContextConfig {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *ChainConfig) GetDisabledNativeContract() []string {
	if m != nil {
		return m.DisabledNativeContract
	}
	return nil
}

func (m *ChainConfig) GetAccountConfig() *GasAccountConfig {
	if m != nil {
		return m.AccountConfig
	}
	return nil
}

func (m *ChainConfig) GetVm() *Vm {
	if m != nil {
		return m.Vm
	}
	return nil
}

// specific permission configuration structure
type ResourcePolicy struct {
	// resource name
	ResourceName string `protobuf:"bytes,1,opt,name=resource_name,json=resourceName,proto3" json:"resource_name,omitempty"`
	// policy(permission)
	Policy *accesscontrol.Policy `protobuf:"bytes,2,opt,name=policy,proto3" json:"policy,omitempty"`
}

func (m *ResourcePolicy) Reset()         { *m = ResourcePolicy{} }
func (m *ResourcePolicy) String() string { return proto.CompactTextString(m) }
func (*ResourcePolicy) ProtoMessage()    {}
func (*ResourcePolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{2}
}
func (m *ResourcePolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourcePolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourcePolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourcePolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourcePolicy.Merge(m, src)
}
func (m *ResourcePolicy) XXX_Size() int {
	return m.Size()
}
func (m *ResourcePolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourcePolicy.DiscardUnknown(m)
}

var xxx_messageInfo_ResourcePolicy proto.InternalMessageInfo

func (m *ResourcePolicy) GetResourceName() string {
	if m != nil {
		return m.ResourceName
	}
	return ""
}

func (m *ResourcePolicy) GetPolicy() *accesscontrol.Policy {
	if m != nil {
		return m.Policy
	}
	return nil
}

// encryption configuration
type CryptoConfig struct {
	// enable Transaction timestamp verification or Not
	Hash string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *CryptoConfig) Reset()         { *m = CryptoConfig{} }
func (m *CryptoConfig) String() string { return proto.CompactTextString(m) }
func (*CryptoConfig) ProtoMessage()    {}
func (*CryptoConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{3}
}
func (m *CryptoConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CryptoConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CryptoConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CryptoConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CryptoConfig.Merge(m, src)
}
func (m *CryptoConfig) XXX_Size() int {
	return m.Size()
}
func (m *CryptoConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CryptoConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CryptoConfig proto.InternalMessageInfo

func (m *CryptoConfig) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

// blockConfig
type BlockConfig struct {
	// enable transaction timestamp verification or Not
	TxTimestampVerify bool `protobuf:"varint,1,opt,name=tx_timestamp_verify,json=txTimestampVerify,proto3" json:"tx_timestamp_verify,omitempty"`
	// expiration time of transaction timestamp (seconds)
	TxTimeout uint32 `protobuf:"varint,2,opt,name=tx_timeout,json=txTimeout,proto3" json:"tx_timeout,omitempty"`
	// maximum number of transactions in a block
	BlockTxCapacity uint32 `protobuf:"varint,3,opt,name=block_tx_capacity,json=blockTxCapacity,proto3" json:"block_tx_capacity,omitempty"`
	// maximum block size, in MB
	BlockSize uint32 `protobuf:"varint,4,opt,name=block_size,json=blockSize,proto3" json:"block_size,omitempty"`
	// block proposing interval, in ms
	BlockInterval uint32 `protobuf:"varint,5,opt,name=block_interval,json=blockInterval,proto3" json:"block_interval,omitempty"`
	// maximum size of transaction's parameter, in MB
	TxParameterSize uint32 `protobuf:"varint,6,opt,name=tx_parameter_size,json=txParameterSize,proto3" json:"tx_parameter_size,omitempty"`
}

func (m *BlockConfig) Reset()         { *m = BlockConfig{} }
func (m *BlockConfig) String() string { return proto.CompactTextString(m) }
func (*BlockConfig) ProtoMessage()    {}
func (*BlockConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{4}
}
func (m *BlockConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockConfig.Merge(m, src)
}
func (m *BlockConfig) XXX_Size() int {
	return m.Size()
}
func (m *BlockConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockConfig.DiscardUnknown(m)
}

var xxx_messageInfo_BlockConfig proto.InternalMessageInfo

func (m *BlockConfig) GetTxTimestampVerify() bool {
	if m != nil {
		return m.TxTimestampVerify
	}
	return false
}

func (m *BlockConfig) GetTxTimeout() uint32 {
	if m != nil {
		return m.TxTimeout
	}
	return 0
}

func (m *BlockConfig) GetBlockTxCapacity() uint32 {
	if m != nil {
		return m.BlockTxCapacity
	}
	return 0
}

func (m *BlockConfig) GetBlockSize() uint32 {
	if m != nil {
		return m.BlockSize
	}
	return 0
}

func (m *BlockConfig) GetBlockInterval() uint32 {
	if m != nil {
		return m.BlockInterval
	}
	return 0
}

func (m *BlockConfig) GetTxParameterSize() uint32 {
	if m != nil {
		return m.TxParameterSize
	}
	return 0
}

// Scheduler configuration
type SchedulerConfig struct {
	// for evidence contract
	EnableEvidence bool `protobuf:"varint,1,opt,name=enable_evidence,json=enableEvidence,proto3" json:"enable_evidence,omitempty"`
}

func (m *SchedulerConfig) Reset()         { *m = SchedulerConfig{} }
func (m *SchedulerConfig) String() string { return proto.CompactTextString(m) }
func (*SchedulerConfig) ProtoMessage()    {}
func (*SchedulerConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{5}
}
func (m *SchedulerConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchedulerConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchedulerConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchedulerConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchedulerConfig.Merge(m, src)
}
func (m *SchedulerConfig) XXX_Size() int {
	return m.Size()
}
func (m *SchedulerConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SchedulerConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SchedulerConfig proto.InternalMessageInfo

func (m *SchedulerConfig) GetEnableEvidence() bool {
	if m != nil {
		return m.EnableEvidence
	}
	return false
}

// gas account config
type GasAccountConfig struct {
	// for admin address
	GasAdminAddress string `protobuf:"bytes,1,opt,name=gas_admin_address,json=gasAdminAddress,proto3" json:"gas_admin_address,omitempty"`
	// for admin gas count
	GasCount uint32 `protobuf:"varint,2,opt,name=gas_count,json=gasCount,proto3" json:"gas_count,omitempty"`
	// for gas manager
	EnableGas bool `protobuf:"varint,3,opt,name=enable_gas,json=enableGas,proto3" json:"enable_gas,omitempty"`
	// default gas value for invoke user contract
	DefaultGas uint64 `protobuf:"varint,4,opt,name=default_gas,json=defaultGas,proto3" json:"default_gas,omitempty"`
	// default gas price per `byte` for invoke user contract
	DefaultGasPrice float32 `protobuf:"fixed32,5,opt,name=default_gas_price,json=defaultGasPrice,proto3" json:"default_gas_price,omitempty"`
	// default gas value for install/upgrade user contract
	InstallBaseGas uint64 `protobuf:"varint,6,opt,name=install_base_gas,json=installBaseGas,proto3" json:"install_base_gas,omitempty"`
	// default gas price per `byte` for install/upgrade user contract
	InstallGasPrice float32 `protobuf:"fixed32,7,opt,name=install_gas_price,json=installGasPrice,proto3" json:"install_gas_price,omitempty"`
}

func (m *GasAccountConfig) Reset()         { *m = GasAccountConfig{} }
func (m *GasAccountConfig) String() string { return proto.CompactTextString(m) }
func (*GasAccountConfig) ProtoMessage()    {}
func (*GasAccountConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{6}
}
func (m *GasAccountConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GasAccountConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GasAccountConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GasAccountConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GasAccountConfig.Merge(m, src)
}
func (m *GasAccountConfig) XXX_Size() int {
	return m.Size()
}
func (m *GasAccountConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GasAccountConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GasAccountConfig proto.InternalMessageInfo

func (m *GasAccountConfig) GetGasAdminAddress() string {
	if m != nil {
		return m.GasAdminAddress
	}
	return ""
}

func (m *GasAccountConfig) GetGasCount() uint32 {
	if m != nil {
		return m.GasCount
	}
	return 0
}

func (m *GasAccountConfig) GetEnableGas() bool {
	if m != nil {
		return m.EnableGas
	}
	return false
}

func (m *GasAccountConfig) GetDefaultGas() uint64 {
	if m != nil {
		return m.DefaultGas
	}
	return 0
}

func (m *GasAccountConfig) GetDefaultGasPrice() float32 {
	if m != nil {
		return m.DefaultGasPrice
	}
	return 0
}

func (m *GasAccountConfig) GetInstallBaseGas() uint64 {
	if m != nil {
		return m.InstallBaseGas
	}
	return 0
}

func (m *GasAccountConfig) GetInstallGasPrice() float32 {
	if m != nil {
		return m.InstallGasPrice
	}
	return 0
}

// Snapshot configuration
type SnapshotConfig struct {
	// for the evidence contract
	EnableEvidence bool `protobuf:"varint,1,opt,name=enable_evidence,json=enableEvidence,proto3" json:"enable_evidence,omitempty"`
}

func (m *SnapshotConfig) Reset()         { *m = SnapshotConfig{} }
func (m *SnapshotConfig) String() string { return proto.CompactTextString(m) }
func (*SnapshotConfig) ProtoMessage()    {}
func (*SnapshotConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{7}
}
func (m *SnapshotConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotConfig.Merge(m, src)
}
func (m *SnapshotConfig) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotConfig proto.InternalMessageInfo

func (m *SnapshotConfig) GetEnableEvidence() bool {
	if m != nil {
		return m.EnableEvidence
	}
	return false
}

// TxSimContext configuration
type ContextConfig struct {
	// for the evidence contract
	EnableEvidence bool `protobuf:"varint,1,opt,name=enable_evidence,json=enableEvidence,proto3" json:"enable_evidence,omitempty"`
}

func (m *ContextConfig) Reset()         { *m = ContextConfig{} }
func (m *ContextConfig) String() string { return proto.CompactTextString(m) }
func (*ContextConfig) ProtoMessage()    {}
func (*ContextConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{8}
}
func (m *ContextConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContextConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContextConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContextConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContextConfig.Merge(m, src)
}
func (m *ContextConfig) XXX_Size() int {
	return m.Size()
}
func (m *ContextConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ContextConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ContextConfig proto.InternalMessageInfo

func (m *ContextConfig) GetEnableEvidence() bool {
	if m != nil {
		return m.EnableEvidence
	}
	return false
}

// consensus message turbo configuration
type ConsensusTurboConfig struct {
	// switch of consensus message turbo
	ConsensusMessageTurbo bool `protobuf:"varint,1,opt,name=consensus_message_turbo,json=consensusMessageTurbo,proto3" json:"consensus_message_turbo,omitempty"`
	// retry time of get tx by txIds from txpool
	RetryTime uint64 `protobuf:"varint,2,opt,name=retry_time,json=retryTime,proto3" json:"retry_time,omitempty"`
	// the interval of retry get tx by txIds from txpool(ms)
	RetryInterval uint64 `protobuf:"varint,3,opt,name=retry_interval,json=retryInterval,proto3" json:"retry_interval,omitempty"`
}

func (m *ConsensusTurboConfig) Reset()         { *m = ConsensusTurboConfig{} }
func (m *ConsensusTurboConfig) String() string { return proto.CompactTextString(m) }
func (*ConsensusTurboConfig) ProtoMessage()    {}
func (*ConsensusTurboConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{9}
}
func (m *ConsensusTurboConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusTurboConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusTurboConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusTurboConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusTurboConfig.Merge(m, src)
}
func (m *ConsensusTurboConfig) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusTurboConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusTurboConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusTurboConfig proto.InternalMessageInfo

func (m *ConsensusTurboConfig) GetConsensusMessageTurbo() bool {
	if m != nil {
		return m.ConsensusMessageTurbo
	}
	return false
}

func (m *ConsensusTurboConfig) GetRetryTime() uint64 {
	if m != nil {
		return m.RetryTime
	}
	return 0
}

func (m *ConsensusTurboConfig) GetRetryInterval() uint64 {
	if m != nil {
		return m.RetryInterval
	}
	return 0
}

// core module related configuration
type CoreConfig struct {
	// [0, 60], the time when the transaction scheduler gets the transaction from the transaction pool to schedule
	TxSchedulerTimeout uint64 `protobuf:"varint,1,opt,name=tx_scheduler_timeout,json=txSchedulerTimeout,proto3" json:"tx_scheduler_timeout,omitempty"`
	// [0, 60], the time-out for verification after the transaction scheduler obtains the transaction from the block
	TxSchedulerValidateTimeout uint64 `protobuf:"varint,2,opt,name=tx_scheduler_validate_timeout,json=txSchedulerValidateTimeout,proto3" json:"tx_scheduler_validate_timeout,omitempty"`
	// the configuration of consensus message turbo
	ConsensusTurboConfig *ConsensusTurboConfig `protobuf:"bytes,3,opt,name=consensus_turbo_config,json=consensusTurboConfig,proto3" json:"consensus_turbo_config,omitempty"`
	// enable sender group, used for handling txs with sender conflicts efficiently
	EnableSenderGroup bool `protobuf:"varint,4,opt,name=enable_sender_group,json=enableSenderGroup,proto3" json:"enable_sender_group,omitempty"`
	// enable conflicts bit window, used for dynamic tuning the capacity of tx execution goroutine pool
	EnableConflictsBitWindow bool `protobuf:"varint,5,opt,name=enable_conflicts_bit_window,json=enableConflictsBitWindow,proto3" json:"enable_conflicts_bit_window,omitempty"`
	// enable optimize charge gas for the same account transactions
	EnableOptimizeChargeGas bool `protobuf:"varint,6,opt,name=enable_optimize_charge_gas,json=enableOptimizeChargeGas,proto3" json:"enable_optimize_charge_gas,omitempty"`
}

func (m *CoreConfig) Reset()         { *m = CoreConfig{} }
func (m *CoreConfig) String() string { return proto.CompactTextString(m) }
func (*CoreConfig) ProtoMessage()    {}
func (*CoreConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{10}
}
func (m *CoreConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoreConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoreConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CoreConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoreConfig.Merge(m, src)
}
func (m *CoreConfig) XXX_Size() int {
	return m.Size()
}
func (m *CoreConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CoreConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CoreConfig proto.InternalMessageInfo

func (m *CoreConfig) GetTxSchedulerTimeout() uint64 {
	if m != nil {
		return m.TxSchedulerTimeout
	}
	return 0
}

func (m *CoreConfig) GetTxSchedulerValidateTimeout() uint64 {
	if m != nil {
		return m.TxSchedulerValidateTimeout
	}
	return 0
}

func (m *CoreConfig) GetConsensusTurboConfig() *ConsensusTurboConfig {
	if m != nil {
		return m.ConsensusTurboConfig
	}
	return nil
}

func (m *CoreConfig) GetEnableSenderGroup() bool {
	if m != nil {
		return m.EnableSenderGroup
	}
	return false
}

func (m *CoreConfig) GetEnableConflictsBitWindow() bool {
	if m != nil {
		return m.EnableConflictsBitWindow
	}
	return false
}

func (m *CoreConfig) GetEnableOptimizeChargeGas() bool {
	if m != nil {
		return m.EnableOptimizeChargeGas
	}
	return false
}

// consensus module related configuration
type ConsensusConfig struct {
	// consensus type
	Type consensus.ConsensusType `protobuf:"varint,1,opt,name=type,proto3,enum=consensus.ConsensusType" json:"type,omitempty"`
	// organization list of nodes
	Nodes []*OrgConfig `protobuf:"bytes,2,rep,name=nodes,proto3" json:"nodes,omitempty"`
	// expand the field, record the difficulty, reward and other consensus algorithm configuration
	ExtConfig []*ConfigKeyValue `protobuf:"bytes,3,rep,name=ext_config,json=extConfig,proto3" json:"ext_config,omitempty"`
	// Initialize the configuration of DPOS
	DposConfig []*ConfigKeyValue `protobuf:"bytes,4,rep,name=dpos_config,json=dposConfig,proto3" json:"dpos_config,omitempty"`
}

func (m *ConsensusConfig) Reset()         { *m = ConsensusConfig{} }
func (m *ConsensusConfig) String() string { return proto.CompactTextString(m) }
func (*ConsensusConfig) ProtoMessage()    {}
func (*ConsensusConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{11}
}
func (m *ConsensusConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusConfig.Merge(m, src)
}
func (m *ConsensusConfig) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusConfig proto.InternalMessageInfo

func (m *ConsensusConfig) GetType() consensus.ConsensusType {
	if m != nil {
		return m.Type
	}
	return consensus.ConsensusType_SOLO
}

func (m *ConsensusConfig) GetNodes() []*OrgConfig {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *ConsensusConfig) GetExtConfig() []*ConfigKeyValue {
	if m != nil {
		return m.ExtConfig
	}
	return nil
}

func (m *ConsensusConfig) GetDposConfig() []*ConfigKeyValue {
	if m != nil {
		return m.DposConfig
	}
	return nil
}

// organization related configuration
type OrgConfig struct {
	// organization identifier
	OrgId string `protobuf:"bytes,1,opt,name=org_id,json=orgId,proto3" json:"org_id,omitempty"`
	// address list owned by the organization
	// Deprecated , replace by node_id
	Address []string `protobuf:"bytes,2,rep,name=address,proto3" json:"address,omitempty"`
	// node id list owned by the organization
	NodeId []string `protobuf:"bytes,3,rep,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *OrgConfig) Reset()         { *m = OrgConfig{} }
func (m *OrgConfig) String() string { return proto.CompactTextString(m) }
func (*OrgConfig) ProtoMessage()    {}
func (*OrgConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{12}
}
func (m *OrgConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrgConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrgConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrgConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrgConfig.Merge(m, src)
}
func (m *OrgConfig) XXX_Size() int {
	return m.Size()
}
func (m *OrgConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_OrgConfig.DiscardUnknown(m)
}

var xxx_messageInfo_OrgConfig proto.InternalMessageInfo

func (m *OrgConfig) GetOrgId() string {
	if m != nil {
		return m.OrgId
	}
	return ""
}

func (m *OrgConfig) GetAddress() []string {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *OrgConfig) GetNodeId() []string {
	if m != nil {
		return m.NodeId
	}
	return nil
}

// trusted root related configuration
type TrustRootConfig struct {
	// oranization ideftifier
	OrgId string `protobuf:"bytes,1,opt,name=org_id,json=orgId,proto3" json:"org_id,omitempty"`
	// root certificate / public key
	Root []string `protobuf:"bytes,2,rep,name=root,proto3" json:"root,omitempty"`
}

func (m *TrustRootConfig) Reset()         { *m = TrustRootConfig{} }
func (m *TrustRootConfig) String() string { return proto.CompactTextString(m) }
func (*TrustRootConfig) ProtoMessage()    {}
func (*TrustRootConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{13}
}
func (m *TrustRootConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrustRootConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrustRootConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrustRootConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrustRootConfig.Merge(m, src)
}
func (m *TrustRootConfig) XXX_Size() int {
	return m.Size()
}
func (m *TrustRootConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TrustRootConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TrustRootConfig proto.InternalMessageInfo

func (m *TrustRootConfig) GetOrgId() string {
	if m != nil {
		return m.OrgId
	}
	return ""
}

func (m *TrustRootConfig) GetRoot() []string {
	if m != nil {
		return m.Root
	}
	return nil
}

type ContractConfig struct {
	EnableSqlSupport bool `protobuf:"varint,1,opt,name=enable_sql_support,json=enableSqlSupport,proto3" json:"enable_sql_support,omitempty"`
	// disabled native contracts list for permission control purposes
	DisabledNativeContract []string `protobuf:"bytes,2,rep,name=disabled_native_contract,json=disabledNativeContract,proto3" json:"disabled_native_contract,omitempty"`
	// If it is true, Only creators are allowed to upgrade contract.
	OnlyCreatorCanUpgrade bool `protobuf:"varint,3,opt,name=only_creator_can_upgrade,json=onlyCreatorCanUpgrade,proto3" json:"only_creator_can_upgrade,omitempty"`
}

func (m *ContractConfig) Reset()         { *m = ContractConfig{} }
func (m *ContractConfig) String() string { return proto.CompactTextString(m) }
func (*ContractConfig) ProtoMessage()    {}
func (*ContractConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{14}
}
func (m *ContractConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractConfig.Merge(m, src)
}
func (m *ContractConfig) XXX_Size() int {
	return m.Size()
}
func (m *ContractConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ContractConfig proto.InternalMessageInfo

func (m *ContractConfig) GetEnableSqlSupport() bool {
	if m != nil {
		return m.EnableSqlSupport
	}
	return false
}

func (m *ContractConfig) GetDisabledNativeContract() []string {
	if m != nil {
		return m.DisabledNativeContract
	}
	return nil
}

func (m *ContractConfig) GetOnlyCreatorCanUpgrade() bool {
	if m != nil {
		return m.OnlyCreatorCanUpgrade
	}
	return false
}

type TrustMemberConfig struct {
	// member info
	MemberInfo string `protobuf:"bytes,1,opt,name=member_info,json=memberInfo,proto3" json:"member_info,omitempty"`
	// oranization ideftifier
	OrgId  string `protobuf:"bytes,2,opt,name=org_id,json=orgId,proto3" json:"org_id,omitempty"`
	Role   string `protobuf:"bytes,3,opt,name=role,proto3" json:"role,omitempty"`
	NodeId string `protobuf:"bytes,4,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *TrustMemberConfig) Reset()         { *m = TrustMemberConfig{} }
func (m *TrustMemberConfig) String() string { return proto.CompactTextString(m) }
func (*TrustMemberConfig) ProtoMessage()    {}
func (*TrustMemberConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{15}
}
func (m *TrustMemberConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrustMemberConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrustMemberConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrustMemberConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrustMemberConfig.Merge(m, src)
}
func (m *TrustMemberConfig) XXX_Size() int {
	return m.Size()
}
func (m *TrustMemberConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TrustMemberConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TrustMemberConfig proto.InternalMessageInfo

func (m *TrustMemberConfig) GetMemberInfo() string {
	if m != nil {
		return m.MemberInfo
	}
	return ""
}

func (m *TrustMemberConfig) GetOrgId() string {
	if m != nil {
		return m.OrgId
	}
	return ""
}

func (m *TrustMemberConfig) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *TrustMemberConfig) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

type Vm struct {
	SupportList []string  `protobuf:"bytes,1,rep,name=support_list,json=supportList,proto3" json:"support_list,omitempty"`
	AddrType    AddrType  `protobuf:"varint,2,opt,name=addr_type,json=addrType,proto3,enum=config.AddrType" json:"addr_type,omitempty"`
	Native      *VmNative `protobuf:"bytes,3,opt,name=native,proto3" json:"native,omitempty"`
}

func (m *Vm) Reset()         { *m = Vm{} }
func (m *Vm) String() string { return proto.CompactTextString(m) }
func (*Vm) ProtoMessage()    {}
func (*Vm) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{16}
}
func (m *Vm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vm.Merge(m, src)
}
func (m *Vm) XXX_Size() int {
	return m.Size()
}
func (m *Vm) XXX_DiscardUnknown() {
	xxx_messageInfo_Vm.DiscardUnknown(m)
}

var xxx_messageInfo_Vm proto.InternalMessageInfo

func (m *Vm) GetSupportList() []string {
	if m != nil {
		return m.SupportList
	}
	return nil
}

func (m *Vm) GetAddrType() AddrType {
	if m != nil {
		return m.AddrType
	}
	return AddrType_CHAINMAKER
}

func (m *Vm) GetNative() *VmNative {
	if m != nil {
		return m.Native
	}
	return nil
}

type VmNative struct {
	Multisign *MultiSign `protobuf:"bytes,1,opt,name=multisign,proto3" json:"multisign,omitempty"`
}

func (m *VmNative) Reset()         { *m = VmNative{} }
func (m *VmNative) String() string { return proto.CompactTextString(m) }
func (*VmNative) ProtoMessage()    {}
func (*VmNative) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{17}
}
func (m *VmNative) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VmNative) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VmNative.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VmNative) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmNative.Merge(m, src)
}
func (m *VmNative) XXX_Size() int {
	return m.Size()
}
func (m *VmNative) XXX_DiscardUnknown() {
	xxx_messageInfo_VmNative.DiscardUnknown(m)
}

var xxx_messageInfo_VmNative proto.InternalMessageInfo

func (m *VmNative) GetMultisign() *MultiSign {
	if m != nil {
		return m.Multisign
	}
	return nil
}

type MultiSign struct {
	// enable multi sign execute contract from sender
	EnableManualRun bool `protobuf:"varint,1,opt,name=enable_manual_run,json=enableManualRun,proto3" json:"enable_manual_run,omitempty"`
}

func (m *MultiSign) Reset()         { *m = MultiSign{} }
func (m *MultiSign) String() string { return proto.CompactTextString(m) }
func (*MultiSign) ProtoMessage()    {}
func (*MultiSign) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{18}
}
func (m *MultiSign) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiSign) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiSign.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiSign) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiSign.Merge(m, src)
}
func (m *MultiSign) XXX_Size() int {
	return m.Size()
}
func (m *MultiSign) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiSign.DiscardUnknown(m)
}

var xxx_messageInfo_MultiSign proto.InternalMessageInfo

func (m *MultiSign) GetEnableManualRun() bool {
	if m != nil {
		return m.EnableManualRun
	}
	return false
}

func init() {
	proto.RegisterEnum("config.AddrType", AddrType_name, AddrType_value)
	proto.RegisterType((*ConfigKeyValue)(nil), "config.ConfigKeyValue")
	proto.RegisterType((*ChainConfig)(nil), "config.ChainConfig")
	proto.RegisterType((*ResourcePolicy)(nil), "config.ResourcePolicy")
	proto.RegisterType((*CryptoConfig)(nil), "config.CryptoConfig")
	proto.RegisterType((*BlockConfig)(nil), "config.BlockConfig")
	proto.RegisterType((*SchedulerConfig)(nil), "config.SchedulerConfig")
	proto.RegisterType((*GasAccountConfig)(nil), "config.GasAccountConfig")
	proto.RegisterType((*SnapshotConfig)(nil), "config.SnapshotConfig")
	proto.RegisterType((*ContextConfig)(nil), "config.ContextConfig")
	proto.RegisterType((*ConsensusTurboConfig)(nil), "config.ConsensusTurboConfig")
	proto.RegisterType((*CoreConfig)(nil), "config.CoreConfig")
	proto.RegisterType((*ConsensusConfig)(nil), "config.ConsensusConfig")
	proto.RegisterType((*OrgConfig)(nil), "config.OrgConfig")
	proto.RegisterType((*TrustRootConfig)(nil), "config.TrustRootConfig")
	proto.RegisterType((*ContractConfig)(nil), "config.ContractConfig")
	proto.RegisterType((*TrustMemberConfig)(nil), "config.TrustMemberConfig")
	proto.RegisterType((*Vm)(nil), "config.Vm")
	proto.RegisterType((*VmNative)(nil), "config.VmNative")
	proto.RegisterType((*MultiSign)(nil), "config.MultiSign")
}

func init() { proto.RegisterFile("config/chain_config.proto", fileDescriptor_2a46c6a6ad69c864) }

var fileDescriptor_2a46c6a6ad69c864 = []byte{
	// 1593 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x57, 0xdd, 0x6e, 0x1b, 0xb9,
	0x15, 0x8e, 0x7e, 0x2c, 0x4b, 0xc7, 0x96, 0x2c, 0x33, 0x4e, 0x32, 0xf1, 0x76, 0x5d, 0x77, 0x8a,
	0x76, 0xbd, 0x41, 0x62, 0xb5, 0x29, 0xb6, 0x49, 0xbb, 0xfd, 0x81, 0x23, 0x18, 0x59, 0x63, 0xd7,
	0xd9, 0x60, 0xec, 0xb8, 0xc5, 0x02, 0xc5, 0x80, 0x9a, 0xa1, 0xe5, 0x41, 0x66, 0x86, 0x13, 0x92,
	0xa3, 0x95, 0x72, 0xd5, 0xbe, 0x41, 0x2f, 0x7a, 0xdb, 0x87, 0xe8, 0x5b, 0xf4, 0x72, 0x2f, 0xb7,
	0x77, 0x45, 0xf2, 0x16, 0xbd, 0x2a, 0x78, 0x48, 0x8e, 0x46, 0x4e, 0x1b, 0xe4, 0x6e, 0xf8, 0x7d,
	0xdf, 0x39, 0x24, 0x0f, 0x0f, 0x0f, 0xcf, 0xc0, 0xdd, 0x88, 0xe7, 0x97, 0xc9, 0x74, 0x14, 0x5d,
	0xd1, 0x24, 0x0f, 0xcd, 0xe0, 0xb0, 0x10, 0x5c, 0x71, 0xd2, 0x31, 0xa3, 0x5d, 0x2d, 0x91, 0x2c,
	0x97, 0xa5, 0x1c, 0x55, 0x5f, 0x46, 0xb2, 0xbb, 0x4b, 0xa3, 0x88, 0x49, 0x19, 0xf1, 0x5c, 0x09,
	0x9e, 0x8e, 0x0a, 0x9e, 0x26, 0xd1, 0xc2, 0x70, 0xfe, 0x63, 0x18, 0x8c, 0xd1, 0xc1, 0x97, 0x6c,
	0x71, 0x41, 0xd3, 0x92, 0x91, 0x21, 0xb4, 0x5e, 0xb2, 0x85, 0xd7, 0xd8, 0x6f, 0x1c, 0xf4, 0x02,
	0xfd, 0x49, 0x76, 0x60, 0x6d, 0xa6, 0x29, 0xaf, 0x89, 0x98, 0x19, 0xf8, 0xff, 0xea, 0xc0, 0xc6,
	0x58, 0xaf, 0xc7, 0xd8, 0x93, 0xbb, 0xd0, 0x35, 0xcb, 0x4b, 0x62, 0x6b, 0xbc, 0x8e, 0xe3, 0x93,
	0x98, 0x78, 0xb0, 0x3e, 0x63, 0x42, 0x26, 0x3c, 0xb7, 0x2e, 0xdc, 0x90, 0x7c, 0x04, 0x3d, 0x5a,
	0xaa, 0xab, 0x50, 0x2d, 0x0a, 0xe6, 0xb5, 0x90, 0xeb, 0x6a, 0xe0, 0x7c, 0x51, 0x30, 0xb2, 0x0b,
	0x5d, 0xc9, 0x5e, 0x95, 0x2c, 0x8f, 0x98, 0xd7, 0xde, 0x6f, 0x1c, 0xb4, 0x83, 0x6a, 0x4c, 0xee,
	0x43, 0x27, 0x12, 0x8b, 0x42, 0x71, 0x6f, 0x6d, 0xbf, 0x71, 0xb0, 0xf1, 0x70, 0xe7, 0xd0, 0x46,
	0x65, 0x8c, 0xa8, 0x59, 0x53, 0x60, 0x35, 0xe4, 0x53, 0x58, 0x9b, 0xa4, 0x3c, 0x7a, 0xe9, 0x75,
	0x50, 0x7c, 0xd3, 0x89, 0x9f, 0x68, 0xd0, 0x6a, 0x8d, 0x82, 0xfc, 0x14, 0xda, 0x11, 0x17, 0xcc,
	0x5b, 0x47, 0x25, 0xa9, 0xdc, 0x72, 0xc1, 0xac, 0x10, 0x79, 0xf2, 0x19, 0xf4, 0xaa, 0x38, 0x7b,
	0x5d, 0x14, 0xdf, 0x59, 0x8a, 0x2d, 0x61, 0x2d, 0x96, 0x4a, 0xf2, 0x18, 0x36, 0x94, 0x28, 0xa5,
	0x0a, 0x05, 0xe7, 0x4a, 0x7a, 0xbd, 0xfd, 0x56, 0xdd, 0xf0, 0x5c, 0x53, 0x01, 0xe7, 0xca, 0x1a,
	0x82, 0x72, 0x80, 0x24, 0xbf, 0x83, 0xbe, 0xb1, 0xcc, 0x58, 0x36, 0x61, 0x42, 0x7a, 0x80, 0xb6,
	0x77, 0x57, 0x6c, 0x4f, 0x91, 0xb3, 0xd6, 0x9b, 0x6a, 0x09, 0x49, 0x32, 0x86, 0x6d, 0xc1, 0x24,
	0x2f, 0x45, 0xc4, 0x42, 0x4c, 0x81, 0x84, 0x49, 0x6f, 0x03, 0x7d, 0xdc, 0x76, 0x3e, 0x02, 0x2b,
	0x78, 0x8e, 0x29, 0x12, 0x0c, 0x45, 0x7d, 0x9c, 0x30, 0x49, 0x1e, 0x42, 0x17, 0xd3, 0x88, 0x46,
	0xca, 0xdb, 0xc4, 0x4d, 0xdf, 0xae, 0x6d, 0x1a, 0x71, 0x3b, 0x79, 0xa5, 0xd3, 0x36, 0x32, 0xa7,
	0x85, 0xbc, 0xe2, 0xca, 0xeb, 0xaf, 0xda, 0x9c, 0x59, 0xdc, 0xd9, 0x38, 0x9d, 0x8e, 0xae, 0x8c,
	0xae, 0x58, 0x5c, 0xa6, 0x4c, 0x78, 0x83, 0xd5, 0xe8, 0x9e, 0x39, 0xc2, 0x45, 0xb7, 0x52, 0x92,
	0x11, 0xac, 0xeb, 0x69, 0xd9, 0x5c, 0x79, 0x5b, 0x68, 0x74, 0xab, 0xbe, 0x3a, 0x36, 0x77, 0x13,
	0x39, 0x15, 0x79, 0x0c, 0x5e, 0x9c, 0x48, 0x3a, 0x49, 0x59, 0x1c, 0xe6, 0x54, 0x25, 0x33, 0x16,
	0x56, 0xfb, 0x1b, 0xee, 0xb7, 0x0e, 0x7a, 0xc1, 0x6d, 0xc7, 0x3f, 0x43, 0xda, 0xed, 0x92, 0xfc,
	0x1e, 0x06, 0x34, 0x8a, 0x78, 0x99, 0x2b, 0x7b, 0x1f, 0x3d, 0x82, 0x33, 0x7a, 0x6e, 0xc6, 0xa7,
	0x54, 0x1e, 0x19, 0x81, 0x9d, 0xb4, 0x4f, 0xeb, 0x43, 0xb2, 0x0b, 0xcd, 0x59, 0xe6, 0x6d, 0xa3,
	0x11, 0x38, 0xa3, 0x8b, 0x2c, 0x68, 0xce, 0x32, 0x3f, 0x86, 0xc1, 0xea, 0x51, 0x90, 0x1f, 0x43,
	0xbf, 0x3a, 0xbd, 0x9c, 0x66, 0xcc, 0x5e, 0xb1, 0x4d, 0x07, 0x3e, 0xa3, 0x19, 0x23, 0x0f, 0xa0,
	0x63, 0x2e, 0x37, 0x5e, 0x33, 0xbd, 0xfb, 0x95, 0x9b, 0x7f, 0x68, 0x8f, 0xd5, 0x8a, 0x7c, 0x1f,
	0x36, 0xeb, 0xb7, 0x85, 0x10, 0x68, 0x5f, 0x51, 0x79, 0x65, 0x5d, 0xe3, 0xb7, 0xff, 0x9f, 0x06,
	0x6c, 0xd4, 0x6e, 0x09, 0x39, 0x84, 0x9b, 0x6a, 0x1e, 0xaa, 0x24, 0x63, 0x52, 0xd1, 0xac, 0x08,
	0x67, 0x4c, 0x24, 0x97, 0xa6, 0x5a, 0x74, 0x83, 0x6d, 0x35, 0x3f, 0x77, 0xcc, 0x05, 0x12, 0xe4,
	0x63, 0x00, 0xab, 0xe7, 0xa5, 0xc2, 0x65, 0xf5, 0x83, 0x9e, 0x91, 0xf1, 0x52, 0x91, 0x7b, 0xb0,
	0x8d, 0xd7, 0x2e, 0x54, 0xf3, 0x30, 0xa2, 0x05, 0x8d, 0x12, 0xb5, 0xc0, 0x3a, 0xd0, 0x0f, 0xb6,
	0x90, 0x38, 0x9f, 0x8f, 0x2d, 0xac, 0x5d, 0x19, 0xad, 0x4c, 0x5e, 0x9b, 0x82, 0xd0, 0x0f, 0x7a,
	0x88, 0x9c, 0x25, 0xaf, 0x19, 0xf9, 0x09, 0x0c, 0x0c, 0x9d, 0xe4, 0x8a, 0x89, 0x19, 0x4d, 0xb1,
	0x32, 0xf4, 0x83, 0x3e, 0xa2, 0x27, 0x16, 0xd4, 0x33, 0xaa, 0x79, 0x58, 0x50, 0x41, 0x33, 0xa6,
	0x98, 0x30, 0xce, 0x3a, 0x66, 0x46, 0x35, 0x7f, 0xee, 0x70, 0xed, 0xd2, 0xff, 0x35, 0x6c, 0x5d,
	0x4b, 0x36, 0xf2, 0x09, 0x6c, 0xb1, 0x5c, 0xe7, 0x43, 0xc8, 0x66, 0x49, 0x8c, 0xa5, 0xc9, 0xec,
	0x7d, 0x60, 0xe0, 0x63, 0x8b, 0xfa, 0x7f, 0x6f, 0xc2, 0xf0, 0x7a, 0x0a, 0xe8, 0xc9, 0xa7, 0x54,
	0x86, 0x34, 0xce, 0x92, 0x3c, 0xa4, 0x71, 0x2c, 0x98, 0x94, 0x36, 0xdc, 0x5b, 0x53, 0x2a, 0x8f,
	0x34, 0x7e, 0x64, 0x60, 0x5d, 0x1a, 0xb5, 0x16, 0xcd, 0x6d, 0xe0, 0xba, 0x53, 0x2a, 0xc7, 0x7a,
	0xac, 0x63, 0x61, 0x97, 0x31, 0xa5, 0x12, 0x03, 0xd6, 0x0d, 0x7a, 0x06, 0x79, 0x4a, 0x25, 0xf9,
	0x21, 0x6c, 0xc4, 0xec, 0x92, 0x96, 0xa9, 0x42, 0xde, 0x14, 0x4f, 0xb0, 0x90, 0x16, 0xdc, 0x83,
	0xed, 0x9a, 0x20, 0x2c, 0x44, 0x12, 0x31, 0x8c, 0x57, 0x33, 0xd8, 0x5a, 0xca, 0x9e, 0x6b, 0x98,
	0x1c, 0xc0, 0x30, 0xc9, 0xa5, 0xa2, 0x69, 0x1a, 0x4e, 0xa8, 0x34, 0x33, 0x76, 0xd0, 0xe3, 0xc0,
	0xe2, 0x4f, 0xa8, 0x64, 0xd6, 0xab, 0x53, 0x2e, 0xbd, 0xae, 0x1b, 0xaf, 0x96, 0x70, 0x5e, 0xfd,
	0x5f, 0xc1, 0x60, 0xf5, 0xf6, 0x7f, 0x78, 0x68, 0x1f, 0x43, 0x7f, 0xe5, 0x3a, 0x7f, 0xb8, 0xe5,
	0xdf, 0x1a, 0xb0, 0x53, 0x15, 0xe7, 0xf3, 0x52, 0x4c, 0x5c, 0xea, 0xff, 0x12, 0xee, 0x54, 0x35,
	0x3a, 0xcc, 0x98, 0x94, 0x74, 0xca, 0x42, 0xa5, 0x05, 0xd6, 0xd3, 0xad, 0x8a, 0x3e, 0x35, 0x2c,
	0x5a, 0xeb, 0x73, 0x10, 0x4c, 0x89, 0x05, 0x66, 0x38, 0x9e, 0x52, 0x3b, 0xe8, 0x21, 0xa2, 0x33,
	0x5c, 0xe7, 0xa4, 0xa1, 0xab, 0x9c, 0x6c, 0xa1, 0xa4, 0x8f, 0xa8, 0xcb, 0x49, 0xff, 0x2f, 0x2d,
	0x80, 0xe5, 0x03, 0x43, 0x7e, 0x06, 0x3b, 0x6a, 0x1e, 0x56, 0x55, 0xad, 0xba, 0x3d, 0x0d, 0xb4,
	0x25, 0x6a, 0x5e, 0x25, 0xa5, 0xbb, 0x46, 0x47, 0xf0, 0xf1, 0x8a, 0xc5, 0x8c, 0xa6, 0x49, 0x4c,
	0x15, 0x5b, 0xb9, 0x78, 0xed, 0x60, 0xb7, 0x66, 0x7a, 0x61, 0x25, 0xce, 0x45, 0x00, 0xb7, 0x97,
	0x11, 0xc0, 0x9d, 0xbb, 0xba, 0xd6, 0xc2, 0x5a, 0xf2, 0x83, 0x77, 0x1e, 0xb7, 0x5a, 0xfc, 0x82,
	0x9d, 0xe8, 0x7f, 0x45, 0xf5, 0x10, 0x6e, 0xda, 0x73, 0x91, 0x2c, 0x8f, 0x99, 0x08, 0xa7, 0x82,
	0x97, 0x05, 0xa6, 0x63, 0x37, 0xd8, 0x36, 0xd4, 0x19, 0x32, 0x4f, 0x35, 0x41, 0x7e, 0x0b, 0x1f,
	0x59, 0xbd, 0x9e, 0x2b, 0x4d, 0x22, 0x25, 0xc3, 0x49, 0xa2, 0xc2, 0x6f, 0x93, 0x3c, 0xe6, 0xdf,
	0x62, 0x7e, 0x76, 0x03, 0xcf, 0x48, 0xc6, 0x4e, 0xf1, 0x24, 0x51, 0x7f, 0x40, 0x9e, 0x7c, 0x0e,
	0xbb, 0xd6, 0x9c, 0x17, 0x2a, 0xc9, 0x92, 0xd7, 0x2c, 0x8c, 0xae, 0xa8, 0x98, 0x2e, 0x53, 0xb6,
	0x1b, 0xdc, 0x31, 0x8a, 0xaf, 0xad, 0x60, 0x8c, 0xfc, 0x53, 0x2a, 0xfd, 0xef, 0x1b, 0xb0, 0x75,
	0xed, 0xdd, 0x26, 0xf7, 0xa1, 0x8d, 0x8d, 0x89, 0x0e, 0xfc, 0xc0, 0x54, 0x76, 0xdb, 0x58, 0x2d,
	0x83, 0xb0, 0x28, 0x58, 0x80, 0x2a, 0xf2, 0x09, 0xac, 0xe5, 0x3c, 0x66, 0xd2, 0x6b, 0xe2, 0xa3,
	0xba, 0xed, 0x02, 0xf6, 0xb5, 0x98, 0xba, 0x16, 0x03, 0x79, 0xf2, 0x19, 0x00, 0x9b, 0xab, 0x65,
	0x78, 0x5b, 0xd7, 0x9e, 0xd1, 0x5a, 0x37, 0x16, 0xf4, 0x96, 0x59, 0xfe, 0x08, 0x36, 0xe2, 0x82,
	0x4b, 0x67, 0xd7, 0x7e, 0xaf, 0x1d, 0x68, 0xa9, 0xc1, 0xfc, 0x17, 0xd0, 0xab, 0xd6, 0x40, 0x6e,
	0x41, 0x87, 0x8b, 0xe9, 0xb2, 0x49, 0x5b, 0xe3, 0x62, 0x6a, 0x5a, 0x34, 0x57, 0x8f, 0x9a, 0xf8,
	0xee, 0xb9, 0x21, 0xb9, 0x03, 0xeb, 0x7a, 0xd9, 0xda, 0xa2, 0x85, 0x4c, 0x47, 0x0f, 0x4f, 0x62,
	0xff, 0x37, 0xb0, 0x75, 0xad, 0x5f, 0xf9, 0x7f, 0xce, 0x09, 0xb4, 0x75, 0xbb, 0x63, 0x3d, 0xe3,
	0xb7, 0xff, 0x8f, 0x06, 0x76, 0x9e, 0xb5, 0x96, 0x81, 0xdc, 0x07, 0xe2, 0xd2, 0xe5, 0x55, 0x1a,
	0xca, 0xb2, 0x28, 0xb8, 0x50, 0xf6, 0xfe, 0x0d, 0x6d, 0xb6, 0xbc, 0x4a, 0xcf, 0x0c, 0xfe, 0xde,
	0xa7, 0xbb, 0xf9, 0xde, 0xa7, 0xfb, 0x11, 0x78, 0x3c, 0x4f, 0x17, 0x61, 0x24, 0x18, 0x55, 0x5c,
	0x84, 0x11, 0xcd, 0xc3, 0xb2, 0x98, 0x0a, 0x1a, 0x33, 0x5b, 0x4a, 0x6f, 0x69, 0x7e, 0x6c, 0xe8,
	0x31, 0xcd, 0x5f, 0x18, 0xd2, 0x9f, 0xc3, 0xf6, 0x3b, 0x5d, 0x96, 0xae, 0xb5, 0xa6, 0x23, 0x0b,
	0x93, 0xfc, 0x92, 0xdb, 0x8d, 0x83, 0x81, 0x4e, 0xf2, 0x4b, 0x5e, 0x0b, 0x4a, 0xf3, 0x9d, 0xa0,
	0xa4, 0xae, 0xeb, 0xc5, 0xef, 0x7a, 0xac, 0xdb, 0x08, 0xbb, 0x58, 0xff, 0xb9, 0x01, 0xcd, 0x8b,
	0x8c, 0xfc, 0x08, 0x36, 0x6d, 0x58, 0xc2, 0x34, 0x91, 0x3a, 0x36, 0x7a, 0x9f, 0x1b, 0x16, 0xfb,
	0x2a, 0x91, 0x8a, 0x3c, 0x80, 0x9e, 0x3e, 0x39, 0xd3, 0x51, 0x37, 0x31, 0x71, 0x87, 0x2e, 0x47,
	0xf4, 0xd3, 0x82, 0x09, 0xdb, 0xa5, 0xf6, 0x8b, 0x1c, 0x40, 0xc7, 0x04, 0xcf, 0x5e, 0xf3, 0xe1,
	0xb2, 0x13, 0x31, 0x51, 0x0b, 0x2c, 0xef, 0x7f, 0x0e, 0x5d, 0x87, 0x91, 0x11, 0xf4, 0xb2, 0x32,
	0x55, 0x89, 0x4c, 0xa6, 0x39, 0xee, 0xb8, 0x96, 0xee, 0xa7, 0x9a, 0x38, 0x4b, 0xa6, 0x79, 0xb0,
	0xd4, 0xf8, 0x8f, 0xa0, 0x57, 0xe1, 0xfa, 0x99, 0xb0, 0xe7, 0x9c, 0xd1, 0xbc, 0xa4, 0x69, 0x28,
	0xca, 0xdc, 0x1e, 0xb3, 0xad, 0xe3, 0xa7, 0x88, 0x07, 0x65, 0x7e, 0xef, 0xe7, 0xd0, 0x75, 0xab,
	0x26, 0x03, 0x80, 0xf1, 0x17, 0x47, 0x27, 0xcf, 0x4e, 0x8f, 0xbe, 0x3c, 0x0e, 0x86, 0x37, 0xc8,
	0x3a, 0xb4, 0xbe, 0xf9, 0xe3, 0x57, 0xc3, 0x06, 0xd9, 0x84, 0xee, 0xf1, 0xf9, 0x17, 0xc7, 0xc1,
	0xf1, 0x8b, 0xd3, 0x61, 0xf3, 0xc9, 0x9f, 0xfe, 0xf9, 0x66, 0xaf, 0xf1, 0xdd, 0x9b, 0xbd, 0xc6,
	0xbf, 0xdf, 0xec, 0x35, 0xfe, 0xfa, 0x76, 0xef, 0xc6, 0x77, 0x6f, 0xf7, 0x6e, 0x7c, 0xff, 0x76,
	0xef, 0x06, 0x78, 0x5c, 0x4c, 0x0f, 0xf1, 0xa7, 0x24, 0xa3, 0x2f, 0x99, 0x38, 0x2c, 0x26, 0x76,
	0xd1, 0xdf, 0x7c, 0x5a, 0x43, 0xb9, 0xb0, 0x3f, 0x5a, 0x38, 0x1c, 0x15, 0x93, 0x07, 0x53, 0x3e,
	0x9a, 0x3d, 0x1c, 0x19, 0xe9, 0xa4, 0x83, 0x3f, 0x4e, 0xbf, 0xf8, 0x6f, 0x00, 0x00, 0x00, 0xff,
	0xff, 0xca, 0xd6, 0x85, 0x00, 0x94, 0x0d, 0x00, 0x00,
}

func (m *ConfigKeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigKeyValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigKeyValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintChainConfig(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintChainConfig(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChainConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AccountConfig != nil {
		{
			size, err := m.AccountConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.Vm != nil {
		{
			size, err := m.Vm.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.DisabledNativeContract) > 0 {
		for iNdEx := len(m.DisabledNativeContract) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DisabledNativeContract[iNdEx])
			copy(dAtA[i:], m.DisabledNativeContract[iNdEx])
			i = encodeVarintChainConfig(dAtA, i, uint64(len(m.DisabledNativeContract[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.Context != nil {
		{
			size, err := m.Context.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.Scheduler != nil {
		{
			size, err := m.Scheduler.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.Snapshot != nil {
		{
			size, err := m.Snapshot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Contract != nil {
		{
			size, err := m.Contract.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.ResourcePolicies) > 0 {
		for iNdEx := len(m.ResourcePolicies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResourcePolicies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChainConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.TrustMembers) > 0 {
		for iNdEx := len(m.TrustMembers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TrustMembers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChainConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.TrustRoots) > 0 {
		for iNdEx := len(m.TrustRoots) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TrustRoots[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChainConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Consensus != nil {
		{
			size, err := m.Consensus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Core != nil {
		{
			size, err := m.Core.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Crypto != nil {
		{
			size, err := m.Crypto.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Sequence != 0 {
		i = encodeVarintChainConfig(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x20
	}
	if len(m.AuthType) > 0 {
		i -= len(m.AuthType)
		copy(dAtA[i:], m.AuthType)
		i = encodeVarintChainConfig(dAtA, i, uint64(len(m.AuthType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintChainConfig(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintChainConfig(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResourcePolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourcePolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourcePolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Policy != nil {
		{
			size, err := m.Policy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ResourceName) > 0 {
		i -= len(m.ResourceName)
		copy(dAtA[i:], m.ResourceName)
		i = encodeVarintChainConfig(dAtA, i, uint64(len(m.ResourceName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CryptoConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CryptoConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CryptoConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintChainConfig(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TxParameterSize != 0 {
		i = encodeVarintChainConfig(dAtA, i, uint64(m.TxParameterSize))
		i--
		dAtA[i] = 0x30
	}
	if m.BlockInterval != 0 {
		i = encodeVarintChainConfig(dAtA, i, uint64(m.BlockInterval))
		i--
		dAtA[i] = 0x28
	}
	if m.BlockSize != 0 {
		i = encodeVarintChainConfig(dAtA, i, uint64(m.BlockSize))
		i--
		dAtA[i] = 0x20
	}
	if m.BlockTxCapacity != 0 {
		i = encodeVarintChainConfig(dAtA, i, uint64(m.BlockTxCapacity))
		i--
		dAtA[i] = 0x18
	}
	if m.TxTimeout != 0 {
		i = encodeVarintChainConfig(dAtA, i, uint64(m.TxTimeout))
		i--
		dAtA[i] = 0x10
	}
	if m.TxTimestampVerify {
		i--
		if m.TxTimestampVerify {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SchedulerConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchedulerConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchedulerConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnableEvidence {
		i--
		if m.EnableEvidence {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GasAccountConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GasAccountConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GasAccountConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InstallGasPrice != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.InstallGasPrice))))
		i--
		dAtA[i] = 0x3d
	}
	if m.InstallBaseGas != 0 {
		i = encodeVarintChainConfig(dAtA, i, uint64(m.InstallBaseGas))
		i--
		dAtA[i] = 0x30
	}
	if m.DefaultGasPrice != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DefaultGasPrice))))
		i--
		dAtA[i] = 0x2d
	}
	if m.DefaultGas != 0 {
		i = encodeVarintChainConfig(dAtA, i, uint64(m.DefaultGas))
		i--
		dAtA[i] = 0x20
	}
	if m.EnableGas {
		i--
		if m.EnableGas {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.GasCount != 0 {
		i = encodeVarintChainConfig(dAtA, i, uint64(m.GasCount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.GasAdminAddress) > 0 {
		i -= len(m.GasAdminAddress)
		copy(dAtA[i:], m.GasAdminAddress)
		i = encodeVarintChainConfig(dAtA, i, uint64(len(m.GasAdminAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SnapshotConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnableEvidence {
		i--
		if m.EnableEvidence {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ContextConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContextConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContextConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnableEvidence {
		i--
		if m.EnableEvidence {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusTurboConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusTurboConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusTurboConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RetryInterval != 0 {
		i = encodeVarintChainConfig(dAtA, i, uint64(m.RetryInterval))
		i--
		dAtA[i] = 0x18
	}
	if m.RetryTime != 0 {
		i = encodeVarintChainConfig(dAtA, i, uint64(m.RetryTime))
		i--
		dAtA[i] = 0x10
	}
	if m.ConsensusMessageTurbo {
		i--
		if m.ConsensusMessageTurbo {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CoreConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoreConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CoreConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnableOptimizeChargeGas {
		i--
		if m.EnableOptimizeChargeGas {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.EnableConflictsBitWindow {
		i--
		if m.EnableConflictsBitWindow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.EnableSenderGroup {
		i--
		if m.EnableSenderGroup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.ConsensusTurboConfig != nil {
		{
			size, err := m.ConsensusTurboConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TxSchedulerValidateTimeout != 0 {
		i = encodeVarintChainConfig(dAtA, i, uint64(m.TxSchedulerValidateTimeout))
		i--
		dAtA[i] = 0x10
	}
	if m.TxSchedulerTimeout != 0 {
		i = encodeVarintChainConfig(dAtA, i, uint64(m.TxSchedulerTimeout))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DposConfig) > 0 {
		for iNdEx := len(m.DposConfig) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DposConfig[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChainConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ExtConfig) > 0 {
		for iNdEx := len(m.ExtConfig) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExtConfig[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChainConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChainConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Type != 0 {
		i = encodeVarintChainConfig(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OrgConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrgConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrgConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		for iNdEx := len(m.NodeId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NodeId[iNdEx])
			copy(dAtA[i:], m.NodeId[iNdEx])
			i = encodeVarintChainConfig(dAtA, i, uint64(len(m.NodeId[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Address) > 0 {
		for iNdEx := len(m.Address) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Address[iNdEx])
			copy(dAtA[i:], m.Address[iNdEx])
			i = encodeVarintChainConfig(dAtA, i, uint64(len(m.Address[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.OrgId) > 0 {
		i -= len(m.OrgId)
		copy(dAtA[i:], m.OrgId)
		i = encodeVarintChainConfig(dAtA, i, uint64(len(m.OrgId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TrustRootConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrustRootConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrustRootConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Root) > 0 {
		for iNdEx := len(m.Root) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Root[iNdEx])
			copy(dAtA[i:], m.Root[iNdEx])
			i = encodeVarintChainConfig(dAtA, i, uint64(len(m.Root[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.OrgId) > 0 {
		i -= len(m.OrgId)
		copy(dAtA[i:], m.OrgId)
		i = encodeVarintChainConfig(dAtA, i, uint64(len(m.OrgId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContractConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OnlyCreatorCanUpgrade {
		i--
		if m.OnlyCreatorCanUpgrade {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.DisabledNativeContract) > 0 {
		for iNdEx := len(m.DisabledNativeContract) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DisabledNativeContract[iNdEx])
			copy(dAtA[i:], m.DisabledNativeContract[iNdEx])
			i = encodeVarintChainConfig(dAtA, i, uint64(len(m.DisabledNativeContract[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.EnableSqlSupport {
		i--
		if m.EnableSqlSupport {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TrustMemberConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrustMemberConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrustMemberConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintChainConfig(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintChainConfig(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OrgId) > 0 {
		i -= len(m.OrgId)
		copy(dAtA[i:], m.OrgId)
		i = encodeVarintChainConfig(dAtA, i, uint64(len(m.OrgId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MemberInfo) > 0 {
		i -= len(m.MemberInfo)
		copy(dAtA[i:], m.MemberInfo)
		i = encodeVarintChainConfig(dAtA, i, uint64(len(m.MemberInfo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Vm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Native != nil {
		{
			size, err := m.Native.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AddrType != 0 {
		i = encodeVarintChainConfig(dAtA, i, uint64(m.AddrType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SupportList) > 0 {
		for iNdEx := len(m.SupportList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SupportList[iNdEx])
			copy(dAtA[i:], m.SupportList[iNdEx])
			i = encodeVarintChainConfig(dAtA, i, uint64(len(m.SupportList[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *VmNative) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VmNative) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VmNative) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Multisign != nil {
		{
			size, err := m.Multisign.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MultiSign) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiSign) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiSign) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnableManualRun {
		i--
		if m.EnableManualRun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintChainConfig(dAtA []byte, offset int, v uint64) int {
	offset -= sovChainConfig(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ConfigKeyValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovChainConfig(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovChainConfig(uint64(l))
	}
	return n
}

func (m *ChainConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovChainConfig(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovChainConfig(uint64(l))
	}
	l = len(m.AuthType)
	if l > 0 {
		n += 1 + l + sovChainConfig(uint64(l))
	}
	if m.Sequence != 0 {
		n += 1 + sovChainConfig(uint64(m.Sequence))
	}
	if m.Crypto != nil {
		l = m.Crypto.Size()
		n += 1 + l + sovChainConfig(uint64(l))
	}
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovChainConfig(uint64(l))
	}
	if m.Core != nil {
		l = m.Core.Size()
		n += 1 + l + sovChainConfig(uint64(l))
	}
	if m.Consensus != nil {
		l = m.Consensus.Size()
		n += 1 + l + sovChainConfig(uint64(l))
	}
	if len(m.TrustRoots) > 0 {
		for _, e := range m.TrustRoots {
			l = e.Size()
			n += 1 + l + sovChainConfig(uint64(l))
		}
	}
	if len(m.TrustMembers) > 0 {
		for _, e := range m.TrustMembers {
			l = e.Size()
			n += 1 + l + sovChainConfig(uint64(l))
		}
	}
	if len(m.ResourcePolicies) > 0 {
		for _, e := range m.ResourcePolicies {
			l = e.Size()
			n += 1 + l + sovChainConfig(uint64(l))
		}
	}
	if m.Contract != nil {
		l = m.Contract.Size()
		n += 1 + l + sovChainConfig(uint64(l))
	}
	if m.Snapshot != nil {
		l = m.Snapshot.Size()
		n += 1 + l + sovChainConfig(uint64(l))
	}
	if m.Scheduler != nil {
		l = m.Scheduler.Size()
		n += 1 + l + sovChainConfig(uint64(l))
	}
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovChainConfig(uint64(l))
	}
	if len(m.DisabledNativeContract) > 0 {
		for _, s := range m.DisabledNativeContract {
			l = len(s)
			n += 2 + l + sovChainConfig(uint64(l))
		}
	}
	if m.Vm != nil {
		l = m.Vm.Size()
		n += 2 + l + sovChainConfig(uint64(l))
	}
	if m.AccountConfig != nil {
		l = m.AccountConfig.Size()
		n += 2 + l + sovChainConfig(uint64(l))
	}
	return n
}

func (m *ResourcePolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResourceName)
	if l > 0 {
		n += 1 + l + sovChainConfig(uint64(l))
	}
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovChainConfig(uint64(l))
	}
	return n
}

func (m *CryptoConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovChainConfig(uint64(l))
	}
	return n
}

func (m *BlockConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TxTimestampVerify {
		n += 2
	}
	if m.TxTimeout != 0 {
		n += 1 + sovChainConfig(uint64(m.TxTimeout))
	}
	if m.BlockTxCapacity != 0 {
		n += 1 + sovChainConfig(uint64(m.BlockTxCapacity))
	}
	if m.BlockSize != 0 {
		n += 1 + sovChainConfig(uint64(m.BlockSize))
	}
	if m.BlockInterval != 0 {
		n += 1 + sovChainConfig(uint64(m.BlockInterval))
	}
	if m.TxParameterSize != 0 {
		n += 1 + sovChainConfig(uint64(m.TxParameterSize))
	}
	return n
}

func (m *SchedulerConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableEvidence {
		n += 2
	}
	return n
}

func (m *GasAccountConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GasAdminAddress)
	if l > 0 {
		n += 1 + l + sovChainConfig(uint64(l))
	}
	if m.GasCount != 0 {
		n += 1 + sovChainConfig(uint64(m.GasCount))
	}
	if m.EnableGas {
		n += 2
	}
	if m.DefaultGas != 0 {
		n += 1 + sovChainConfig(uint64(m.DefaultGas))
	}
	if m.DefaultGasPrice != 0 {
		n += 5
	}
	if m.InstallBaseGas != 0 {
		n += 1 + sovChainConfig(uint64(m.InstallBaseGas))
	}
	if m.InstallGasPrice != 0 {
		n += 5
	}
	return n
}

func (m *SnapshotConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableEvidence {
		n += 2
	}
	return n
}

func (m *ContextConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableEvidence {
		n += 2
	}
	return n
}

func (m *ConsensusTurboConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConsensusMessageTurbo {
		n += 2
	}
	if m.RetryTime != 0 {
		n += 1 + sovChainConfig(uint64(m.RetryTime))
	}
	if m.RetryInterval != 0 {
		n += 1 + sovChainConfig(uint64(m.RetryInterval))
	}
	return n
}

func (m *CoreConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TxSchedulerTimeout != 0 {
		n += 1 + sovChainConfig(uint64(m.TxSchedulerTimeout))
	}
	if m.TxSchedulerValidateTimeout != 0 {
		n += 1 + sovChainConfig(uint64(m.TxSchedulerValidateTimeout))
	}
	if m.ConsensusTurboConfig != nil {
		l = m.ConsensusTurboConfig.Size()
		n += 1 + l + sovChainConfig(uint64(l))
	}
	if m.EnableSenderGroup {
		n += 2
	}
	if m.EnableConflictsBitWindow {
		n += 2
	}
	if m.EnableOptimizeChargeGas {
		n += 2
	}
	return n
}

func (m *ConsensusConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovChainConfig(uint64(m.Type))
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovChainConfig(uint64(l))
		}
	}
	if len(m.ExtConfig) > 0 {
		for _, e := range m.ExtConfig {
			l = e.Size()
			n += 1 + l + sovChainConfig(uint64(l))
		}
	}
	if len(m.DposConfig) > 0 {
		for _, e := range m.DposConfig {
			l = e.Size()
			n += 1 + l + sovChainConfig(uint64(l))
		}
	}
	return n
}

func (m *OrgConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrgId)
	if l > 0 {
		n += 1 + l + sovChainConfig(uint64(l))
	}
	if len(m.Address) > 0 {
		for _, s := range m.Address {
			l = len(s)
			n += 1 + l + sovChainConfig(uint64(l))
		}
	}
	if len(m.NodeId) > 0 {
		for _, s := range m.NodeId {
			l = len(s)
			n += 1 + l + sovChainConfig(uint64(l))
		}
	}
	return n
}

func (m *TrustRootConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrgId)
	if l > 0 {
		n += 1 + l + sovChainConfig(uint64(l))
	}
	if len(m.Root) > 0 {
		for _, s := range m.Root {
			l = len(s)
			n += 1 + l + sovChainConfig(uint64(l))
		}
	}
	return n
}

func (m *ContractConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableSqlSupport {
		n += 2
	}
	if len(m.DisabledNativeContract) > 0 {
		for _, s := range m.DisabledNativeContract {
			l = len(s)
			n += 1 + l + sovChainConfig(uint64(l))
		}
	}
	if m.OnlyCreatorCanUpgrade {
		n += 2
	}
	return n
}

func (m *TrustMemberConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MemberInfo)
	if l > 0 {
		n += 1 + l + sovChainConfig(uint64(l))
	}
	l = len(m.OrgId)
	if l > 0 {
		n += 1 + l + sovChainConfig(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovChainConfig(uint64(l))
	}
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovChainConfig(uint64(l))
	}
	return n
}

func (m *Vm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SupportList) > 0 {
		for _, s := range m.SupportList {
			l = len(s)
			n += 1 + l + sovChainConfig(uint64(l))
		}
	}
	if m.AddrType != 0 {
		n += 1 + sovChainConfig(uint64(m.AddrType))
	}
	if m.Native != nil {
		l = m.Native.Size()
		n += 1 + l + sovChainConfig(uint64(l))
	}
	return n
}

func (m *VmNative) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Multisign != nil {
		l = m.Multisign.Size()
		n += 1 + l + sovChainConfig(uint64(l))
	}
	return n
}

func (m *MultiSign) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableManualRun {
		n += 2
	}
	return n
}

func sovChainConfig(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozChainConfig(x uint64) (n int) {
	return sovChainConfig(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ConfigKeyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigKeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigKeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crypto", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Crypto == nil {
				m.Crypto = &CryptoConfig{}
			}
			if err := m.Crypto.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &BlockConfig{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Core", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Core == nil {
				m.Core = &CoreConfig{}
			}
			if err := m.Core.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Consensus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Consensus == nil {
				m.Consensus = &ConsensusConfig{}
			}
			if err := m.Consensus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustRoots", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustRoots = append(m.TrustRoots, &TrustRootConfig{})
			if err := m.TrustRoots[len(m.TrustRoots)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustMembers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustMembers = append(m.TrustMembers, &TrustMemberConfig{})
			if err := m.TrustMembers[len(m.TrustMembers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourcePolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourcePolicies = append(m.ResourcePolicies, &ResourcePolicy{})
			if err := m.ResourcePolicies[len(m.ResourcePolicies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contract", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Contract == nil {
				m.Contract = &ContractConfig{}
			}
			if err := m.Contract.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Snapshot == nil {
				m.Snapshot = &SnapshotConfig{}
			}
			if err := m.Snapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheduler", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Scheduler == nil {
				m.Scheduler = &SchedulerConfig{}
			}
			if err := m.Scheduler.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &ContextConfig{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisabledNativeContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisabledNativeContract = append(m.DisabledNativeContract, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vm == nil {
				m.Vm = &Vm{}
			}
			if err := m.Vm.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccountConfig == nil {
				m.AccountConfig = &GasAccountConfig{}
			}
			if err := m.AccountConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourcePolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourcePolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourcePolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &accesscontrol.Policy{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CryptoConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CryptoConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CryptoConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxTimestampVerify", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TxTimestampVerify = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxTimeout", wireType)
			}
			m.TxTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTxCapacity", wireType)
			}
			m.BlockTxCapacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTxCapacity |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockSize", wireType)
			}
			m.BlockSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockInterval", wireType)
			}
			m.BlockInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockInterval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxParameterSize", wireType)
			}
			m.TxParameterSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxParameterSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchedulerConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchedulerConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchedulerConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableEvidence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableEvidence = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GasAccountConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GasAccountConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GasAccountConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasAdminAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GasAdminAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasCount", wireType)
			}
			m.GasCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableGas", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableGas = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultGas", wireType)
			}
			m.DefaultGas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultGas |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultGasPrice", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DefaultGasPrice = float32(math.Float32frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstallBaseGas", wireType)
			}
			m.InstallBaseGas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstallBaseGas |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstallGasPrice", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.InstallGasPrice = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableEvidence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableEvidence = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContextConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContextConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContextConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableEvidence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableEvidence = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusTurboConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusTurboConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusTurboConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusMessageTurbo", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConsensusMessageTurbo = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryTime", wireType)
			}
			m.RetryTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetryTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryInterval", wireType)
			}
			m.RetryInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetryInterval |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoreConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoreConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoreConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxSchedulerTimeout", wireType)
			}
			m.TxSchedulerTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxSchedulerTimeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxSchedulerValidateTimeout", wireType)
			}
			m.TxSchedulerValidateTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxSchedulerValidateTimeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusTurboConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConsensusTurboConfig == nil {
				m.ConsensusTurboConfig = &ConsensusTurboConfig{}
			}
			if err := m.ConsensusTurboConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableSenderGroup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableSenderGroup = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableConflictsBitWindow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableConflictsBitWindow = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableOptimizeChargeGas", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableOptimizeChargeGas = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= consensus.ConsensusType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &OrgConfig{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtConfig = append(m.ExtConfig, &ConfigKeyValue{})
			if err := m.ExtConfig[len(m.ExtConfig)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DposConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DposConfig = append(m.DposConfig, &ConfigKeyValue{})
			if err := m.DposConfig[len(m.DposConfig)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrgConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrgConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrgConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = append(m.NodeId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrustRootConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrustRootConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrustRootConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = append(m.Root, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableSqlSupport", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableSqlSupport = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisabledNativeContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisabledNativeContract = append(m.DisabledNativeContract, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlyCreatorCanUpgrade", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnlyCreatorCanUpgrade = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrustMemberConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrustMemberConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrustMemberConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MemberInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupportList = append(m.SupportList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrType", wireType)
			}
			m.AddrType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddrType |= AddrType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Native", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Native == nil {
				m.Native = &VmNative{}
			}
			if err := m.Native.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VmNative) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VmNative: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VmNative: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multisign", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Multisign == nil {
				m.Multisign = &MultiSign{}
			}
			if err := m.Multisign.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiSign) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiSign: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiSign: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableManualRun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableManualRun = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipChainConfig(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthChainConfig
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupChainConfig
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthChainConfig
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthChainConfig        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowChainConfig          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupChainConfig = fmt.Errorf("proto: unexpected end of group")
)
