// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tee/enclave_server.proto

package tee

import (
	common "zhanghefan123/security/protobuf/pb-go/common"
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type InitEnclaveRequest struct {
	// Sign algorithm of TEE
	TeeCertSignAlg string `protobuf:"bytes,1,opt,name=tee_cert_sign_alg,json=teeCertSignAlg,proto3" json:"tee_cert_sign_alg,omitempty"`
	// Encrypt algorithm of TEE
	TeeEncryptAlg string `protobuf:"bytes,2,opt,name=tee_encrypt_alg,json=teeEncryptAlg,proto3" json:"tee_encrypt_alg,omitempty"`
}

func (m *InitEnclaveRequest) Reset()         { *m = InitEnclaveRequest{} }
func (m *InitEnclaveRequest) String() string { return proto.CompactTextString(m) }
func (*InitEnclaveRequest) ProtoMessage()    {}
func (*InitEnclaveRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7502c848eed594a1, []int{0}
}
func (m *InitEnclaveRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InitEnclaveRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InitEnclaveRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InitEnclaveRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitEnclaveRequest.Merge(m, src)
}
func (m *InitEnclaveRequest) XXX_Size() int {
	return m.Size()
}
func (m *InitEnclaveRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InitEnclaveRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InitEnclaveRequest proto.InternalMessageInfo

func (m *InitEnclaveRequest) GetTeeCertSignAlg() string {
	if m != nil {
		return m.TeeCertSignAlg
	}
	return ""
}

func (m *InitEnclaveRequest) GetTeeEncryptAlg() string {
	if m != nil {
		return m.TeeEncryptAlg
	}
	return ""
}

type InitEnclaveResponse struct {
	TeeReport []byte `protobuf:"bytes,1,opt,name=tee_report,json=teeReport,proto3" json:"tee_report,omitempty"`
	TeePubkey []byte `protobuf:"bytes,2,opt,name=tee_pubkey,json=teePubkey,proto3" json:"tee_pubkey,omitempty"`
	TeeCsr    []byte `protobuf:"bytes,3,opt,name=tee_csr,json=teeCsr,proto3" json:"tee_csr,omitempty"`
}

func (m *InitEnclaveResponse) Reset()         { *m = InitEnclaveResponse{} }
func (m *InitEnclaveResponse) String() string { return proto.CompactTextString(m) }
func (*InitEnclaveResponse) ProtoMessage()    {}
func (*InitEnclaveResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7502c848eed594a1, []int{1}
}
func (m *InitEnclaveResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InitEnclaveResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InitEnclaveResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InitEnclaveResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitEnclaveResponse.Merge(m, src)
}
func (m *InitEnclaveResponse) XXX_Size() int {
	return m.Size()
}
func (m *InitEnclaveResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InitEnclaveResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InitEnclaveResponse proto.InternalMessageInfo

func (m *InitEnclaveResponse) GetTeeReport() []byte {
	if m != nil {
		return m.TeeReport
	}
	return nil
}

func (m *InitEnclaveResponse) GetTeePubkey() []byte {
	if m != nil {
		return m.TeePubkey
	}
	return nil
}

func (m *InitEnclaveResponse) GetTeeCsr() []byte {
	if m != nil {
		return m.TeeCsr
	}
	return nil
}

type EnclaveResponse struct {
	EnclaveResponsePayload *EnclaveResponsePayload `protobuf:"bytes,1,opt,name=enclave_response_payload,json=enclaveResponsePayload,proto3" json:"enclave_response_payload,omitempty"`
	Signature              []byte                  `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *EnclaveResponse) Reset()         { *m = EnclaveResponse{} }
func (m *EnclaveResponse) String() string { return proto.CompactTextString(m) }
func (*EnclaveResponse) ProtoMessage()    {}
func (*EnclaveResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7502c848eed594a1, []int{2}
}
func (m *EnclaveResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnclaveResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnclaveResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnclaveResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnclaveResponse.Merge(m, src)
}
func (m *EnclaveResponse) XXX_Size() int {
	return m.Size()
}
func (m *EnclaveResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EnclaveResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EnclaveResponse proto.InternalMessageInfo

func (m *EnclaveResponse) GetEnclaveResponsePayload() *EnclaveResponsePayload {
	if m != nil {
		return m.EnclaveResponsePayload
	}
	return nil
}

func (m *EnclaveResponse) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type EnclaveResponsePayload struct {
	ContractResult  *common.ContractResult `protobuf:"bytes,1,opt,name=contract_result,json=contractResult,proto3" json:"contract_result,omitempty"`
	TxRwset         *common.TxRWSet        `protobuf:"bytes,2,opt,name=tx_rwset,json=txRwset,proto3" json:"tx_rwset,omitempty"`
	TxRequest       *common.TxRequest      `protobuf:"bytes,3,opt,name=tx_request,json=txRequest,proto3" json:"tx_request,omitempty"`
	ContractName    string                 `protobuf:"bytes,4,opt,name=contract_name,json=contractName,proto3" json:"contract_name,omitempty"`
	ContractVersion string                 `protobuf:"bytes,5,opt,name=contract_version,json=contractVersion,proto3" json:"contract_version,omitempty"`
	ContractHash    string                 `protobuf:"bytes,6,opt,name=contract_hash,json=contractHash,proto3" json:"contract_hash,omitempty"`
	ReportHash      string                 `protobuf:"bytes,7,opt,name=report_hash,json=reportHash,proto3" json:"report_hash,omitempty"`
}

func (m *EnclaveResponsePayload) Reset()         { *m = EnclaveResponsePayload{} }
func (m *EnclaveResponsePayload) String() string { return proto.CompactTextString(m) }
func (*EnclaveResponsePayload) ProtoMessage()    {}
func (*EnclaveResponsePayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_7502c848eed594a1, []int{3}
}
func (m *EnclaveResponsePayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnclaveResponsePayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnclaveResponsePayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnclaveResponsePayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnclaveResponsePayload.Merge(m, src)
}
func (m *EnclaveResponsePayload) XXX_Size() int {
	return m.Size()
}
func (m *EnclaveResponsePayload) XXX_DiscardUnknown() {
	xxx_messageInfo_EnclaveResponsePayload.DiscardUnknown(m)
}

var xxx_messageInfo_EnclaveResponsePayload proto.InternalMessageInfo

func (m *EnclaveResponsePayload) GetContractResult() *common.ContractResult {
	if m != nil {
		return m.ContractResult
	}
	return nil
}

func (m *EnclaveResponsePayload) GetTxRwset() *common.TxRWSet {
	if m != nil {
		return m.TxRwset
	}
	return nil
}

func (m *EnclaveResponsePayload) GetTxRequest() *common.TxRequest {
	if m != nil {
		return m.TxRequest
	}
	return nil
}

func (m *EnclaveResponsePayload) GetContractName() string {
	if m != nil {
		return m.ContractName
	}
	return ""
}

func (m *EnclaveResponsePayload) GetContractVersion() string {
	if m != nil {
		return m.ContractVersion
	}
	return ""
}

func (m *EnclaveResponsePayload) GetContractHash() string {
	if m != nil {
		return m.ContractHash
	}
	return ""
}

func (m *EnclaveResponsePayload) GetReportHash() string {
	if m != nil {
		return m.ReportHash
	}
	return ""
}

type RemoteAttestationRequest struct {
	Challenge string `protobuf:"bytes,1,opt,name=challenge,proto3" json:"challenge,omitempty"`
}

func (m *RemoteAttestationRequest) Reset()         { *m = RemoteAttestationRequest{} }
func (m *RemoteAttestationRequest) String() string { return proto.CompactTextString(m) }
func (*RemoteAttestationRequest) ProtoMessage()    {}
func (*RemoteAttestationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7502c848eed594a1, []int{4}
}
func (m *RemoteAttestationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteAttestationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoteAttestationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoteAttestationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteAttestationRequest.Merge(m, src)
}
func (m *RemoteAttestationRequest) XXX_Size() int {
	return m.Size()
}
func (m *RemoteAttestationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteAttestationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteAttestationRequest proto.InternalMessageInfo

func (m *RemoteAttestationRequest) GetChallenge() string {
	if m != nil {
		return m.Challenge
	}
	return ""
}

type RemoteAttestationResponse struct {
	RemoteAttestationPayload *RemoteAttestationPayload `protobuf:"bytes,1,opt,name=remote_attestation_payload,json=remoteAttestationPayload,proto3" json:"remote_attestation_payload,omitempty"`
	// signature on challenge + report + tee_cert
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *RemoteAttestationResponse) Reset()         { *m = RemoteAttestationResponse{} }
func (m *RemoteAttestationResponse) String() string { return proto.CompactTextString(m) }
func (*RemoteAttestationResponse) ProtoMessage()    {}
func (*RemoteAttestationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7502c848eed594a1, []int{5}
}
func (m *RemoteAttestationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteAttestationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoteAttestationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoteAttestationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteAttestationResponse.Merge(m, src)
}
func (m *RemoteAttestationResponse) XXX_Size() int {
	return m.Size()
}
func (m *RemoteAttestationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteAttestationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteAttestationResponse proto.InternalMessageInfo

func (m *RemoteAttestationResponse) GetRemoteAttestationPayload() *RemoteAttestationPayload {
	if m != nil {
		return m.RemoteAttestationPayload
	}
	return nil
}

func (m *RemoteAttestationResponse) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type RemoteAttestationPayload struct {
	Challenge string `protobuf:"bytes,1,opt,name=challenge,proto3" json:"challenge,omitempty"`
	Report    []byte `protobuf:"bytes,2,opt,name=report,proto3" json:"report,omitempty"`
	TeeCert   []byte `protobuf:"bytes,3,opt,name=tee_cert,json=teeCert,proto3" json:"tee_cert,omitempty"`
}

func (m *RemoteAttestationPayload) Reset()         { *m = RemoteAttestationPayload{} }
func (m *RemoteAttestationPayload) String() string { return proto.CompactTextString(m) }
func (*RemoteAttestationPayload) ProtoMessage()    {}
func (*RemoteAttestationPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_7502c848eed594a1, []int{6}
}
func (m *RemoteAttestationPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteAttestationPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoteAttestationPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoteAttestationPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteAttestationPayload.Merge(m, src)
}
func (m *RemoteAttestationPayload) XXX_Size() int {
	return m.Size()
}
func (m *RemoteAttestationPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteAttestationPayload.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteAttestationPayload proto.InternalMessageInfo

func (m *RemoteAttestationPayload) GetChallenge() string {
	if m != nil {
		return m.Challenge
	}
	return ""
}

func (m *RemoteAttestationPayload) GetReport() []byte {
	if m != nil {
		return m.Report
	}
	return nil
}

func (m *RemoteAttestationPayload) GetTeeCert() []byte {
	if m != nil {
		return m.TeeCert
	}
	return nil
}

func init() {
	proto.RegisterType((*InitEnclaveRequest)(nil), "tee.InitEnclaveRequest")
	proto.RegisterType((*InitEnclaveResponse)(nil), "tee.InitEnclaveResponse")
	proto.RegisterType((*EnclaveResponse)(nil), "tee.EnclaveResponse")
	proto.RegisterType((*EnclaveResponsePayload)(nil), "tee.EnclaveResponsePayload")
	proto.RegisterType((*RemoteAttestationRequest)(nil), "tee.RemoteAttestationRequest")
	proto.RegisterType((*RemoteAttestationResponse)(nil), "tee.RemoteAttestationResponse")
	proto.RegisterType((*RemoteAttestationPayload)(nil), "tee.RemoteAttestationPayload")
}

func init() { proto.RegisterFile("tee/enclave_server.proto", fileDescriptor_7502c848eed594a1) }

var fileDescriptor_7502c848eed594a1 = []byte{
	// 671 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0x4f, 0x4f, 0x13, 0x4f,
	0x18, 0x6e, 0xe1, 0xf7, 0x6b, 0xe9, 0x5b, 0xa0, 0x32, 0x60, 0x59, 0x2a, 0x54, 0x53, 0x12, 0x23,
	0x26, 0xb6, 0xa6, 0x5e, 0x4c, 0x3c, 0x18, 0x40, 0x12, 0xb9, 0x18, 0xb2, 0xa0, 0x46, 0x3d, 0x6c,
	0xa6, 0xeb, 0x9b, 0x6d, 0xd3, 0xed, 0xcc, 0x3a, 0xfb, 0xb6, 0xd2, 0x2f, 0xe0, 0xd9, 0x93, 0x9f,
	0xc1, 0x8f, 0xe2, 0xc5, 0x84, 0xa3, 0x47, 0x03, 0x5f, 0xc4, 0xec, 0xcc, 0x4e, 0x69, 0x69, 0x1b,
	0x13, 0x6f, 0xbb, 0xcf, 0xf3, 0xbc, 0xcf, 0xbc, 0xf3, 0xfe, 0x19, 0x70, 0x08, 0xb1, 0x81, 0xc2,
	0x0f, 0xf9, 0x00, 0xbd, 0x18, 0xd5, 0x00, 0x55, 0x3d, 0x52, 0x92, 0x24, 0x5b, 0x24, 0xc4, 0xca,
	0x86, 0x2f, 0x7b, 0x3d, 0x29, 0x1a, 0x0a, 0x3f, 0xf5, 0x31, 0x26, 0x43, 0x55, 0xd6, 0x47, 0x68,
	0xdc, 0x0f, 0x2d, 0xc8, 0x2c, 0xf8, 0x39, 0xc6, 0x14, 0xab, 0x05, 0xc0, 0x8e, 0x45, 0x87, 0x8e,
	0x8c, 0xbf, 0x6b, 0x4c, 0xd8, 0x1e, 0xac, 0x11, 0xa2, 0xe7, 0xa3, 0x22, 0x2f, 0xee, 0x04, 0xc2,
	0xe3, 0x61, 0xe0, 0x64, 0xef, 0x65, 0x1f, 0x14, 0xdc, 0x55, 0x42, 0x3c, 0x44, 0x45, 0xa7, 0x9d,
	0x40, 0xec, 0x87, 0x01, 0xbb, 0x0f, 0xa5, 0x44, 0x8a, 0xc2, 0x57, 0xc3, 0x88, 0xb4, 0x70, 0x41,
	0x0b, 0x57, 0x08, 0xf1, 0xc8, 0xa0, 0xfb, 0x61, 0x50, 0x0b, 0x61, 0x7d, 0xe2, 0xa0, 0x38, 0x92,
	0x22, 0x46, 0xb6, 0x03, 0x90, 0x84, 0x2b, 0x8c, 0xa4, 0x22, 0x7d, 0xc4, 0xb2, 0x5b, 0x20, 0x44,
	0x57, 0x03, 0x96, 0x8e, 0xfa, 0xad, 0x2e, 0x0e, 0xb5, 0xb1, 0xa1, 0x4f, 0x34, 0xc0, 0x36, 0x21,
	0xaf, 0xf3, 0x8c, 0x95, 0xb3, 0xa8, 0xb9, 0x5c, 0x92, 0x5d, 0xac, 0x6a, 0x5f, 0xb2, 0x50, 0xba,
	0x79, 0xd4, 0x6b, 0x70, 0x6c, 0x19, 0x55, 0x8a, 0x79, 0x11, 0x1f, 0x86, 0x92, 0x7f, 0xd4, 0x07,
	0x17, 0x9b, 0x77, 0xea, 0x84, 0x58, 0xbf, 0x11, 0x77, 0x62, 0x24, 0x6e, 0x19, 0x67, 0xe2, 0x6c,
	0x1b, 0x0a, 0x49, 0x89, 0x38, 0xf5, 0x15, 0xda, 0x0c, 0x47, 0x40, 0xed, 0xe7, 0x02, 0x94, 0x67,
	0x1b, 0xb2, 0xe7, 0x50, 0xf2, 0xa5, 0x20, 0xc5, 0x7d, 0xf2, 0x4c, 0x9f, 0xd2, 0x34, 0xca, 0x75,
	0xd3, 0xa8, 0xfa, 0x61, 0x4a, 0xbb, 0x9a, 0x75, 0x57, 0xfd, 0x89, 0x7f, 0xf6, 0x10, 0x96, 0xe8,
	0xdc, 0xd3, 0xdd, 0xd4, 0x07, 0x17, 0x9b, 0x25, 0x1b, 0x79, 0x76, 0xee, 0xbe, 0x3d, 0x45, 0x72,
	0xf3, 0x74, 0xee, 0x26, 0x3c, 0x7b, 0x0c, 0x90, 0x68, 0x4d, 0x7f, 0x75, 0xb1, 0x8a, 0xcd, 0xb5,
	0x31, 0xb5, 0x21, 0xdc, 0x02, 0xd9, 0x4f, 0xb6, 0x0b, 0x2b, 0xa3, 0xf4, 0x04, 0xef, 0xa1, 0xf3,
	0x9f, 0x6e, 0xeb, 0xb2, 0x05, 0x5f, 0xf1, 0x1e, 0xb2, 0x3d, 0xb8, 0x35, 0x12, 0x0d, 0x50, 0xc5,
	0x1d, 0x29, 0x9c, 0xff, 0xb5, 0x6e, 0x74, 0xb7, 0x37, 0x06, 0x9e, 0xf0, 0x6b, 0xf3, 0xb8, 0xed,
	0xe4, 0x26, 0xfd, 0x5e, 0xf2, 0xb8, 0xcd, 0xee, 0x42, 0xd1, 0x8c, 0x82, 0x91, 0xe4, 0xb5, 0x04,
	0x0c, 0x94, 0x08, 0x6a, 0x4f, 0xc1, 0x71, 0xb1, 0x27, 0x09, 0xf7, 0x89, 0x30, 0x26, 0x4e, 0x1d,
	0x29, 0x6c, 0xc6, 0xdb, 0x50, 0xf0, 0xdb, 0x3c, 0x0c, 0x51, 0x04, 0x98, 0x4e, 0xeb, 0x35, 0x50,
	0xfb, 0x96, 0x85, 0xad, 0x19, 0xa1, 0xe9, 0x70, 0x7c, 0x80, 0x8a, 0xd2, 0xa4, 0xc7, 0xaf, 0xd9,
	0x1b, 0xe3, 0xb1, 0xa3, 0xc7, 0x63, 0xca, 0xc3, 0x0e, 0x88, 0xa3, 0xe6, 0x30, 0x7f, 0x19, 0x91,
	0xee, 0x8c, 0x2b, 0x8d, 0x45, 0xce, 0xbf, 0x12, 0x2b, 0x43, 0x2e, 0x5d, 0x1c, 0x63, 0x9a, 0xfe,
	0xb1, 0x2d, 0x58, 0xb2, 0xeb, 0x9b, 0xee, 0x45, 0x3e, 0xdd, 0xda, 0xe6, 0xf7, 0x05, 0x58, 0x49,
	0xe7, 0xf1, 0x54, 0xbf, 0x25, 0xec, 0x00, 0x8a, 0x63, 0x8b, 0xc9, 0x36, 0xf5, 0x25, 0xa7, 0xdf,
	0x84, 0x8a, 0x33, 0x4d, 0x98, 0xda, 0xd5, 0x32, 0xec, 0x19, 0xac, 0xbe, 0xc0, 0x28, 0x94, 0x43,
	0x3b, 0xb1, 0x6c, 0x7a, 0xb6, 0x2a, 0x1b, 0xb3, 0xb6, 0xcb, 0x04, 0x1f, 0x8b, 0x81, 0xec, 0xe2,
	0xbf, 0x04, 0xbf, 0x83, 0xf2, 0x74, 0xf1, 0x94, 0x1c, 0x20, 0x9b, 0xd3, 0x2d, 0x6b, 0x58, 0x9d,
	0x47, 0x5b, 0xeb, 0x83, 0xb3, 0x1f, 0x97, 0xd5, 0xec, 0xc5, 0x65, 0x35, 0xfb, 0xfb, 0xb2, 0x9a,
	0xfd, 0x7a, 0x55, 0xcd, 0x5c, 0x5c, 0x55, 0x33, 0xbf, 0xae, 0xaa, 0x19, 0xb8, 0x2d, 0x55, 0x50,
	0xf7, 0xdb, 0xbc, 0x23, 0x7a, 0xbc, 0x9b, 0x3c, 0xc7, 0xad, 0xc4, 0xec, 0xfd, 0xee, 0x18, 0x24,
	0x55, 0xd0, 0xb8, 0xfe, 0x6d, 0x44, 0xad, 0x47, 0x81, 0x6c, 0x10, 0x62, 0x2b, 0xa7, 0xdf, 0xdd,
	0x27, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x36, 0xc5, 0xaa, 0x4a, 0xd7, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// EnclaveServerClient is the client API for EnclaveServer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EnclaveServerClient interface {
	// Init Enclave (optional):
	// 1. Generate and return report.
	// 2. Generate private key and return public key (RSA & ECC).
	// 3. Generate and return csr. (Cert will be put into trusted files later)
	InitEnclave(ctx context.Context, in *InitEnclaveRequest, opts ...grpc.CallOption) (*InitEnclaveResponse, error)
	// Deploy contract.
	DeployContract(ctx context.Context, in *common.TxRequest, opts ...grpc.CallOption) (*EnclaveResponse, error)
	// Invoke contract.
	InvokeContract(ctx context.Context, in *common.TxRequest, opts ...grpc.CallOption) (*EnclaveResponse, error)
	// Remote attestation prove
	RemoteAttestationProve(ctx context.Context, in *RemoteAttestationRequest, opts ...grpc.CallOption) (*RemoteAttestationResponse, error)
}

type enclaveServerClient struct {
	cc *grpc.ClientConn
}

func NewEnclaveServerClient(cc *grpc.ClientConn) EnclaveServerClient {
	return &enclaveServerClient{cc}
}

func (c *enclaveServerClient) InitEnclave(ctx context.Context, in *InitEnclaveRequest, opts ...grpc.CallOption) (*InitEnclaveResponse, error) {
	out := new(InitEnclaveResponse)
	err := c.cc.Invoke(ctx, "/tee.EnclaveServer/InitEnclave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveServerClient) DeployContract(ctx context.Context, in *common.TxRequest, opts ...grpc.CallOption) (*EnclaveResponse, error) {
	out := new(EnclaveResponse)
	err := c.cc.Invoke(ctx, "/tee.EnclaveServer/DeployContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveServerClient) InvokeContract(ctx context.Context, in *common.TxRequest, opts ...grpc.CallOption) (*EnclaveResponse, error) {
	out := new(EnclaveResponse)
	err := c.cc.Invoke(ctx, "/tee.EnclaveServer/InvokeContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveServerClient) RemoteAttestationProve(ctx context.Context, in *RemoteAttestationRequest, opts ...grpc.CallOption) (*RemoteAttestationResponse, error) {
	out := new(RemoteAttestationResponse)
	err := c.cc.Invoke(ctx, "/tee.EnclaveServer/RemoteAttestationProve", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EnclaveServerServer is the server API for EnclaveServer service.
type EnclaveServerServer interface {
	// Init Enclave (optional):
	// 1. Generate and return report.
	// 2. Generate private key and return public key (RSA & ECC).
	// 3. Generate and return csr. (Cert will be put into trusted files later)
	InitEnclave(context.Context, *InitEnclaveRequest) (*InitEnclaveResponse, error)
	// Deploy contract.
	DeployContract(context.Context, *common.TxRequest) (*EnclaveResponse, error)
	// Invoke contract.
	InvokeContract(context.Context, *common.TxRequest) (*EnclaveResponse, error)
	// Remote attestation prove
	RemoteAttestationProve(context.Context, *RemoteAttestationRequest) (*RemoteAttestationResponse, error)
}

// UnimplementedEnclaveServerServer can be embedded to have forward compatible implementations.
type UnimplementedEnclaveServerServer struct {
}

func (*UnimplementedEnclaveServerServer) InitEnclave(ctx context.Context, req *InitEnclaveRequest) (*InitEnclaveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitEnclave not implemented")
}
func (*UnimplementedEnclaveServerServer) DeployContract(ctx context.Context, req *common.TxRequest) (*EnclaveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeployContract not implemented")
}
func (*UnimplementedEnclaveServerServer) InvokeContract(ctx context.Context, req *common.TxRequest) (*EnclaveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InvokeContract not implemented")
}
func (*UnimplementedEnclaveServerServer) RemoteAttestationProve(ctx context.Context, req *RemoteAttestationRequest) (*RemoteAttestationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoteAttestationProve not implemented")
}

func RegisterEnclaveServerServer(s *grpc.Server, srv EnclaveServerServer) {
	s.RegisterService(&_EnclaveServer_serviceDesc, srv)
}

func _EnclaveServer_InitEnclave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitEnclaveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveServerServer).InitEnclave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tee.EnclaveServer/InitEnclave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveServerServer).InitEnclave(ctx, req.(*InitEnclaveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveServer_DeployContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.TxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveServerServer).DeployContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tee.EnclaveServer/DeployContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveServerServer).DeployContract(ctx, req.(*common.TxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveServer_InvokeContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.TxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveServerServer).InvokeContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tee.EnclaveServer/InvokeContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveServerServer).InvokeContract(ctx, req.(*common.TxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveServer_RemoteAttestationProve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoteAttestationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveServerServer).RemoteAttestationProve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tee.EnclaveServer/RemoteAttestationProve",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveServerServer).RemoteAttestationProve(ctx, req.(*RemoteAttestationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _EnclaveServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tee.EnclaveServer",
	HandlerType: (*EnclaveServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InitEnclave",
			Handler:    _EnclaveServer_InitEnclave_Handler,
		},
		{
			MethodName: "DeployContract",
			Handler:    _EnclaveServer_DeployContract_Handler,
		},
		{
			MethodName: "InvokeContract",
			Handler:    _EnclaveServer_InvokeContract_Handler,
		},
		{
			MethodName: "RemoteAttestationProve",
			Handler:    _EnclaveServer_RemoteAttestationProve_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tee/enclave_server.proto",
}

func (m *InitEnclaveRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitEnclaveRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InitEnclaveRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TeeEncryptAlg) > 0 {
		i -= len(m.TeeEncryptAlg)
		copy(dAtA[i:], m.TeeEncryptAlg)
		i = encodeVarintEnclaveServer(dAtA, i, uint64(len(m.TeeEncryptAlg)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TeeCertSignAlg) > 0 {
		i -= len(m.TeeCertSignAlg)
		copy(dAtA[i:], m.TeeCertSignAlg)
		i = encodeVarintEnclaveServer(dAtA, i, uint64(len(m.TeeCertSignAlg)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InitEnclaveResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitEnclaveResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InitEnclaveResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TeeCsr) > 0 {
		i -= len(m.TeeCsr)
		copy(dAtA[i:], m.TeeCsr)
		i = encodeVarintEnclaveServer(dAtA, i, uint64(len(m.TeeCsr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TeePubkey) > 0 {
		i -= len(m.TeePubkey)
		copy(dAtA[i:], m.TeePubkey)
		i = encodeVarintEnclaveServer(dAtA, i, uint64(len(m.TeePubkey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TeeReport) > 0 {
		i -= len(m.TeeReport)
		copy(dAtA[i:], m.TeeReport)
		i = encodeVarintEnclaveServer(dAtA, i, uint64(len(m.TeeReport)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EnclaveResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnclaveResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnclaveResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintEnclaveServer(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if m.EnclaveResponsePayload != nil {
		{
			size, err := m.EnclaveResponsePayload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEnclaveServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EnclaveResponsePayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnclaveResponsePayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnclaveResponsePayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ReportHash) > 0 {
		i -= len(m.ReportHash)
		copy(dAtA[i:], m.ReportHash)
		i = encodeVarintEnclaveServer(dAtA, i, uint64(len(m.ReportHash)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ContractHash) > 0 {
		i -= len(m.ContractHash)
		copy(dAtA[i:], m.ContractHash)
		i = encodeVarintEnclaveServer(dAtA, i, uint64(len(m.ContractHash)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ContractVersion) > 0 {
		i -= len(m.ContractVersion)
		copy(dAtA[i:], m.ContractVersion)
		i = encodeVarintEnclaveServer(dAtA, i, uint64(len(m.ContractVersion)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ContractName) > 0 {
		i -= len(m.ContractName)
		copy(dAtA[i:], m.ContractName)
		i = encodeVarintEnclaveServer(dAtA, i, uint64(len(m.ContractName)))
		i--
		dAtA[i] = 0x22
	}
	if m.TxRequest != nil {
		{
			size, err := m.TxRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEnclaveServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TxRwset != nil {
		{
			size, err := m.TxRwset.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEnclaveServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ContractResult != nil {
		{
			size, err := m.ContractResult.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEnclaveServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemoteAttestationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteAttestationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteAttestationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Challenge) > 0 {
		i -= len(m.Challenge)
		copy(dAtA[i:], m.Challenge)
		i = encodeVarintEnclaveServer(dAtA, i, uint64(len(m.Challenge)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemoteAttestationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteAttestationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteAttestationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintEnclaveServer(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if m.RemoteAttestationPayload != nil {
		{
			size, err := m.RemoteAttestationPayload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEnclaveServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemoteAttestationPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteAttestationPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteAttestationPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TeeCert) > 0 {
		i -= len(m.TeeCert)
		copy(dAtA[i:], m.TeeCert)
		i = encodeVarintEnclaveServer(dAtA, i, uint64(len(m.TeeCert)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Report) > 0 {
		i -= len(m.Report)
		copy(dAtA[i:], m.Report)
		i = encodeVarintEnclaveServer(dAtA, i, uint64(len(m.Report)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Challenge) > 0 {
		i -= len(m.Challenge)
		copy(dAtA[i:], m.Challenge)
		i = encodeVarintEnclaveServer(dAtA, i, uint64(len(m.Challenge)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEnclaveServer(dAtA []byte, offset int, v uint64) int {
	offset -= sovEnclaveServer(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *InitEnclaveRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TeeCertSignAlg)
	if l > 0 {
		n += 1 + l + sovEnclaveServer(uint64(l))
	}
	l = len(m.TeeEncryptAlg)
	if l > 0 {
		n += 1 + l + sovEnclaveServer(uint64(l))
	}
	return n
}

func (m *InitEnclaveResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TeeReport)
	if l > 0 {
		n += 1 + l + sovEnclaveServer(uint64(l))
	}
	l = len(m.TeePubkey)
	if l > 0 {
		n += 1 + l + sovEnclaveServer(uint64(l))
	}
	l = len(m.TeeCsr)
	if l > 0 {
		n += 1 + l + sovEnclaveServer(uint64(l))
	}
	return n
}

func (m *EnclaveResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnclaveResponsePayload != nil {
		l = m.EnclaveResponsePayload.Size()
		n += 1 + l + sovEnclaveServer(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovEnclaveServer(uint64(l))
	}
	return n
}

func (m *EnclaveResponsePayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContractResult != nil {
		l = m.ContractResult.Size()
		n += 1 + l + sovEnclaveServer(uint64(l))
	}
	if m.TxRwset != nil {
		l = m.TxRwset.Size()
		n += 1 + l + sovEnclaveServer(uint64(l))
	}
	if m.TxRequest != nil {
		l = m.TxRequest.Size()
		n += 1 + l + sovEnclaveServer(uint64(l))
	}
	l = len(m.ContractName)
	if l > 0 {
		n += 1 + l + sovEnclaveServer(uint64(l))
	}
	l = len(m.ContractVersion)
	if l > 0 {
		n += 1 + l + sovEnclaveServer(uint64(l))
	}
	l = len(m.ContractHash)
	if l > 0 {
		n += 1 + l + sovEnclaveServer(uint64(l))
	}
	l = len(m.ReportHash)
	if l > 0 {
		n += 1 + l + sovEnclaveServer(uint64(l))
	}
	return n
}

func (m *RemoteAttestationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Challenge)
	if l > 0 {
		n += 1 + l + sovEnclaveServer(uint64(l))
	}
	return n
}

func (m *RemoteAttestationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RemoteAttestationPayload != nil {
		l = m.RemoteAttestationPayload.Size()
		n += 1 + l + sovEnclaveServer(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovEnclaveServer(uint64(l))
	}
	return n
}

func (m *RemoteAttestationPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Challenge)
	if l > 0 {
		n += 1 + l + sovEnclaveServer(uint64(l))
	}
	l = len(m.Report)
	if l > 0 {
		n += 1 + l + sovEnclaveServer(uint64(l))
	}
	l = len(m.TeeCert)
	if l > 0 {
		n += 1 + l + sovEnclaveServer(uint64(l))
	}
	return n
}

func sovEnclaveServer(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEnclaveServer(x uint64) (n int) {
	return sovEnclaveServer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *InitEnclaveRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclaveServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitEnclaveRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitEnclaveRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeeCertSignAlg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclaveServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TeeCertSignAlg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeeEncryptAlg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclaveServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TeeEncryptAlg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclaveServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitEnclaveResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclaveServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitEnclaveResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitEnclaveResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeeReport", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclaveServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TeeReport = append(m.TeeReport[:0], dAtA[iNdEx:postIndex]...)
			if m.TeeReport == nil {
				m.TeeReport = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeePubkey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclaveServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TeePubkey = append(m.TeePubkey[:0], dAtA[iNdEx:postIndex]...)
			if m.TeePubkey == nil {
				m.TeePubkey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeeCsr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclaveServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TeeCsr = append(m.TeeCsr[:0], dAtA[iNdEx:postIndex]...)
			if m.TeeCsr == nil {
				m.TeeCsr = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclaveServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnclaveResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclaveServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnclaveResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnclaveResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnclaveResponsePayload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclaveServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnclaveResponsePayload == nil {
				m.EnclaveResponsePayload = &EnclaveResponsePayload{}
			}
			if err := m.EnclaveResponsePayload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclaveServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclaveServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnclaveResponsePayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclaveServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnclaveResponsePayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnclaveResponsePayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclaveServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContractResult == nil {
				m.ContractResult = &common.ContractResult{}
			}
			if err := m.ContractResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxRwset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclaveServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxRwset == nil {
				m.TxRwset = &common.TxRWSet{}
			}
			if err := m.TxRwset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclaveServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxRequest == nil {
				m.TxRequest = &common.TxRequest{}
			}
			if err := m.TxRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclaveServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclaveServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclaveServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclaveServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclaveServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteAttestationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclaveServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteAttestationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteAttestationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Challenge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclaveServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Challenge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclaveServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteAttestationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclaveServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteAttestationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteAttestationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteAttestationPayload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclaveServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemoteAttestationPayload == nil {
				m.RemoteAttestationPayload = &RemoteAttestationPayload{}
			}
			if err := m.RemoteAttestationPayload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclaveServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclaveServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteAttestationPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclaveServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteAttestationPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteAttestationPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Challenge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclaveServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Challenge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Report", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclaveServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Report = append(m.Report[:0], dAtA[iNdEx:postIndex]...)
			if m.Report == nil {
				m.Report = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeeCert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclaveServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TeeCert = append(m.TeeCert[:0], dAtA[iNdEx:postIndex]...)
			if m.TeeCert == nil {
				m.TeeCert = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclaveServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclaveServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEnclaveServer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEnclaveServer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEnclaveServer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEnclaveServer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEnclaveServer
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEnclaveServer
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEnclaveServer
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEnclaveServer        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEnclaveServer          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEnclaveServer = fmt.Errorf("proto: unexpected end of group")
)
