// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: archivecenter/archivecenter.proto

package archivecenter

import (
	common "zhanghefan123/security/protobuf/pb-go/common"
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type OperationByHash int32

const (
	OperationByHash_OperationBlockExists     OperationByHash = 0
	OperationByHash_OperationGetBlockByHash  OperationByHash = 1
	OperationByHash_OperationGetHeightByHash OperationByHash = 2
)

var OperationByHash_name = map[int32]string{
	0: "OperationBlockExists",
	1: "OperationGetBlockByHash",
	2: "OperationGetHeightByHash",
}

var OperationByHash_value = map[string]int32{
	"OperationBlockExists":     0,
	"OperationGetBlockByHash":  1,
	"OperationGetHeightByHash": 2,
}

func (x OperationByHash) String() string {
	return proto.EnumName(OperationByHash_name, int32(x))
}

func (OperationByHash) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6730fb89abfa5724, []int{0}
}

type OperationByHeight int32

const (
	OperationByHeight_OperationGetBlockByHeight       OperationByHeight = 0
	OperationByHeight_OperationGetBlockHeaderByHeight OperationByHeight = 1
)

var OperationByHeight_name = map[int32]string{
	0: "OperationGetBlockByHeight",
	1: "OperationGetBlockHeaderByHeight",
}

var OperationByHeight_value = map[string]int32{
	"OperationGetBlockByHeight":       0,
	"OperationGetBlockHeaderByHeight": 1,
}

func (x OperationByHeight) String() string {
	return proto.EnumName(OperationByHeight_name, int32(x))
}

func (OperationByHeight) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6730fb89abfa5724, []int{1}
}

type OperationByTxId int32

const (
	OperationByTxId_OperationGetTxHeight        OperationByTxId = 0
	OperationByTxId_OperationTxExists           OperationByTxId = 1
	OperationByTxId_OperationGetTxConfirmedTime OperationByTxId = 2
)

var OperationByTxId_name = map[int32]string{
	0: "OperationGetTxHeight",
	1: "OperationTxExists",
	2: "OperationGetTxConfirmedTime",
}

var OperationByTxId_value = map[string]int32{
	"OperationGetTxHeight":        0,
	"OperationTxExists":           1,
	"OperationGetTxConfirmedTime": 2,
}

func (x OperationByTxId) String() string {
	return proto.EnumName(OperationByTxId_name, int32(x))
}

func (OperationByTxId) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6730fb89abfa5724, []int{2}
}

type RegisterStatus int32

const (
	RegisterStatus_RegisterStatusSuccess  RegisterStatus = 0
	RegisterStatus_RegisterStatusConflict RegisterStatus = 1
)

var RegisterStatus_name = map[int32]string{
	0: "RegisterStatusSuccess",
	1: "RegisterStatusConflict",
}

var RegisterStatus_value = map[string]int32{
	"RegisterStatusSuccess":  0,
	"RegisterStatusConflict": 1,
}

func (x RegisterStatus) String() string {
	return proto.EnumName(RegisterStatus_name, int32(x))
}

func (RegisterStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6730fb89abfa5724, []int{3}
}

type ArchiveStatus int32

const (
	ArchiveStatus_ArchiveStatusFailed      ArchiveStatus = 0
	ArchiveStatus_ArchiveStatusHasArchived ArchiveStatus = 1
	ArchiveStatus_ArchiveStatusSuccess     ArchiveStatus = 2
)

var ArchiveStatus_name = map[int32]string{
	0: "ArchiveStatusFailed",
	1: "ArchiveStatusHasArchived",
	2: "ArchiveStatusSuccess",
}

var ArchiveStatus_value = map[string]int32{
	"ArchiveStatusFailed":      0,
	"ArchiveStatusHasArchived": 1,
	"ArchiveStatusSuccess":     2,
}

func (x ArchiveStatus) String() string {
	return proto.EnumName(ArchiveStatus_name, int32(x))
}

func (ArchiveStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6730fb89abfa5724, []int{4}
}

type StoreDataType int32

const (
	StoreDataType_BlockData      StoreDataType = 0
	StoreDataType_CompressedData StoreDataType = 1
	StoreDataType_DecompressData StoreDataType = 2
)

var StoreDataType_name = map[int32]string{
	0: "BlockData",
	1: "CompressedData",
	2: "DecompressData",
}

var StoreDataType_value = map[string]int32{
	"BlockData":      0,
	"CompressedData": 1,
	"DecompressData": 2,
}

func (x StoreDataType) String() string {
	return proto.EnumName(StoreDataType_name, int32(x))
}

func (StoreDataType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6730fb89abfa5724, []int{5}
}

type RegisterResp struct {
	RegisterStatus RegisterStatus `protobuf:"varint,1,opt,name=register_status,json=registerStatus,proto3,enum=archivecenter.RegisterStatus" json:"register_status,omitempty"`
	Code           uint32         `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
	Message        string         `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *RegisterResp) Reset()         { *m = RegisterResp{} }
func (m *RegisterResp) String() string { return proto.CompactTextString(m) }
func (*RegisterResp) ProtoMessage()    {}
func (*RegisterResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_6730fb89abfa5724, []int{0}
}
func (m *RegisterResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterResp.Merge(m, src)
}
func (m *RegisterResp) XXX_Size() int {
	return m.Size()
}
func (m *RegisterResp) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterResp.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterResp proto.InternalMessageInfo

func (m *RegisterResp) GetRegisterStatus() RegisterStatus {
	if m != nil {
		return m.RegisterStatus
	}
	return RegisterStatus_RegisterStatusSuccess
}

func (m *RegisterResp) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *RegisterResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type ArchiveBlockRequest struct {
	ChainUnique string            `protobuf:"bytes,1,opt,name=chain_unique,json=chainUnique,proto3" json:"chain_unique,omitempty"`
	Block       *common.BlockInfo `protobuf:"bytes,2,opt,name=block,proto3" json:"block,omitempty"`
}

func (m *ArchiveBlockRequest) Reset()         { *m = ArchiveBlockRequest{} }
func (m *ArchiveBlockRequest) String() string { return proto.CompactTextString(m) }
func (*ArchiveBlockRequest) ProtoMessage()    {}
func (*ArchiveBlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6730fb89abfa5724, []int{1}
}
func (m *ArchiveBlockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArchiveBlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArchiveBlockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArchiveBlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArchiveBlockRequest.Merge(m, src)
}
func (m *ArchiveBlockRequest) XXX_Size() int {
	return m.Size()
}
func (m *ArchiveBlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ArchiveBlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ArchiveBlockRequest proto.InternalMessageInfo

func (m *ArchiveBlockRequest) GetChainUnique() string {
	if m != nil {
		return m.ChainUnique
	}
	return ""
}

func (m *ArchiveBlockRequest) GetBlock() *common.BlockInfo {
	if m != nil {
		return m.Block
	}
	return nil
}

type SingleArchiveBlockResp struct {
	ArchivedBeginHeight uint64 `protobuf:"varint,1,opt,name=archived_begin_height,json=archivedBeginHeight,proto3" json:"archived_begin_height,omitempty"`
	ArchivedEndHeight   uint64 `protobuf:"varint,2,opt,name=archived_end_height,json=archivedEndHeight,proto3" json:"archived_end_height,omitempty"`
	Code                uint32 `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
	Message             string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *SingleArchiveBlockResp) Reset()         { *m = SingleArchiveBlockResp{} }
func (m *SingleArchiveBlockResp) String() string { return proto.CompactTextString(m) }
func (*SingleArchiveBlockResp) ProtoMessage()    {}
func (*SingleArchiveBlockResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_6730fb89abfa5724, []int{2}
}
func (m *SingleArchiveBlockResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SingleArchiveBlockResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SingleArchiveBlockResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SingleArchiveBlockResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SingleArchiveBlockResp.Merge(m, src)
}
func (m *SingleArchiveBlockResp) XXX_Size() int {
	return m.Size()
}
func (m *SingleArchiveBlockResp) XXX_DiscardUnknown() {
	xxx_messageInfo_SingleArchiveBlockResp.DiscardUnknown(m)
}

var xxx_messageInfo_SingleArchiveBlockResp proto.InternalMessageInfo

func (m *SingleArchiveBlockResp) GetArchivedBeginHeight() uint64 {
	if m != nil {
		return m.ArchivedBeginHeight
	}
	return 0
}

func (m *SingleArchiveBlockResp) GetArchivedEndHeight() uint64 {
	if m != nil {
		return m.ArchivedEndHeight
	}
	return 0
}

func (m *SingleArchiveBlockResp) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *SingleArchiveBlockResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type ArchiveBlockResp struct {
	ArchiveStatus ArchiveStatus `protobuf:"varint,1,opt,name=archive_status,json=archiveStatus,proto3,enum=archivecenter.ArchiveStatus" json:"archive_status,omitempty"`
	Code          uint32        `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
	Message       string        `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *ArchiveBlockResp) Reset()         { *m = ArchiveBlockResp{} }
func (m *ArchiveBlockResp) String() string { return proto.CompactTextString(m) }
func (*ArchiveBlockResp) ProtoMessage()    {}
func (*ArchiveBlockResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_6730fb89abfa5724, []int{3}
}
func (m *ArchiveBlockResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArchiveBlockResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArchiveBlockResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArchiveBlockResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArchiveBlockResp.Merge(m, src)
}
func (m *ArchiveBlockResp) XXX_Size() int {
	return m.Size()
}
func (m *ArchiveBlockResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ArchiveBlockResp.DiscardUnknown(m)
}

var xxx_messageInfo_ArchiveBlockResp proto.InternalMessageInfo

func (m *ArchiveBlockResp) GetArchiveStatus() ArchiveStatus {
	if m != nil {
		return m.ArchiveStatus
	}
	return ArchiveStatus_ArchiveStatusFailed
}

func (m *ArchiveBlockResp) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ArchiveBlockResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type ArchiveStatusRequest struct {
	ChainUnique string `protobuf:"bytes,1,opt,name=chain_unique,json=chainUnique,proto3" json:"chain_unique,omitempty"`
}

func (m *ArchiveStatusRequest) Reset()         { *m = ArchiveStatusRequest{} }
func (m *ArchiveStatusRequest) String() string { return proto.CompactTextString(m) }
func (*ArchiveStatusRequest) ProtoMessage()    {}
func (*ArchiveStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6730fb89abfa5724, []int{4}
}
func (m *ArchiveStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArchiveStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArchiveStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArchiveStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArchiveStatusRequest.Merge(m, src)
}
func (m *ArchiveStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *ArchiveStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ArchiveStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ArchiveStatusRequest proto.InternalMessageInfo

func (m *ArchiveStatusRequest) GetChainUnique() string {
	if m != nil {
		return m.ChainUnique
	}
	return ""
}

type ArchiveStatusResp struct {
	ArchivedHeight uint64 `protobuf:"varint,1,opt,name=archived_height,json=archivedHeight,proto3" json:"archived_height,omitempty"`
	InArchive      bool   `protobuf:"varint,2,opt,name=in_archive,json=inArchive,proto3" json:"in_archive,omitempty"`
	Code           uint32 `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
	Message        string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *ArchiveStatusResp) Reset()         { *m = ArchiveStatusResp{} }
func (m *ArchiveStatusResp) String() string { return proto.CompactTextString(m) }
func (*ArchiveStatusResp) ProtoMessage()    {}
func (*ArchiveStatusResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_6730fb89abfa5724, []int{5}
}
func (m *ArchiveStatusResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArchiveStatusResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArchiveStatusResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArchiveStatusResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArchiveStatusResp.Merge(m, src)
}
func (m *ArchiveStatusResp) XXX_Size() int {
	return m.Size()
}
func (m *ArchiveStatusResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ArchiveStatusResp.DiscardUnknown(m)
}

var xxx_messageInfo_ArchiveStatusResp proto.InternalMessageInfo

func (m *ArchiveStatusResp) GetArchivedHeight() uint64 {
	if m != nil {
		return m.ArchivedHeight
	}
	return 0
}

func (m *ArchiveStatusResp) GetInArchive() bool {
	if m != nil {
		return m.InArchive
	}
	return false
}

func (m *ArchiveStatusResp) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ArchiveStatusResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type RangeBlocksRequest struct {
	ChainUnique string `protobuf:"bytes,1,opt,name=chain_unique,json=chainUnique,proto3" json:"chain_unique,omitempty"`
	StartHeight uint64 `protobuf:"varint,2,opt,name=start_height,json=startHeight,proto3" json:"start_height,omitempty"`
	EndHeight   uint64 `protobuf:"varint,3,opt,name=end_height,json=endHeight,proto3" json:"end_height,omitempty"`
}

func (m *RangeBlocksRequest) Reset()         { *m = RangeBlocksRequest{} }
func (m *RangeBlocksRequest) String() string { return proto.CompactTextString(m) }
func (*RangeBlocksRequest) ProtoMessage()    {}
func (*RangeBlocksRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6730fb89abfa5724, []int{6}
}
func (m *RangeBlocksRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeBlocksRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RangeBlocksRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RangeBlocksRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeBlocksRequest.Merge(m, src)
}
func (m *RangeBlocksRequest) XXX_Size() int {
	return m.Size()
}
func (m *RangeBlocksRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeBlocksRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RangeBlocksRequest proto.InternalMessageInfo

func (m *RangeBlocksRequest) GetChainUnique() string {
	if m != nil {
		return m.ChainUnique
	}
	return ""
}

func (m *RangeBlocksRequest) GetStartHeight() uint64 {
	if m != nil {
		return m.StartHeight
	}
	return 0
}

func (m *RangeBlocksRequest) GetEndHeight() uint64 {
	if m != nil {
		return m.EndHeight
	}
	return 0
}

type BlockByHashRequest struct {
	ChainUnique string          `protobuf:"bytes,1,opt,name=chain_unique,json=chainUnique,proto3" json:"chain_unique,omitempty"`
	BlockHash   string          `protobuf:"bytes,2,opt,name=block_hash,json=blockHash,proto3" json:"block_hash,omitempty"`
	Operation   OperationByHash `protobuf:"varint,3,opt,name=operation,proto3,enum=archivecenter.OperationByHash" json:"operation,omitempty"`
}

func (m *BlockByHashRequest) Reset()         { *m = BlockByHashRequest{} }
func (m *BlockByHashRequest) String() string { return proto.CompactTextString(m) }
func (*BlockByHashRequest) ProtoMessage()    {}
func (*BlockByHashRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6730fb89abfa5724, []int{7}
}
func (m *BlockByHashRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockByHashRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockByHashRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockByHashRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockByHashRequest.Merge(m, src)
}
func (m *BlockByHashRequest) XXX_Size() int {
	return m.Size()
}
func (m *BlockByHashRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockByHashRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BlockByHashRequest proto.InternalMessageInfo

func (m *BlockByHashRequest) GetChainUnique() string {
	if m != nil {
		return m.ChainUnique
	}
	return ""
}

func (m *BlockByHashRequest) GetBlockHash() string {
	if m != nil {
		return m.BlockHash
	}
	return ""
}

func (m *BlockByHashRequest) GetOperation() OperationByHash {
	if m != nil {
		return m.Operation
	}
	return OperationByHash_OperationBlockExists
}

type BlockByHeightRequest struct {
	ChainUnique string            `protobuf:"bytes,1,opt,name=chain_unique,json=chainUnique,proto3" json:"chain_unique,omitempty"`
	Height      uint64            `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	Operation   OperationByHeight `protobuf:"varint,3,opt,name=operation,proto3,enum=archivecenter.OperationByHeight" json:"operation,omitempty"`
}

func (m *BlockByHeightRequest) Reset()         { *m = BlockByHeightRequest{} }
func (m *BlockByHeightRequest) String() string { return proto.CompactTextString(m) }
func (*BlockByHeightRequest) ProtoMessage()    {}
func (*BlockByHeightRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6730fb89abfa5724, []int{8}
}
func (m *BlockByHeightRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockByHeightRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockByHeightRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockByHeightRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockByHeightRequest.Merge(m, src)
}
func (m *BlockByHeightRequest) XXX_Size() int {
	return m.Size()
}
func (m *BlockByHeightRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockByHeightRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BlockByHeightRequest proto.InternalMessageInfo

func (m *BlockByHeightRequest) GetChainUnique() string {
	if m != nil {
		return m.ChainUnique
	}
	return ""
}

func (m *BlockByHeightRequest) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *BlockByHeightRequest) GetOperation() OperationByHeight {
	if m != nil {
		return m.Operation
	}
	return OperationByHeight_OperationGetBlockByHeight
}

type BlockByTxIdRequest struct {
	ChainUnique string `protobuf:"bytes,1,opt,name=chain_unique,json=chainUnique,proto3" json:"chain_unique,omitempty"`
	TxId        string `protobuf:"bytes,2,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
}

func (m *BlockByTxIdRequest) Reset()         { *m = BlockByTxIdRequest{} }
func (m *BlockByTxIdRequest) String() string { return proto.CompactTextString(m) }
func (*BlockByTxIdRequest) ProtoMessage()    {}
func (*BlockByTxIdRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6730fb89abfa5724, []int{9}
}
func (m *BlockByTxIdRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockByTxIdRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockByTxIdRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockByTxIdRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockByTxIdRequest.Merge(m, src)
}
func (m *BlockByTxIdRequest) XXX_Size() int {
	return m.Size()
}
func (m *BlockByTxIdRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockByTxIdRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BlockByTxIdRequest proto.InternalMessageInfo

func (m *BlockByTxIdRequest) GetChainUnique() string {
	if m != nil {
		return m.ChainUnique
	}
	return ""
}

func (m *BlockByTxIdRequest) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

type TxDetailByIdRequest struct {
	ChainUnique string          `protobuf:"bytes,1,opt,name=chain_unique,json=chainUnique,proto3" json:"chain_unique,omitempty"`
	TxId        string          `protobuf:"bytes,2,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	Operation   OperationByTxId `protobuf:"varint,3,opt,name=operation,proto3,enum=archivecenter.OperationByTxId" json:"operation,omitempty"`
}

func (m *TxDetailByIdRequest) Reset()         { *m = TxDetailByIdRequest{} }
func (m *TxDetailByIdRequest) String() string { return proto.CompactTextString(m) }
func (*TxDetailByIdRequest) ProtoMessage()    {}
func (*TxDetailByIdRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6730fb89abfa5724, []int{10}
}
func (m *TxDetailByIdRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxDetailByIdRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxDetailByIdRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxDetailByIdRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxDetailByIdRequest.Merge(m, src)
}
func (m *TxDetailByIdRequest) XXX_Size() int {
	return m.Size()
}
func (m *TxDetailByIdRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TxDetailByIdRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TxDetailByIdRequest proto.InternalMessageInfo

func (m *TxDetailByIdRequest) GetChainUnique() string {
	if m != nil {
		return m.ChainUnique
	}
	return ""
}

func (m *TxDetailByIdRequest) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

func (m *TxDetailByIdRequest) GetOperation() OperationByTxId {
	if m != nil {
		return m.Operation
	}
	return OperationByTxId_OperationGetTxHeight
}

type TxDetailByIdResp struct {
	Height          uint64 `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	TxExist         bool   `protobuf:"varint,2,opt,name=tx_exist,json=txExist,proto3" json:"tx_exist,omitempty"`
	TxConfirmedTime uint64 `protobuf:"varint,3,opt,name=tx_confirmedTime,json=txConfirmedTime,proto3" json:"tx_confirmedTime,omitempty"`
	Code            uint32 `protobuf:"varint,4,opt,name=code,proto3" json:"code,omitempty"`
	Message         string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *TxDetailByIdResp) Reset()         { *m = TxDetailByIdResp{} }
func (m *TxDetailByIdResp) String() string { return proto.CompactTextString(m) }
func (*TxDetailByIdResp) ProtoMessage()    {}
func (*TxDetailByIdResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_6730fb89abfa5724, []int{11}
}
func (m *TxDetailByIdResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxDetailByIdResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxDetailByIdResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxDetailByIdResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxDetailByIdResp.Merge(m, src)
}
func (m *TxDetailByIdResp) XXX_Size() int {
	return m.Size()
}
func (m *TxDetailByIdResp) XXX_DiscardUnknown() {
	xxx_messageInfo_TxDetailByIdResp.DiscardUnknown(m)
}

var xxx_messageInfo_TxDetailByIdResp proto.InternalMessageInfo

func (m *TxDetailByIdResp) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *TxDetailByIdResp) GetTxExist() bool {
	if m != nil {
		return m.TxExist
	}
	return false
}

func (m *TxDetailByIdResp) GetTxConfirmedTime() uint64 {
	if m != nil {
		return m.TxConfirmedTime
	}
	return 0
}

func (m *TxDetailByIdResp) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *TxDetailByIdResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type BlockWithRWSetResp struct {
	BlockData *common.BlockInfo `protobuf:"bytes,1,opt,name=block_data,json=blockData,proto3" json:"block_data,omitempty"`
	Code      uint32            `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
	Message   string            `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *BlockWithRWSetResp) Reset()         { *m = BlockWithRWSetResp{} }
func (m *BlockWithRWSetResp) String() string { return proto.CompactTextString(m) }
func (*BlockWithRWSetResp) ProtoMessage()    {}
func (*BlockWithRWSetResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_6730fb89abfa5724, []int{12}
}
func (m *BlockWithRWSetResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockWithRWSetResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockWithRWSetResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockWithRWSetResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockWithRWSetResp.Merge(m, src)
}
func (m *BlockWithRWSetResp) XXX_Size() int {
	return m.Size()
}
func (m *BlockWithRWSetResp) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockWithRWSetResp.DiscardUnknown(m)
}

var xxx_messageInfo_BlockWithRWSetResp proto.InternalMessageInfo

func (m *BlockWithRWSetResp) GetBlockData() *common.BlockInfo {
	if m != nil {
		return m.BlockData
	}
	return nil
}

func (m *BlockWithRWSetResp) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *BlockWithRWSetResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type TxRWSetResp struct {
	RwSet   *common.TxRWSet `protobuf:"bytes,1,opt,name=rw_set,json=rwSet,proto3" json:"rw_set,omitempty"`
	Code    uint32          `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
	Message string          `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *TxRWSetResp) Reset()         { *m = TxRWSetResp{} }
func (m *TxRWSetResp) String() string { return proto.CompactTextString(m) }
func (*TxRWSetResp) ProtoMessage()    {}
func (*TxRWSetResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_6730fb89abfa5724, []int{13}
}
func (m *TxRWSetResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxRWSetResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxRWSetResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxRWSetResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxRWSetResp.Merge(m, src)
}
func (m *TxRWSetResp) XXX_Size() int {
	return m.Size()
}
func (m *TxRWSetResp) XXX_DiscardUnknown() {
	xxx_messageInfo_TxRWSetResp.DiscardUnknown(m)
}

var xxx_messageInfo_TxRWSetResp proto.InternalMessageInfo

func (m *TxRWSetResp) GetRwSet() *common.TxRWSet {
	if m != nil {
		return m.RwSet
	}
	return nil
}

func (m *TxRWSetResp) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *TxRWSetResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type TransactionResp struct {
	Transaction *common.Transaction `protobuf:"bytes,1,opt,name=transaction,proto3" json:"transaction,omitempty"`
	Code        uint32              `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
	Message     string              `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *TransactionResp) Reset()         { *m = TransactionResp{} }
func (m *TransactionResp) String() string { return proto.CompactTextString(m) }
func (*TransactionResp) ProtoMessage()    {}
func (*TransactionResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_6730fb89abfa5724, []int{14}
}
func (m *TransactionResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionResp.Merge(m, src)
}
func (m *TransactionResp) XXX_Size() int {
	return m.Size()
}
func (m *TransactionResp) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionResp.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionResp proto.InternalMessageInfo

func (m *TransactionResp) GetTransaction() *common.Transaction {
	if m != nil {
		return m.Transaction
	}
	return nil
}

func (m *TransactionResp) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *TransactionResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type StoreStatusResp struct {
	StoreStatus *StoreStatus `protobuf:"bytes,1,opt,name=store_status,json=storeStatus,proto3" json:"store_status,omitempty"`
	Code        uint32       `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
	Message     string       `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *StoreStatusResp) Reset()         { *m = StoreStatusResp{} }
func (m *StoreStatusResp) String() string { return proto.CompactTextString(m) }
func (*StoreStatusResp) ProtoMessage()    {}
func (*StoreStatusResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_6730fb89abfa5724, []int{15}
}
func (m *StoreStatusResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreStatusResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreStatusResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreStatusResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreStatusResp.Merge(m, src)
}
func (m *StoreStatusResp) XXX_Size() int {
	return m.Size()
}
func (m *StoreStatusResp) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreStatusResp.DiscardUnknown(m)
}

var xxx_messageInfo_StoreStatusResp proto.InternalMessageInfo

func (m *StoreStatusResp) GetStoreStatus() *StoreStatus {
	if m != nil {
		return m.StoreStatus
	}
	return nil
}

func (m *StoreStatusResp) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *StoreStatusResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type StoreStatus struct {
	ChainUnique string       `protobuf:"bytes,1,opt,name=chain_unique,json=chainUnique,proto3" json:"chain_unique,omitempty"`
	StoreInfos  []*StoreInfo `protobuf:"bytes,2,rep,name=StoreInfos,proto3" json:"StoreInfos,omitempty"`
	Size_       int64        `protobuf:"varint,3,opt,name=size,proto3" json:"size,omitempty"`
}

func (m *StoreStatus) Reset()         { *m = StoreStatus{} }
func (m *StoreStatus) String() string { return proto.CompactTextString(m) }
func (*StoreStatus) ProtoMessage()    {}
func (*StoreStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_6730fb89abfa5724, []int{16}
}
func (m *StoreStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreStatus.Merge(m, src)
}
func (m *StoreStatus) XXX_Size() int {
	return m.Size()
}
func (m *StoreStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreStatus.DiscardUnknown(m)
}

var xxx_messageInfo_StoreStatus proto.InternalMessageInfo

func (m *StoreStatus) GetChainUnique() string {
	if m != nil {
		return m.ChainUnique
	}
	return ""
}

func (m *StoreStatus) GetStoreInfos() []*StoreInfo {
	if m != nil {
		return m.StoreInfos
	}
	return nil
}

func (m *StoreStatus) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

type StoreInfo struct {
	Type      StoreDataType `protobuf:"varint,1,opt,name=type,proto3,enum=archivecenter.StoreDataType" json:"type,omitempty"`
	FileInfos []*FileInfo   `protobuf:"bytes,2,rep,name=FileInfos,proto3" json:"FileInfos,omitempty"`
	Size_     int64         `protobuf:"varint,3,opt,name=size,proto3" json:"size,omitempty"`
}

func (m *StoreInfo) Reset()         { *m = StoreInfo{} }
func (m *StoreInfo) String() string { return proto.CompactTextString(m) }
func (*StoreInfo) ProtoMessage()    {}
func (*StoreInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6730fb89abfa5724, []int{17}
}
func (m *StoreInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreInfo.Merge(m, src)
}
func (m *StoreInfo) XXX_Size() int {
	return m.Size()
}
func (m *StoreInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreInfo.DiscardUnknown(m)
}

var xxx_messageInfo_StoreInfo proto.InternalMessageInfo

func (m *StoreInfo) GetType() StoreDataType {
	if m != nil {
		return m.Type
	}
	return StoreDataType_BlockData
}

func (m *StoreInfo) GetFileInfos() []*FileInfo {
	if m != nil {
		return m.FileInfos
	}
	return nil
}

func (m *StoreInfo) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

type FileInfo struct {
	Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Start uint64 `protobuf:"varint,2,opt,name=start,proto3" json:"start,omitempty"`
	End   uint64 `protobuf:"varint,3,opt,name=end,proto3" json:"end,omitempty"`
	Size_ int64  `protobuf:"varint,4,opt,name=size,proto3" json:"size,omitempty"`
}

func (m *FileInfo) Reset()         { *m = FileInfo{} }
func (m *FileInfo) String() string { return proto.CompactTextString(m) }
func (*FileInfo) ProtoMessage()    {}
func (*FileInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6730fb89abfa5724, []int{18}
}
func (m *FileInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileInfo.Merge(m, src)
}
func (m *FileInfo) XXX_Size() int {
	return m.Size()
}
func (m *FileInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FileInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FileInfo proto.InternalMessageInfo

func (m *FileInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FileInfo) GetStart() uint64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *FileInfo) GetEnd() uint64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *FileInfo) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func init() {
	proto.RegisterEnum("archivecenter.OperationByHash", OperationByHash_name, OperationByHash_value)
	proto.RegisterEnum("archivecenter.OperationByHeight", OperationByHeight_name, OperationByHeight_value)
	proto.RegisterEnum("archivecenter.OperationByTxId", OperationByTxId_name, OperationByTxId_value)
	proto.RegisterEnum("archivecenter.RegisterStatus", RegisterStatus_name, RegisterStatus_value)
	proto.RegisterEnum("archivecenter.ArchiveStatus", ArchiveStatus_name, ArchiveStatus_value)
	proto.RegisterEnum("archivecenter.StoreDataType", StoreDataType_name, StoreDataType_value)
	proto.RegisterType((*RegisterResp)(nil), "archivecenter.RegisterResp")
	proto.RegisterType((*ArchiveBlockRequest)(nil), "archivecenter.ArchiveBlockRequest")
	proto.RegisterType((*SingleArchiveBlockResp)(nil), "archivecenter.SingleArchiveBlockResp")
	proto.RegisterType((*ArchiveBlockResp)(nil), "archivecenter.ArchiveBlockResp")
	proto.RegisterType((*ArchiveStatusRequest)(nil), "archivecenter.ArchiveStatusRequest")
	proto.RegisterType((*ArchiveStatusResp)(nil), "archivecenter.ArchiveStatusResp")
	proto.RegisterType((*RangeBlocksRequest)(nil), "archivecenter.RangeBlocksRequest")
	proto.RegisterType((*BlockByHashRequest)(nil), "archivecenter.BlockByHashRequest")
	proto.RegisterType((*BlockByHeightRequest)(nil), "archivecenter.BlockByHeightRequest")
	proto.RegisterType((*BlockByTxIdRequest)(nil), "archivecenter.BlockByTxIdRequest")
	proto.RegisterType((*TxDetailByIdRequest)(nil), "archivecenter.TxDetailByIdRequest")
	proto.RegisterType((*TxDetailByIdResp)(nil), "archivecenter.TxDetailByIdResp")
	proto.RegisterType((*BlockWithRWSetResp)(nil), "archivecenter.BlockWithRWSetResp")
	proto.RegisterType((*TxRWSetResp)(nil), "archivecenter.TxRWSetResp")
	proto.RegisterType((*TransactionResp)(nil), "archivecenter.TransactionResp")
	proto.RegisterType((*StoreStatusResp)(nil), "archivecenter.StoreStatusResp")
	proto.RegisterType((*StoreStatus)(nil), "archivecenter.StoreStatus")
	proto.RegisterType((*StoreInfo)(nil), "archivecenter.StoreInfo")
	proto.RegisterType((*FileInfo)(nil), "archivecenter.FileInfo")
}

func init() { proto.RegisterFile("archivecenter/archivecenter.proto", fileDescriptor_6730fb89abfa5724) }

var fileDescriptor_6730fb89abfa5724 = []byte{
	// 1336 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x58, 0x51, 0x6f, 0x1b, 0x45,
	0x10, 0xbe, 0x75, 0x9c, 0x36, 0x1e, 0x37, 0xf6, 0x65, 0x93, 0xb6, 0x6e, 0xda, 0xb8, 0xe9, 0x55,
	0xd0, 0x10, 0x89, 0x24, 0x32, 0xaa, 0x04, 0x12, 0x20, 0x91, 0xb4, 0x49, 0x5a, 0x15, 0x21, 0x9d,
	0x8d, 0x82, 0xa2, 0x0a, 0x73, 0xb9, 0xdb, 0xda, 0xa7, 0xda, 0x77, 0xee, 0xed, 0x26, 0xbd, 0xf0,
	0xc0, 0x13, 0x48, 0x20, 0x5e, 0x40, 0xe2, 0x19, 0xf1, 0xcc, 0x2f, 0xe1, 0xb1, 0x8f, 0x3c, 0xa2,
	0xf6, 0x8f, 0xa0, 0x9b, 0xdb, 0x3b, 0xdf, 0xde, 0xb9, 0x91, 0x0d, 0x6f, 0xb7, 0x33, 0xb3, 0xdf,
	0x7c, 0x33, 0x3b, 0x3b, 0x3b, 0x3a, 0xb8, 0x63, 0x05, 0x76, 0xdf, 0x3d, 0x63, 0x36, 0xf3, 0x04,
	0x0b, 0xb6, 0x95, 0xd5, 0xd6, 0x28, 0xf0, 0x85, 0x4f, 0x17, 0x15, 0xe1, 0x2a, 0xb5, 0xfd, 0xe1,
	0xd0, 0xf7, 0xb6, 0x4f, 0x06, 0xbe, 0xfd, 0x3c, 0x36, 0x49, 0x65, 0xc1, 0x4b, 0xce, 0x84, 0x94,
	0x35, 0xa4, 0x4c, 0x04, 0x96, 0xc7, 0x2d, 0x5b, 0xb8, 0xbe, 0x17, 0x6b, 0x8c, 0xef, 0x09, 0x5c,
	0x31, 0x59, 0xcf, 0xe5, 0x82, 0x05, 0x26, 0xe3, 0x23, 0xba, 0x0f, 0xf5, 0x40, 0xae, 0xbb, 0x5c,
	0x58, 0xe2, 0x94, 0x37, 0xc8, 0x3a, 0xd9, 0xa8, 0xb5, 0xd6, 0xb6, 0x54, 0x42, 0xc9, 0xae, 0x36,
	0x1a, 0x99, 0xb5, 0x40, 0x59, 0x53, 0x0a, 0x65, 0xdb, 0x77, 0x58, 0xa3, 0xb4, 0x4e, 0x36, 0x16,
	0x4d, 0xfc, 0xa6, 0x0d, 0xb8, 0x3c, 0x64, 0x9c, 0x5b, 0x3d, 0xd6, 0x98, 0x5b, 0x27, 0x1b, 0x15,
	0x33, 0x59, 0x1a, 0x16, 0x2c, 0x7f, 0x16, 0xa3, 0xef, 0x46, 0xa1, 0x98, 0xec, 0xc5, 0x29, 0xe3,
	0x82, 0xde, 0x81, 0x2b, 0x76, 0xdf, 0x72, 0xbd, 0xee, 0xa9, 0xe7, 0xbe, 0x38, 0x65, 0xc8, 0xa4,
	0x62, 0x56, 0x51, 0xf6, 0x25, 0x8a, 0xe8, 0x3d, 0x98, 0xc7, 0xe8, 0xd1, 0x51, 0xb5, 0xb5, 0xb4,
	0x15, 0x87, 0xba, 0x85, 0x38, 0x8f, 0xbc, 0x67, 0xbe, 0x19, 0xeb, 0x8d, 0x3f, 0x09, 0x5c, 0x6b,
	0xbb, 0x5e, 0x6f, 0xc0, 0x54, 0x4f, 0x7c, 0x44, 0x5b, 0x70, 0x55, 0xc6, 0xe6, 0x74, 0x4f, 0x58,
	0xcf, 0xf5, 0xba, 0x7d, 0xe6, 0xf6, 0xfa, 0x02, 0xfd, 0x95, 0xcd, 0xe5, 0x44, 0xb9, 0x1b, 0xe9,
	0x0e, 0x51, 0x45, 0xb7, 0x20, 0x15, 0x77, 0x99, 0xe7, 0x24, 0x3b, 0x4a, 0xb8, 0x63, 0x29, 0x51,
	0x3d, 0xf4, 0x1c, 0x69, 0x9f, 0xe4, 0x63, 0x6e, 0x72, 0x3e, 0xca, 0x6a, 0x3e, 0x7e, 0x20, 0xa0,
	0x17, 0x68, 0xee, 0x41, 0x4d, 0xe2, 0xaa, 0x27, 0x73, 0x2b, 0x77, 0x32, 0x72, 0xa3, 0x3c, 0x98,
	0xa4, 0x64, 0xfe, 0xd3, 0xb9, 0x7c, 0x04, 0x2b, 0x2a, 0xda, 0xd4, 0x07, 0x63, 0xfc, 0x44, 0x60,
	0x29, 0xb7, 0x97, 0x8f, 0xe8, 0x3d, 0xa8, 0xa7, 0x69, 0x53, 0x92, 0x9c, 0x84, 0x96, 0xe4, 0x6b,
	0x0d, 0xc0, 0xf5, 0xba, 0x52, 0x88, 0x6c, 0x17, 0xcc, 0x8a, 0xeb, 0x49, 0xc4, 0x19, 0xd3, 0x79,
	0x0e, 0xd4, 0xb4, 0xbc, 0x5e, 0x9c, 0xcb, 0x19, 0x82, 0x88, 0x4c, 0xb8, 0xb0, 0x02, 0xa1, 0x1e,
	0x6f, 0x15, 0x65, 0x63, 0xa2, 0x99, 0xf3, 0x9f, 0x43, 0x83, 0x0a, 0x4b, 0xce, 0xdd, 0xf8, 0x8d,
	0x00, 0x45, 0xb7, 0xbb, 0xe7, 0x87, 0x16, 0xef, 0xcf, 0xe0, 0x7b, 0x0d, 0x00, 0x2b, 0xb7, 0xdb,
	0xb7, 0x78, 0x1f, 0x3d, 0x57, 0xcc, 0x0a, 0x4a, 0x22, 0x20, 0xfa, 0x31, 0x54, 0xfc, 0x11, 0x0b,
	0xac, 0xe8, 0x32, 0xa3, 0xdb, 0x5a, 0xab, 0x99, 0x2b, 0x84, 0x2f, 0x12, 0xbd, 0xf4, 0x3d, 0xde,
	0x60, 0xfc, 0x4a, 0x60, 0x25, 0xa1, 0x85, 0x44, 0x67, 0x20, 0x76, 0x0d, 0x2e, 0x29, 0xe9, 0x90,
	0x2b, 0xfa, 0x69, 0x91, 0xd1, 0xfa, 0x05, 0x8c, 0x62, 0xb7, 0x19, 0x4e, 0x4f, 0xd2, 0x4c, 0x75,
	0xc2, 0x47, 0xce, 0x0c, 0x84, 0x96, 0x61, 0x5e, 0x84, 0x5d, 0xd7, 0x91, 0x49, 0x2a, 0x8b, 0xf0,
	0x91, 0x63, 0xfc, 0x4c, 0x60, 0xb9, 0x13, 0x3e, 0x60, 0xc2, 0x72, 0x07, 0xbb, 0xe7, 0xff, 0x1b,
	0x6f, 0xc6, 0x7c, 0x63, 0x04, 0x99, 0xd8, 0x7e, 0x27, 0xa0, 0xab, 0x6c, 0xf8, 0x28, 0x93, 0x48,
	0xa2, 0x24, 0xf2, 0x06, 0x2c, 0x88, 0xb0, 0xcb, 0x42, 0x97, 0x0b, 0x59, 0xf9, 0x97, 0x45, 0xf8,
	0x30, 0x5a, 0xd2, 0xf7, 0x40, 0x17, 0x61, 0xd7, 0xf6, 0xbd, 0x67, 0x6e, 0x30, 0x64, 0x4e, 0xc7,
	0x1d, 0x32, 0x59, 0x73, 0x75, 0x11, 0xee, 0x65, 0xc5, 0xe9, 0x15, 0x29, 0x4f, 0xbe, 0x22, 0xf3,
	0xea, 0x15, 0x11, 0x32, 0xf9, 0x47, 0xae, 0xe8, 0x9b, 0x47, 0x6d, 0x26, 0x90, 0xe1, 0x4e, 0x52,
	0x83, 0x8e, 0x25, 0x2c, 0x64, 0x39, 0xb1, 0xc5, 0xc6, 0x65, 0xf9, 0xc0, 0x12, 0xd6, 0x8c, 0xfd,
	0xc5, 0x86, 0x6a, 0x27, 0x1c, 0xbb, 0x7b, 0x17, 0x2e, 0x05, 0x2f, 0xbb, 0x9c, 0x09, 0xe9, 0xaa,
	0x9e, 0xb8, 0x4a, 0x8c, 0xe6, 0x83, 0x97, 0x6d, 0x26, 0x66, 0x74, 0x72, 0x06, 0xf5, 0xce, 0xf8,
	0xe1, 0x43, 0x47, 0xf7, 0xa1, 0x9a, 0x79, 0x0b, 0xa5, 0xb7, 0xe5, 0xd4, 0x5b, 0xc6, 0x3a, 0x6b,
	0x37, 0xa3, 0xdf, 0xef, 0xa0, 0xde, 0x16, 0x7e, 0x90, 0x6d, 0x7f, 0x9f, 0x44, 0xfd, 0xc4, 0x0f,
	0x94, 0x06, 0x5e, 0x6d, 0xad, 0xe6, 0xea, 0x28, 0xbb, 0xab, 0xca, 0xc7, 0x8b, 0x99, 0xfd, 0x57,
	0x33, 0x48, 0xd3, 0x14, 0xfe, 0x87, 0x00, 0xb8, 0x23, 0x3a, 0x54, 0xde, 0x28, 0xad, 0xcf, 0x6d,
	0x54, 0x5b, 0x8d, 0x49, 0xe4, 0xf0, 0xd4, 0x33, 0xb6, 0x11, 0x33, 0xee, 0x7e, 0x1b, 0x53, 0x98,
	0x33, 0xf1, 0xdb, 0xf8, 0x91, 0x40, 0x25, 0x35, 0xa1, 0x3b, 0x50, 0x16, 0xe7, 0x23, 0xf6, 0x96,
	0x37, 0x0b, 0xed, 0xa2, 0x02, 0xea, 0x9c, 0x8f, 0x98, 0x89, 0x96, 0xf4, 0x3e, 0x54, 0xf6, 0xdd,
	0x81, 0x42, 0xe6, 0x7a, 0x6e, 0x5b, 0xa2, 0x37, 0xc7, 0x96, 0x13, 0xa9, 0x1c, 0xc3, 0x42, 0x62,
	0x10, 0xe9, 0x3d, 0x6b, 0x98, 0xc4, 0x8f, 0xdf, 0x74, 0x05, 0xe6, 0xb1, 0xa7, 0xcb, 0x8e, 0x16,
	0x2f, 0xa8, 0x0e, 0x73, 0xcc, 0x73, 0xe4, 0xfd, 0x8a, 0x3e, 0x53, 0xec, 0xf2, 0x18, 0x7b, 0xf3,
	0x19, 0xd4, 0x73, 0x8d, 0x96, 0x36, 0x60, 0x65, 0x2c, 0x8a, 0xae, 0x06, 0x5e, 0x5e, 0xae, 0x6b,
	0xf4, 0x26, 0x5c, 0x4f, 0x35, 0x07, 0x4c, 0x64, 0x5e, 0x06, 0x9d, 0xd0, 0x5b, 0xd0, 0xc8, 0x2a,
	0xe3, 0x0e, 0x29, 0xb5, 0xa5, 0xcd, 0x23, 0x58, 0x2a, 0xb4, 0x4f, 0xba, 0x06, 0x37, 0x26, 0xe1,
	0xa1, 0x52, 0xd7, 0xe8, 0x5d, 0xb8, 0x5d, 0x50, 0x1f, 0x32, 0xcb, 0x61, 0x41, 0x6a, 0x44, 0x36,
	0x6d, 0x25, 0x80, 0xa8, 0x73, 0x29, 0x01, 0x1c, 0x30, 0xd1, 0x09, 0x53, 0xc4, 0xab, 0x19, 0x16,
	0x9d, 0x50, 0xc6, 0x45, 0xe8, 0x6d, 0xb8, 0xa9, 0x6e, 0x50, 0x7a, 0x91, 0x5e, 0xda, 0x3c, 0x80,
	0x9a, 0x3a, 0x31, 0xd2, 0x1b, 0x70, 0x55, 0x95, 0xb4, 0x4f, 0x6d, 0x9b, 0xf1, 0x28, 0x4b, 0xab,
	0x70, 0x4d, 0x55, 0x45, 0x68, 0x03, 0xd7, 0x8e, 0xd8, 0x7e, 0x03, 0x8b, 0xca, 0x58, 0x41, 0xaf,
	0xa7, 0xb3, 0x63, 0x2c, 0xd8, 0xb7, 0xdc, 0x01, 0x73, 0x74, 0x2d, 0x4a, 0xa7, 0xa2, 0x38, 0xb4,
	0xb8, 0x5c, 0x3b, 0x3a, 0x89, 0x42, 0x54, 0xb4, 0x89, 0xf7, 0xd2, 0xe6, 0x3e, 0x2c, 0x2a, 0xe5,
	0x48, 0x17, 0xa1, 0xb2, 0x9b, 0x34, 0x38, 0x5d, 0xa3, 0x14, 0x6a, 0x7b, 0xfe, 0x70, 0x14, 0x30,
	0xce, 0x99, 0x83, 0x32, 0x12, 0xc9, 0x1e, 0x30, 0x5b, 0x4a, 0x51, 0x56, 0x6a, 0xfd, 0x51, 0x49,
	0x99, 0xed, 0x61, 0xb9, 0xb6, 0x59, 0x70, 0xc6, 0x02, 0xfa, 0x39, 0x2c, 0x24, 0xd1, 0x51, 0x63,
	0xf2, 0xec, 0x96, 0x9d, 0x82, 0x57, 0x6f, 0xbe, 0x65, 0xf2, 0x8e, 0x3a, 0x8a, 0xa1, 0xd1, 0xe3,
	0x34, 0x21, 0xf1, 0x78, 0x33, 0x15, 0xe6, 0xed, 0x0b, 0x6d, 0x22, 0xdc, 0x0d, 0xb2, 0x43, 0xa8,
	0x03, 0xcb, 0xc5, 0x99, 0x79, 0x3a, 0x0f, 0xef, 0xe4, 0x6f, 0xf8, 0xc4, 0xd9, 0x3b, 0xf2, 0x43,
	0x9f, 0xc2, 0xd2, 0x01, 0x13, 0xc9, 0xd9, 0xc8, 0x63, 0xbd, 0x7b, 0xe1, 0x54, 0x2b, 0x9d, 0xac,
	0x5f, 0x6c, 0x84, 0xf9, 0x39, 0x82, 0xda, 0x01, 0x13, 0xd9, 0x4e, 0x38, 0x15, 0x74, 0xf3, 0x82,
	0xa6, 0x1c, 0x03, 0x3f, 0x46, 0xe0, 0xcc, 0x60, 0x49, 0xef, 0xe4, 0x4f, 0xaa, 0x30, 0x74, 0xae,
	0x16, 0x5f, 0x4f, 0x43, 0xdb, 0x21, 0xf4, 0x2b, 0xc4, 0xca, 0xb4, 0x83, 0x02, 0x56, 0x71, 0x88,
	0x5c, 0x9d, 0x68, 0xa2, 0x3c, 0xe0, 0x86, 0x46, 0x9f, 0x82, 0x9e, 0x6f, 0x0c, 0x85, 0x04, 0x4c,
	0x9a, 0x04, 0xa7, 0x43, 0x57, 0x78, 0x63, 0xeb, 0x78, 0x0b, 0xef, 0xcc, 0x48, 0x37, 0x1d, 0x72,
	0x1b, 0x79, 0xcb, 0x87, 0x7f, 0x7a, 0xec, 0xfc, 0x5b, 0x9a, 0x19, 0x2f, 0x0c, 0x8d, 0x9a, 0x50,
	0x45, 0xd0, 0xe9, 0xf1, 0xf2, 0x65, 0x90, 0x9b, 0x24, 0x0c, 0x8d, 0x7e, 0x0d, 0xf4, 0x80, 0x89,
	0x27, 0x16, 0x17, 0xd8, 0xf3, 0x7a, 0x08, 0x32, 0x5d, 0x8d, 0x4d, 0x95, 0x88, 0x63, 0xbc, 0x1d,
	0xe3, 0xe1, 0x11, 0x99, 0x1b, 0x85, 0x30, 0x0b, 0x93, 0x6e, 0xe1, 0x8e, 0xe7, 0xe7, 0x4f, 0x43,
	0xdb, 0x7d, 0xfc, 0xd7, 0xeb, 0x26, 0x79, 0xf5, 0xba, 0x49, 0xfe, 0x79, 0xdd, 0x24, 0xbf, 0xbc,
	0x69, 0x6a, 0xaf, 0xde, 0x34, 0xb5, 0xbf, 0xdf, 0x34, 0xb5, 0xe3, 0x1d, 0x9c, 0x0b, 0x86, 0xd6,
	0x73, 0x16, 0x6c, 0xf9, 0x41, 0x6f, 0x7b, 0xbc, 0xdc, 0x1e, 0x9d, 0xbc, 0xdf, 0xf3, 0xb7, 0xcf,
	0x5a, 0xea, 0x1f, 0x8a, 0x93, 0x4b, 0xf8, 0x47, 0xe1, 0x83, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff,
	0xfe, 0x71, 0x58, 0x1b, 0xc7, 0x10, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ArchiveCenterServerClient is the client API for ArchiveCenterServer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ArchiveCenterServerClient interface {
	// 注册接口
	Register(ctx context.Context, in *ArchiveBlockRequest, opts ...grpc.CallOption) (*RegisterResp, error)
	// 归档区块接口
	ArchiveBlocks(ctx context.Context, opts ...grpc.CallOption) (ArchiveCenterServer_ArchiveBlocksClient, error)
	// 归档区块接口(单向流)
	SingleArchiveBlocks(ctx context.Context, opts ...grpc.CallOption) (ArchiveCenterServer_SingleArchiveBlocksClient, error)
	// 查询归档状态
	GetArchivedStatus(ctx context.Context, in *ArchiveStatusRequest, opts ...grpc.CallOption) (*ArchiveStatusResp, error)
	// 获取当前归档中心存储信息
	GetStoreStatus(ctx context.Context, in *ArchiveStatusRequest, opts ...grpc.CallOption) (*StoreStatusResp, error)
	// 查询高度范围内区块
	GetRangeBlocks(ctx context.Context, in *RangeBlocksRequest, opts ...grpc.CallOption) (ArchiveCenterServer_GetRangeBlocksClient, error)
	// 根据blockhash查询区块
	GetBlockByHash(ctx context.Context, in *BlockByHashRequest, opts ...grpc.CallOption) (*BlockWithRWSetResp, error)
	// 根据块高查询区块
	GetBlockByHeight(ctx context.Context, in *BlockByHeightRequest, opts ...grpc.CallOption) (*BlockWithRWSetResp, error)
	// 根据txid查询区块
	GetBlockByTxId(ctx context.Context, in *BlockByTxIdRequest, opts ...grpc.CallOption) (*BlockWithRWSetResp, error)
	// 根据txid查询RWSET
	GetTxRWSetByTxId(ctx context.Context, in *BlockByTxIdRequest, opts ...grpc.CallOption) (*TxRWSetResp, error)
	// 根据txid查询transaction
	GetTxByTxId(ctx context.Context, in *BlockByTxIdRequest, opts ...grpc.CallOption) (*TransactionResp, error)
	// 查询归档中心的最新的配置区块信息
	GetLastConfigBlock(ctx context.Context, in *ArchiveStatusRequest, opts ...grpc.CallOption) (*BlockWithRWSetResp, error)
	// 根据txid查询块高，或判定tx是否存在，或查询tx的confirmtime
	GetTxDetailByTxId(ctx context.Context, in *TxDetailByIdRequest, opts ...grpc.CallOption) (*TxDetailByIdResp, error)
}

type archiveCenterServerClient struct {
	cc *grpc.ClientConn
}

func NewArchiveCenterServerClient(cc *grpc.ClientConn) ArchiveCenterServerClient {
	return &archiveCenterServerClient{cc}
}

func (c *archiveCenterServerClient) Register(ctx context.Context, in *ArchiveBlockRequest, opts ...grpc.CallOption) (*RegisterResp, error) {
	out := new(RegisterResp)
	err := c.cc.Invoke(ctx, "/archivecenter.ArchiveCenterServer/Register", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveCenterServerClient) ArchiveBlocks(ctx context.Context, opts ...grpc.CallOption) (ArchiveCenterServer_ArchiveBlocksClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ArchiveCenterServer_serviceDesc.Streams[0], "/archivecenter.ArchiveCenterServer/ArchiveBlocks", opts...)
	if err != nil {
		return nil, err
	}
	x := &archiveCenterServerArchiveBlocksClient{stream}
	return x, nil
}

type ArchiveCenterServer_ArchiveBlocksClient interface {
	Send(*ArchiveBlockRequest) error
	Recv() (*ArchiveBlockResp, error)
	grpc.ClientStream
}

type archiveCenterServerArchiveBlocksClient struct {
	grpc.ClientStream
}

func (x *archiveCenterServerArchiveBlocksClient) Send(m *ArchiveBlockRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *archiveCenterServerArchiveBlocksClient) Recv() (*ArchiveBlockResp, error) {
	m := new(ArchiveBlockResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *archiveCenterServerClient) SingleArchiveBlocks(ctx context.Context, opts ...grpc.CallOption) (ArchiveCenterServer_SingleArchiveBlocksClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ArchiveCenterServer_serviceDesc.Streams[1], "/archivecenter.ArchiveCenterServer/SingleArchiveBlocks", opts...)
	if err != nil {
		return nil, err
	}
	x := &archiveCenterServerSingleArchiveBlocksClient{stream}
	return x, nil
}

type ArchiveCenterServer_SingleArchiveBlocksClient interface {
	Send(*ArchiveBlockRequest) error
	CloseAndRecv() (*SingleArchiveBlockResp, error)
	grpc.ClientStream
}

type archiveCenterServerSingleArchiveBlocksClient struct {
	grpc.ClientStream
}

func (x *archiveCenterServerSingleArchiveBlocksClient) Send(m *ArchiveBlockRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *archiveCenterServerSingleArchiveBlocksClient) CloseAndRecv() (*SingleArchiveBlockResp, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(SingleArchiveBlockResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *archiveCenterServerClient) GetArchivedStatus(ctx context.Context, in *ArchiveStatusRequest, opts ...grpc.CallOption) (*ArchiveStatusResp, error) {
	out := new(ArchiveStatusResp)
	err := c.cc.Invoke(ctx, "/archivecenter.ArchiveCenterServer/GetArchivedStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveCenterServerClient) GetStoreStatus(ctx context.Context, in *ArchiveStatusRequest, opts ...grpc.CallOption) (*StoreStatusResp, error) {
	out := new(StoreStatusResp)
	err := c.cc.Invoke(ctx, "/archivecenter.ArchiveCenterServer/GetStoreStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveCenterServerClient) GetRangeBlocks(ctx context.Context, in *RangeBlocksRequest, opts ...grpc.CallOption) (ArchiveCenterServer_GetRangeBlocksClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ArchiveCenterServer_serviceDesc.Streams[2], "/archivecenter.ArchiveCenterServer/GetRangeBlocks", opts...)
	if err != nil {
		return nil, err
	}
	x := &archiveCenterServerGetRangeBlocksClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ArchiveCenterServer_GetRangeBlocksClient interface {
	Recv() (*common.BlockInfo, error)
	grpc.ClientStream
}

type archiveCenterServerGetRangeBlocksClient struct {
	grpc.ClientStream
}

func (x *archiveCenterServerGetRangeBlocksClient) Recv() (*common.BlockInfo, error) {
	m := new(common.BlockInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *archiveCenterServerClient) GetBlockByHash(ctx context.Context, in *BlockByHashRequest, opts ...grpc.CallOption) (*BlockWithRWSetResp, error) {
	out := new(BlockWithRWSetResp)
	err := c.cc.Invoke(ctx, "/archivecenter.ArchiveCenterServer/GetBlockByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveCenterServerClient) GetBlockByHeight(ctx context.Context, in *BlockByHeightRequest, opts ...grpc.CallOption) (*BlockWithRWSetResp, error) {
	out := new(BlockWithRWSetResp)
	err := c.cc.Invoke(ctx, "/archivecenter.ArchiveCenterServer/GetBlockByHeight", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveCenterServerClient) GetBlockByTxId(ctx context.Context, in *BlockByTxIdRequest, opts ...grpc.CallOption) (*BlockWithRWSetResp, error) {
	out := new(BlockWithRWSetResp)
	err := c.cc.Invoke(ctx, "/archivecenter.ArchiveCenterServer/GetBlockByTxId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveCenterServerClient) GetTxRWSetByTxId(ctx context.Context, in *BlockByTxIdRequest, opts ...grpc.CallOption) (*TxRWSetResp, error) {
	out := new(TxRWSetResp)
	err := c.cc.Invoke(ctx, "/archivecenter.ArchiveCenterServer/GetTxRWSetByTxId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveCenterServerClient) GetTxByTxId(ctx context.Context, in *BlockByTxIdRequest, opts ...grpc.CallOption) (*TransactionResp, error) {
	out := new(TransactionResp)
	err := c.cc.Invoke(ctx, "/archivecenter.ArchiveCenterServer/GetTxByTxId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveCenterServerClient) GetLastConfigBlock(ctx context.Context, in *ArchiveStatusRequest, opts ...grpc.CallOption) (*BlockWithRWSetResp, error) {
	out := new(BlockWithRWSetResp)
	err := c.cc.Invoke(ctx, "/archivecenter.ArchiveCenterServer/GetLastConfigBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveCenterServerClient) GetTxDetailByTxId(ctx context.Context, in *TxDetailByIdRequest, opts ...grpc.CallOption) (*TxDetailByIdResp, error) {
	out := new(TxDetailByIdResp)
	err := c.cc.Invoke(ctx, "/archivecenter.ArchiveCenterServer/GetTxDetailByTxId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ArchiveCenterServerServer is the server API for ArchiveCenterServer service.
type ArchiveCenterServerServer interface {
	// 注册接口
	Register(context.Context, *ArchiveBlockRequest) (*RegisterResp, error)
	// 归档区块接口
	ArchiveBlocks(ArchiveCenterServer_ArchiveBlocksServer) error
	// 归档区块接口(单向流)
	SingleArchiveBlocks(ArchiveCenterServer_SingleArchiveBlocksServer) error
	// 查询归档状态
	GetArchivedStatus(context.Context, *ArchiveStatusRequest) (*ArchiveStatusResp, error)
	// 获取当前归档中心存储信息
	GetStoreStatus(context.Context, *ArchiveStatusRequest) (*StoreStatusResp, error)
	// 查询高度范围内区块
	GetRangeBlocks(*RangeBlocksRequest, ArchiveCenterServer_GetRangeBlocksServer) error
	// 根据blockhash查询区块
	GetBlockByHash(context.Context, *BlockByHashRequest) (*BlockWithRWSetResp, error)
	// 根据块高查询区块
	GetBlockByHeight(context.Context, *BlockByHeightRequest) (*BlockWithRWSetResp, error)
	// 根据txid查询区块
	GetBlockByTxId(context.Context, *BlockByTxIdRequest) (*BlockWithRWSetResp, error)
	// 根据txid查询RWSET
	GetTxRWSetByTxId(context.Context, *BlockByTxIdRequest) (*TxRWSetResp, error)
	// 根据txid查询transaction
	GetTxByTxId(context.Context, *BlockByTxIdRequest) (*TransactionResp, error)
	// 查询归档中心的最新的配置区块信息
	GetLastConfigBlock(context.Context, *ArchiveStatusRequest) (*BlockWithRWSetResp, error)
	// 根据txid查询块高，或判定tx是否存在，或查询tx的confirmtime
	GetTxDetailByTxId(context.Context, *TxDetailByIdRequest) (*TxDetailByIdResp, error)
}

// UnimplementedArchiveCenterServerServer can be embedded to have forward compatible implementations.
type UnimplementedArchiveCenterServerServer struct {
}

func (*UnimplementedArchiveCenterServerServer) Register(ctx context.Context, req *ArchiveBlockRequest) (*RegisterResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (*UnimplementedArchiveCenterServerServer) ArchiveBlocks(srv ArchiveCenterServer_ArchiveBlocksServer) error {
	return status.Errorf(codes.Unimplemented, "method ArchiveBlocks not implemented")
}
func (*UnimplementedArchiveCenterServerServer) SingleArchiveBlocks(srv ArchiveCenterServer_SingleArchiveBlocksServer) error {
	return status.Errorf(codes.Unimplemented, "method SingleArchiveBlocks not implemented")
}
func (*UnimplementedArchiveCenterServerServer) GetArchivedStatus(ctx context.Context, req *ArchiveStatusRequest) (*ArchiveStatusResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetArchivedStatus not implemented")
}
func (*UnimplementedArchiveCenterServerServer) GetStoreStatus(ctx context.Context, req *ArchiveStatusRequest) (*StoreStatusResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStoreStatus not implemented")
}
func (*UnimplementedArchiveCenterServerServer) GetRangeBlocks(req *RangeBlocksRequest, srv ArchiveCenterServer_GetRangeBlocksServer) error {
	return status.Errorf(codes.Unimplemented, "method GetRangeBlocks not implemented")
}
func (*UnimplementedArchiveCenterServerServer) GetBlockByHash(ctx context.Context, req *BlockByHashRequest) (*BlockWithRWSetResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockByHash not implemented")
}
func (*UnimplementedArchiveCenterServerServer) GetBlockByHeight(ctx context.Context, req *BlockByHeightRequest) (*BlockWithRWSetResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockByHeight not implemented")
}
func (*UnimplementedArchiveCenterServerServer) GetBlockByTxId(ctx context.Context, req *BlockByTxIdRequest) (*BlockWithRWSetResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockByTxId not implemented")
}
func (*UnimplementedArchiveCenterServerServer) GetTxRWSetByTxId(ctx context.Context, req *BlockByTxIdRequest) (*TxRWSetResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTxRWSetByTxId not implemented")
}
func (*UnimplementedArchiveCenterServerServer) GetTxByTxId(ctx context.Context, req *BlockByTxIdRequest) (*TransactionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTxByTxId not implemented")
}
func (*UnimplementedArchiveCenterServerServer) GetLastConfigBlock(ctx context.Context, req *ArchiveStatusRequest) (*BlockWithRWSetResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLastConfigBlock not implemented")
}
func (*UnimplementedArchiveCenterServerServer) GetTxDetailByTxId(ctx context.Context, req *TxDetailByIdRequest) (*TxDetailByIdResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTxDetailByTxId not implemented")
}

func RegisterArchiveCenterServerServer(s *grpc.Server, srv ArchiveCenterServerServer) {
	s.RegisterService(&_ArchiveCenterServer_serviceDesc, srv)
}

func _ArchiveCenterServer_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArchiveBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveCenterServerServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archivecenter.ArchiveCenterServer/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveCenterServerServer).Register(ctx, req.(*ArchiveBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArchiveCenterServer_ArchiveBlocks_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ArchiveCenterServerServer).ArchiveBlocks(&archiveCenterServerArchiveBlocksServer{stream})
}

type ArchiveCenterServer_ArchiveBlocksServer interface {
	Send(*ArchiveBlockResp) error
	Recv() (*ArchiveBlockRequest, error)
	grpc.ServerStream
}

type archiveCenterServerArchiveBlocksServer struct {
	grpc.ServerStream
}

func (x *archiveCenterServerArchiveBlocksServer) Send(m *ArchiveBlockResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *archiveCenterServerArchiveBlocksServer) Recv() (*ArchiveBlockRequest, error) {
	m := new(ArchiveBlockRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ArchiveCenterServer_SingleArchiveBlocks_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ArchiveCenterServerServer).SingleArchiveBlocks(&archiveCenterServerSingleArchiveBlocksServer{stream})
}

type ArchiveCenterServer_SingleArchiveBlocksServer interface {
	SendAndClose(*SingleArchiveBlockResp) error
	Recv() (*ArchiveBlockRequest, error)
	grpc.ServerStream
}

type archiveCenterServerSingleArchiveBlocksServer struct {
	grpc.ServerStream
}

func (x *archiveCenterServerSingleArchiveBlocksServer) SendAndClose(m *SingleArchiveBlockResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *archiveCenterServerSingleArchiveBlocksServer) Recv() (*ArchiveBlockRequest, error) {
	m := new(ArchiveBlockRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ArchiveCenterServer_GetArchivedStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArchiveStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveCenterServerServer).GetArchivedStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archivecenter.ArchiveCenterServer/GetArchivedStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveCenterServerServer).GetArchivedStatus(ctx, req.(*ArchiveStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArchiveCenterServer_GetStoreStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArchiveStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveCenterServerServer).GetStoreStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archivecenter.ArchiveCenterServer/GetStoreStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveCenterServerServer).GetStoreStatus(ctx, req.(*ArchiveStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArchiveCenterServer_GetRangeBlocks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RangeBlocksRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ArchiveCenterServerServer).GetRangeBlocks(m, &archiveCenterServerGetRangeBlocksServer{stream})
}

type ArchiveCenterServer_GetRangeBlocksServer interface {
	Send(*common.BlockInfo) error
	grpc.ServerStream
}

type archiveCenterServerGetRangeBlocksServer struct {
	grpc.ServerStream
}

func (x *archiveCenterServerGetRangeBlocksServer) Send(m *common.BlockInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _ArchiveCenterServer_GetBlockByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveCenterServerServer).GetBlockByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archivecenter.ArchiveCenterServer/GetBlockByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveCenterServerServer).GetBlockByHash(ctx, req.(*BlockByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArchiveCenterServer_GetBlockByHeight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockByHeightRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveCenterServerServer).GetBlockByHeight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archivecenter.ArchiveCenterServer/GetBlockByHeight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveCenterServerServer).GetBlockByHeight(ctx, req.(*BlockByHeightRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArchiveCenterServer_GetBlockByTxId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockByTxIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveCenterServerServer).GetBlockByTxId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archivecenter.ArchiveCenterServer/GetBlockByTxId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveCenterServerServer).GetBlockByTxId(ctx, req.(*BlockByTxIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArchiveCenterServer_GetTxRWSetByTxId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockByTxIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveCenterServerServer).GetTxRWSetByTxId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archivecenter.ArchiveCenterServer/GetTxRWSetByTxId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveCenterServerServer).GetTxRWSetByTxId(ctx, req.(*BlockByTxIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArchiveCenterServer_GetTxByTxId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockByTxIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveCenterServerServer).GetTxByTxId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archivecenter.ArchiveCenterServer/GetTxByTxId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveCenterServerServer).GetTxByTxId(ctx, req.(*BlockByTxIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArchiveCenterServer_GetLastConfigBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArchiveStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveCenterServerServer).GetLastConfigBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archivecenter.ArchiveCenterServer/GetLastConfigBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveCenterServerServer).GetLastConfigBlock(ctx, req.(*ArchiveStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArchiveCenterServer_GetTxDetailByTxId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxDetailByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveCenterServerServer).GetTxDetailByTxId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archivecenter.ArchiveCenterServer/GetTxDetailByTxId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveCenterServerServer).GetTxDetailByTxId(ctx, req.(*TxDetailByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ArchiveCenterServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "archivecenter.ArchiveCenterServer",
	HandlerType: (*ArchiveCenterServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _ArchiveCenterServer_Register_Handler,
		},
		{
			MethodName: "GetArchivedStatus",
			Handler:    _ArchiveCenterServer_GetArchivedStatus_Handler,
		},
		{
			MethodName: "GetStoreStatus",
			Handler:    _ArchiveCenterServer_GetStoreStatus_Handler,
		},
		{
			MethodName: "GetBlockByHash",
			Handler:    _ArchiveCenterServer_GetBlockByHash_Handler,
		},
		{
			MethodName: "GetBlockByHeight",
			Handler:    _ArchiveCenterServer_GetBlockByHeight_Handler,
		},
		{
			MethodName: "GetBlockByTxId",
			Handler:    _ArchiveCenterServer_GetBlockByTxId_Handler,
		},
		{
			MethodName: "GetTxRWSetByTxId",
			Handler:    _ArchiveCenterServer_GetTxRWSetByTxId_Handler,
		},
		{
			MethodName: "GetTxByTxId",
			Handler:    _ArchiveCenterServer_GetTxByTxId_Handler,
		},
		{
			MethodName: "GetLastConfigBlock",
			Handler:    _ArchiveCenterServer_GetLastConfigBlock_Handler,
		},
		{
			MethodName: "GetTxDetailByTxId",
			Handler:    _ArchiveCenterServer_GetTxDetailByTxId_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ArchiveBlocks",
			Handler:       _ArchiveCenterServer_ArchiveBlocks_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SingleArchiveBlocks",
			Handler:       _ArchiveCenterServer_SingleArchiveBlocks_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetRangeBlocks",
			Handler:       _ArchiveCenterServer_GetRangeBlocks_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "archivecenter/archivecenter.proto",
}

func (m *RegisterResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintArchivecenter(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.RegisterStatus != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.RegisterStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArchiveBlockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArchiveBlockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArchiveBlockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintArchivecenter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainUnique) > 0 {
		i -= len(m.ChainUnique)
		copy(dAtA[i:], m.ChainUnique)
		i = encodeVarintArchivecenter(dAtA, i, uint64(len(m.ChainUnique)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SingleArchiveBlockResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SingleArchiveBlockResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SingleArchiveBlockResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintArchivecenter(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x22
	}
	if m.Code != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if m.ArchivedEndHeight != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.ArchivedEndHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.ArchivedBeginHeight != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.ArchivedBeginHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArchiveBlockResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArchiveBlockResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArchiveBlockResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintArchivecenter(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.ArchiveStatus != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.ArchiveStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArchiveStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArchiveStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArchiveStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainUnique) > 0 {
		i -= len(m.ChainUnique)
		copy(dAtA[i:], m.ChainUnique)
		i = encodeVarintArchivecenter(dAtA, i, uint64(len(m.ChainUnique)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ArchiveStatusResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArchiveStatusResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArchiveStatusResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintArchivecenter(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x22
	}
	if m.Code != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if m.InArchive {
		i--
		if m.InArchive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.ArchivedHeight != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.ArchivedHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RangeBlocksRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeBlocksRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeBlocksRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndHeight != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.EndHeight))
		i--
		dAtA[i] = 0x18
	}
	if m.StartHeight != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.StartHeight))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ChainUnique) > 0 {
		i -= len(m.ChainUnique)
		copy(dAtA[i:], m.ChainUnique)
		i = encodeVarintArchivecenter(dAtA, i, uint64(len(m.ChainUnique)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockByHashRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockByHashRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockByHashRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operation != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.Operation))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BlockHash) > 0 {
		i -= len(m.BlockHash)
		copy(dAtA[i:], m.BlockHash)
		i = encodeVarintArchivecenter(dAtA, i, uint64(len(m.BlockHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainUnique) > 0 {
		i -= len(m.ChainUnique)
		copy(dAtA[i:], m.ChainUnique)
		i = encodeVarintArchivecenter(dAtA, i, uint64(len(m.ChainUnique)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockByHeightRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockByHeightRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockByHeightRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operation != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.Operation))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ChainUnique) > 0 {
		i -= len(m.ChainUnique)
		copy(dAtA[i:], m.ChainUnique)
		i = encodeVarintArchivecenter(dAtA, i, uint64(len(m.ChainUnique)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockByTxIdRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockByTxIdRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockByTxIdRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxId) > 0 {
		i -= len(m.TxId)
		copy(dAtA[i:], m.TxId)
		i = encodeVarintArchivecenter(dAtA, i, uint64(len(m.TxId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainUnique) > 0 {
		i -= len(m.ChainUnique)
		copy(dAtA[i:], m.ChainUnique)
		i = encodeVarintArchivecenter(dAtA, i, uint64(len(m.ChainUnique)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxDetailByIdRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxDetailByIdRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxDetailByIdRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operation != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.Operation))
		i--
		dAtA[i] = 0x18
	}
	if len(m.TxId) > 0 {
		i -= len(m.TxId)
		copy(dAtA[i:], m.TxId)
		i = encodeVarintArchivecenter(dAtA, i, uint64(len(m.TxId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainUnique) > 0 {
		i -= len(m.ChainUnique)
		copy(dAtA[i:], m.ChainUnique)
		i = encodeVarintArchivecenter(dAtA, i, uint64(len(m.ChainUnique)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxDetailByIdResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxDetailByIdResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxDetailByIdResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintArchivecenter(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Code != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x20
	}
	if m.TxConfirmedTime != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.TxConfirmedTime))
		i--
		dAtA[i] = 0x18
	}
	if m.TxExist {
		i--
		if m.TxExist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Height != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockWithRWSetResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockWithRWSetResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockWithRWSetResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintArchivecenter(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.BlockData != nil {
		{
			size, err := m.BlockData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintArchivecenter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxRWSetResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxRWSetResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxRWSetResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintArchivecenter(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.RwSet != nil {
		{
			size, err := m.RwSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintArchivecenter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransactionResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintArchivecenter(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Transaction != nil {
		{
			size, err := m.Transaction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintArchivecenter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StoreStatusResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreStatusResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreStatusResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintArchivecenter(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.StoreStatus != nil {
		{
			size, err := m.StoreStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintArchivecenter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StoreStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Size_ != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x18
	}
	if len(m.StoreInfos) > 0 {
		for iNdEx := len(m.StoreInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StoreInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArchivecenter(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ChainUnique) > 0 {
		i -= len(m.ChainUnique)
		copy(dAtA[i:], m.ChainUnique)
		i = encodeVarintArchivecenter(dAtA, i, uint64(len(m.ChainUnique)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StoreInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Size_ != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x18
	}
	if len(m.FileInfos) > 0 {
		for iNdEx := len(m.FileInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FileInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArchivecenter(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Type != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Size_ != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x20
	}
	if m.End != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x18
	}
	if m.Start != 0 {
		i = encodeVarintArchivecenter(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintArchivecenter(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintArchivecenter(dAtA []byte, offset int, v uint64) int {
	offset -= sovArchivecenter(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RegisterResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RegisterStatus != 0 {
		n += 1 + sovArchivecenter(uint64(m.RegisterStatus))
	}
	if m.Code != 0 {
		n += 1 + sovArchivecenter(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovArchivecenter(uint64(l))
	}
	return n
}

func (m *ArchiveBlockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainUnique)
	if l > 0 {
		n += 1 + l + sovArchivecenter(uint64(l))
	}
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovArchivecenter(uint64(l))
	}
	return n
}

func (m *SingleArchiveBlockResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ArchivedBeginHeight != 0 {
		n += 1 + sovArchivecenter(uint64(m.ArchivedBeginHeight))
	}
	if m.ArchivedEndHeight != 0 {
		n += 1 + sovArchivecenter(uint64(m.ArchivedEndHeight))
	}
	if m.Code != 0 {
		n += 1 + sovArchivecenter(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovArchivecenter(uint64(l))
	}
	return n
}

func (m *ArchiveBlockResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ArchiveStatus != 0 {
		n += 1 + sovArchivecenter(uint64(m.ArchiveStatus))
	}
	if m.Code != 0 {
		n += 1 + sovArchivecenter(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovArchivecenter(uint64(l))
	}
	return n
}

func (m *ArchiveStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainUnique)
	if l > 0 {
		n += 1 + l + sovArchivecenter(uint64(l))
	}
	return n
}

func (m *ArchiveStatusResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ArchivedHeight != 0 {
		n += 1 + sovArchivecenter(uint64(m.ArchivedHeight))
	}
	if m.InArchive {
		n += 2
	}
	if m.Code != 0 {
		n += 1 + sovArchivecenter(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovArchivecenter(uint64(l))
	}
	return n
}

func (m *RangeBlocksRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainUnique)
	if l > 0 {
		n += 1 + l + sovArchivecenter(uint64(l))
	}
	if m.StartHeight != 0 {
		n += 1 + sovArchivecenter(uint64(m.StartHeight))
	}
	if m.EndHeight != 0 {
		n += 1 + sovArchivecenter(uint64(m.EndHeight))
	}
	return n
}

func (m *BlockByHashRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainUnique)
	if l > 0 {
		n += 1 + l + sovArchivecenter(uint64(l))
	}
	l = len(m.BlockHash)
	if l > 0 {
		n += 1 + l + sovArchivecenter(uint64(l))
	}
	if m.Operation != 0 {
		n += 1 + sovArchivecenter(uint64(m.Operation))
	}
	return n
}

func (m *BlockByHeightRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainUnique)
	if l > 0 {
		n += 1 + l + sovArchivecenter(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovArchivecenter(uint64(m.Height))
	}
	if m.Operation != 0 {
		n += 1 + sovArchivecenter(uint64(m.Operation))
	}
	return n
}

func (m *BlockByTxIdRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainUnique)
	if l > 0 {
		n += 1 + l + sovArchivecenter(uint64(l))
	}
	l = len(m.TxId)
	if l > 0 {
		n += 1 + l + sovArchivecenter(uint64(l))
	}
	return n
}

func (m *TxDetailByIdRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainUnique)
	if l > 0 {
		n += 1 + l + sovArchivecenter(uint64(l))
	}
	l = len(m.TxId)
	if l > 0 {
		n += 1 + l + sovArchivecenter(uint64(l))
	}
	if m.Operation != 0 {
		n += 1 + sovArchivecenter(uint64(m.Operation))
	}
	return n
}

func (m *TxDetailByIdResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovArchivecenter(uint64(m.Height))
	}
	if m.TxExist {
		n += 2
	}
	if m.TxConfirmedTime != 0 {
		n += 1 + sovArchivecenter(uint64(m.TxConfirmedTime))
	}
	if m.Code != 0 {
		n += 1 + sovArchivecenter(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovArchivecenter(uint64(l))
	}
	return n
}

func (m *BlockWithRWSetResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockData != nil {
		l = m.BlockData.Size()
		n += 1 + l + sovArchivecenter(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovArchivecenter(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovArchivecenter(uint64(l))
	}
	return n
}

func (m *TxRWSetResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RwSet != nil {
		l = m.RwSet.Size()
		n += 1 + l + sovArchivecenter(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovArchivecenter(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovArchivecenter(uint64(l))
	}
	return n
}

func (m *TransactionResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Transaction != nil {
		l = m.Transaction.Size()
		n += 1 + l + sovArchivecenter(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovArchivecenter(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovArchivecenter(uint64(l))
	}
	return n
}

func (m *StoreStatusResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StoreStatus != nil {
		l = m.StoreStatus.Size()
		n += 1 + l + sovArchivecenter(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovArchivecenter(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovArchivecenter(uint64(l))
	}
	return n
}

func (m *StoreStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainUnique)
	if l > 0 {
		n += 1 + l + sovArchivecenter(uint64(l))
	}
	if len(m.StoreInfos) > 0 {
		for _, e := range m.StoreInfos {
			l = e.Size()
			n += 1 + l + sovArchivecenter(uint64(l))
		}
	}
	if m.Size_ != 0 {
		n += 1 + sovArchivecenter(uint64(m.Size_))
	}
	return n
}

func (m *StoreInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovArchivecenter(uint64(m.Type))
	}
	if len(m.FileInfos) > 0 {
		for _, e := range m.FileInfos {
			l = e.Size()
			n += 1 + l + sovArchivecenter(uint64(l))
		}
	}
	if m.Size_ != 0 {
		n += 1 + sovArchivecenter(uint64(m.Size_))
	}
	return n
}

func (m *FileInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovArchivecenter(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovArchivecenter(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovArchivecenter(uint64(m.End))
	}
	if m.Size_ != 0 {
		n += 1 + sovArchivecenter(uint64(m.Size_))
	}
	return n
}

func sovArchivecenter(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozArchivecenter(x uint64) (n int) {
	return sovArchivecenter(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RegisterResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchivecenter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisterStatus", wireType)
			}
			m.RegisterStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegisterStatus |= RegisterStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArchivecenter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArchiveBlockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchivecenter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArchiveBlockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArchiveBlockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainUnique", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainUnique = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &common.BlockInfo{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArchivecenter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SingleArchiveBlockResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchivecenter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleArchiveBlockResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleArchiveBlockResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArchivedBeginHeight", wireType)
			}
			m.ArchivedBeginHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArchivedBeginHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArchivedEndHeight", wireType)
			}
			m.ArchivedEndHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArchivedEndHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArchivecenter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArchiveBlockResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchivecenter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArchiveBlockResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArchiveBlockResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArchiveStatus", wireType)
			}
			m.ArchiveStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArchiveStatus |= ArchiveStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArchivecenter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArchiveStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchivecenter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArchiveStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArchiveStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainUnique", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainUnique = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArchivecenter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArchiveStatusResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchivecenter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArchiveStatusResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArchiveStatusResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArchivedHeight", wireType)
			}
			m.ArchivedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArchivedHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InArchive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InArchive = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArchivecenter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeBlocksRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchivecenter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeBlocksRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeBlocksRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainUnique", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainUnique = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartHeight", wireType)
			}
			m.StartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndHeight", wireType)
			}
			m.EndHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArchivecenter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockByHashRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchivecenter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockByHashRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockByHashRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainUnique", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainUnique = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operation |= OperationByHash(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArchivecenter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockByHeightRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchivecenter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockByHeightRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockByHeightRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainUnique", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainUnique = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operation |= OperationByHeight(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArchivecenter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockByTxIdRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchivecenter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockByTxIdRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockByTxIdRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainUnique", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainUnique = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArchivecenter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxDetailByIdRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchivecenter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxDetailByIdRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxDetailByIdRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainUnique", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainUnique = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operation |= OperationByTxId(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArchivecenter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxDetailByIdResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchivecenter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxDetailByIdResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxDetailByIdResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxExist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TxExist = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxConfirmedTime", wireType)
			}
			m.TxConfirmedTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxConfirmedTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArchivecenter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockWithRWSetResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchivecenter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockWithRWSetResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockWithRWSetResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockData == nil {
				m.BlockData = &common.BlockInfo{}
			}
			if err := m.BlockData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArchivecenter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxRWSetResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchivecenter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxRWSetResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxRWSetResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RwSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RwSet == nil {
				m.RwSet = &common.TxRWSet{}
			}
			if err := m.RwSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArchivecenter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchivecenter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transaction == nil {
				m.Transaction = &common.Transaction{}
			}
			if err := m.Transaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArchivecenter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreStatusResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchivecenter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreStatusResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreStatusResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StoreStatus == nil {
				m.StoreStatus = &StoreStatus{}
			}
			if err := m.StoreStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArchivecenter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchivecenter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainUnique", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainUnique = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreInfos = append(m.StoreInfos, &StoreInfo{})
			if err := m.StoreInfos[len(m.StoreInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArchivecenter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchivecenter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= StoreDataType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileInfos = append(m.FileInfos, &FileInfo{})
			if err := m.FileInfos[len(m.FileInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArchivecenter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchivecenter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchivecenter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArchivecenter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchivecenter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipArchivecenter(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowArchivecenter
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowArchivecenter
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthArchivecenter
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupArchivecenter
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthArchivecenter
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthArchivecenter        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowArchivecenter          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupArchivecenter = fmt.Errorf("proto: unexpected end of group")
)
