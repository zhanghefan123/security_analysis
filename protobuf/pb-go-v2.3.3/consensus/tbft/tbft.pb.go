// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: consensus/tbft/tbft.proto

package tbft

import (
	common "zhanghefan123/security/protobuf/pb-go/common"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TBFTMsgType defines different type message in tbft
type TBFTMsgType int32

const (
	TBFTMsgType_MSG_PROPOSE       TBFTMsgType = 0
	TBFTMsgType_MSG_PREVOTE       TBFTMsgType = 1
	TBFTMsgType_MSG_PRECOMMIT     TBFTMsgType = 2
	TBFTMsgType_MSG_STATE         TBFTMsgType = 3
	TBFTMsgType_MSG_FETCH_ROUNDQC TBFTMsgType = 4
	TBFTMsgType_MSG_SEND_ROUND_QC TBFTMsgType = 5
)

var TBFTMsgType_name = map[int32]string{
	0: "MSG_PROPOSE",
	1: "MSG_PREVOTE",
	2: "MSG_PRECOMMIT",
	3: "MSG_STATE",
	4: "MSG_FETCH_ROUNDQC",
	5: "MSG_SEND_ROUND_QC",
}

var TBFTMsgType_value = map[string]int32{
	"MSG_PROPOSE":       0,
	"MSG_PREVOTE":       1,
	"MSG_PRECOMMIT":     2,
	"MSG_STATE":         3,
	"MSG_FETCH_ROUNDQC": 4,
	"MSG_SEND_ROUND_QC": 5,
}

func (x TBFTMsgType) String() string {
	return proto.EnumName(TBFTMsgType_name, int32(x))
}

func (TBFTMsgType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{0}
}

// VoteType represents the type of vote
type VoteType int32

const (
	VoteType_VOTE_PREVOTE   VoteType = 0
	VoteType_VOTE_PRECOMMIT VoteType = 1
)

var VoteType_name = map[int32]string{
	0: "VOTE_PREVOTE",
	1: "VOTE_PRECOMMIT",
}

var VoteType_value = map[string]int32{
	"VOTE_PREVOTE":   0,
	"VOTE_PRECOMMIT": 1,
}

func (x VoteType) String() string {
	return proto.EnumName(VoteType_name, int32(x))
}

func (VoteType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{1}
}

// Step represents the step in a round
type Step int32

const (
	Step_NEW_HEIGHT     Step = 0
	Step_NEW_ROUND      Step = 1
	Step_PROPOSE        Step = 2
	Step_PREVOTE        Step = 3
	Step_PREVOTE_WAIT   Step = 4
	Step_PRECOMMIT      Step = 5
	Step_PRECOMMIT_WAIT Step = 6
	Step_COMMIT         Step = 7
)

var Step_name = map[int32]string{
	0: "NEW_HEIGHT",
	1: "NEW_ROUND",
	2: "PROPOSE",
	3: "PREVOTE",
	4: "PREVOTE_WAIT",
	5: "PRECOMMIT",
	6: "PRECOMMIT_WAIT",
	7: "COMMIT",
}

var Step_value = map[string]int32{
	"NEW_HEIGHT":     0,
	"NEW_ROUND":      1,
	"PROPOSE":        2,
	"PREVOTE":        3,
	"PREVOTE_WAIT":   4,
	"PRECOMMIT":      5,
	"PRECOMMIT_WAIT": 6,
	"COMMIT":         7,
}

func (x Step) String() string {
	return proto.EnumName(Step_name, int32(x))
}

func (Step) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{2}
}

// WalEntryType represents different types of entries in Wal
type WalEntryType int32

const (
	WalEntryType_TIMEOUT_ENTRY       WalEntryType = 0
	WalEntryType_PROPOSAL_ENTRY      WalEntryType = 1
	WalEntryType_VOTE_ENTRY          WalEntryType = 2
	WalEntryType_PROPOSAL_VOTE_ENTRY WalEntryType = 3
)

var WalEntryType_name = map[int32]string{
	0: "TIMEOUT_ENTRY",
	1: "PROPOSAL_ENTRY",
	2: "VOTE_ENTRY",
	3: "PROPOSAL_VOTE_ENTRY",
}

var WalEntryType_value = map[string]int32{
	"TIMEOUT_ENTRY":       0,
	"PROPOSAL_ENTRY":      1,
	"VOTE_ENTRY":          2,
	"PROPOSAL_VOTE_ENTRY": 3,
}

func (x WalEntryType) String() string {
	return proto.EnumName(WalEntryType_name, int32(x))
}

func (WalEntryType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{3}
}

// ValidatorSet represents the set of validators
type ValidatorSet struct {
	Validators []string `protobuf:"bytes,1,rep,name=validators,proto3" json:"validators,omitempty"`
}

func (m *ValidatorSet) Reset()         { *m = ValidatorSet{} }
func (m *ValidatorSet) String() string { return proto.CompactTextString(m) }
func (*ValidatorSet) ProtoMessage()    {}
func (*ValidatorSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{0}
}
func (m *ValidatorSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorSet.Merge(m, src)
}
func (m *ValidatorSet) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorSet) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorSet.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorSet proto.InternalMessageInfo

func (m *ValidatorSet) GetValidators() []string {
	if m != nil {
		return m.Validators
	}
	return nil
}

type TBFTMsg struct {
	Type TBFTMsgType `protobuf:"varint,1,opt,name=type,proto3,enum=tbft.TBFTMsgType" json:"type,omitempty"`
	Msg  []byte      `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *TBFTMsg) Reset()         { *m = TBFTMsg{} }
func (m *TBFTMsg) String() string { return proto.CompactTextString(m) }
func (*TBFTMsg) ProtoMessage()    {}
func (*TBFTMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{1}
}
func (m *TBFTMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TBFTMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TBFTMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TBFTMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TBFTMsg.Merge(m, src)
}
func (m *TBFTMsg) XXX_Size() int {
	return m.Size()
}
func (m *TBFTMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_TBFTMsg.DiscardUnknown(m)
}

var xxx_messageInfo_TBFTMsg proto.InternalMessageInfo

func (m *TBFTMsg) GetType() TBFTMsgType {
	if m != nil {
		return m.Type
	}
	return TBFTMsgType_MSG_PROPOSE
}

func (m *TBFTMsg) GetMsg() []byte {
	if m != nil {
		return m.Msg
	}
	return nil
}

// Proposal defined a consesensus proposal which can
// be gossiped to other node and can be serilized
// for persistent store.
type Proposal struct {
	Voter       string                     `protobuf:"bytes,1,opt,name=voter,proto3" json:"voter,omitempty"`
	Height      uint64                     `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	Round       int32                      `protobuf:"varint,3,opt,name=round,proto3" json:"round,omitempty"`
	PolRound    int32                      `protobuf:"varint,4,opt,name=pol_round,json=polRound,proto3" json:"pol_round,omitempty"`
	Block       *common.Block              `protobuf:"bytes,5,opt,name=block,proto3" json:"block,omitempty"`
	Endorsement *common.EndorsementEntry   `protobuf:"bytes,6,opt,name=endorsement,proto3" json:"endorsement,omitempty"`
	TxsRwSet    map[string]*common.TxRWSet `protobuf:"bytes,7,rep,name=txs_rw_set,json=txsRwSet,proto3" json:"txs_rw_set,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Qc          []*Vote                    `protobuf:"bytes,8,rep,name=qc,proto3" json:"qc,omitempty"`
}

func (m *Proposal) Reset()         { *m = Proposal{} }
func (m *Proposal) String() string { return proto.CompactTextString(m) }
func (*Proposal) ProtoMessage()    {}
func (*Proposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{2}
}
func (m *Proposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proposal.Merge(m, src)
}
func (m *Proposal) XXX_Size() int {
	return m.Size()
}
func (m *Proposal) XXX_DiscardUnknown() {
	xxx_messageInfo_Proposal.DiscardUnknown(m)
}

var xxx_messageInfo_Proposal proto.InternalMessageInfo

func (m *Proposal) GetVoter() string {
	if m != nil {
		return m.Voter
	}
	return ""
}

func (m *Proposal) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Proposal) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *Proposal) GetPolRound() int32 {
	if m != nil {
		return m.PolRound
	}
	return 0
}

func (m *Proposal) GetBlock() *common.Block {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *Proposal) GetEndorsement() *common.EndorsementEntry {
	if m != nil {
		return m.Endorsement
	}
	return nil
}

func (m *Proposal) GetTxsRwSet() map[string]*common.TxRWSet {
	if m != nil {
		return m.TxsRwSet
	}
	return nil
}

func (m *Proposal) GetQc() []*Vote {
	if m != nil {
		return m.Qc
	}
	return nil
}

// Vote represents a tbft vote
type Vote struct {
	Type        VoteType                 `protobuf:"varint,1,opt,name=type,proto3,enum=tbft.VoteType" json:"type,omitempty"`
	Voter       string                   `protobuf:"bytes,2,opt,name=voter,proto3" json:"voter,omitempty"`
	Height      uint64                   `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
	Round       int32                    `protobuf:"varint,4,opt,name=round,proto3" json:"round,omitempty"`
	Hash        []byte                   `protobuf:"bytes,5,opt,name=hash,proto3" json:"hash,omitempty"`
	Endorsement *common.EndorsementEntry `protobuf:"bytes,6,opt,name=endorsement,proto3" json:"endorsement,omitempty"`
	InvalidTxs  []string                 `protobuf:"bytes,7,rep,name=invalidTxs,proto3" json:"invalidTxs,omitempty"`
}

func (m *Vote) Reset()         { *m = Vote{} }
func (m *Vote) String() string { return proto.CompactTextString(m) }
func (*Vote) ProtoMessage()    {}
func (*Vote) Descriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{3}
}
func (m *Vote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vote.Merge(m, src)
}
func (m *Vote) XXX_Size() int {
	return m.Size()
}
func (m *Vote) XXX_DiscardUnknown() {
	xxx_messageInfo_Vote.DiscardUnknown(m)
}

var xxx_messageInfo_Vote proto.InternalMessageInfo

func (m *Vote) GetType() VoteType {
	if m != nil {
		return m.Type
	}
	return VoteType_VOTE_PREVOTE
}

func (m *Vote) GetVoter() string {
	if m != nil {
		return m.Voter
	}
	return ""
}

func (m *Vote) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Vote) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *Vote) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *Vote) GetEndorsement() *common.EndorsementEntry {
	if m != nil {
		return m.Endorsement
	}
	return nil
}

func (m *Vote) GetInvalidTxs() []string {
	if m != nil {
		return m.InvalidTxs
	}
	return nil
}

// BlockVotes represents votes as key-value form
type BlockVotes struct {
	Votes map[string]*Vote `protobuf:"bytes,1,rep,name=votes,proto3" json:"votes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Sum   uint64           `protobuf:"varint,2,opt,name=sum,proto3" json:"sum,omitempty"`
}

func (m *BlockVotes) Reset()         { *m = BlockVotes{} }
func (m *BlockVotes) String() string { return proto.CompactTextString(m) }
func (*BlockVotes) ProtoMessage()    {}
func (*BlockVotes) Descriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{4}
}
func (m *BlockVotes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockVotes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockVotes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockVotes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockVotes.Merge(m, src)
}
func (m *BlockVotes) XXX_Size() int {
	return m.Size()
}
func (m *BlockVotes) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockVotes.DiscardUnknown(m)
}

var xxx_messageInfo_BlockVotes proto.InternalMessageInfo

func (m *BlockVotes) GetVotes() map[string]*Vote {
	if m != nil {
		return m.Votes
	}
	return nil
}

func (m *BlockVotes) GetSum() uint64 {
	if m != nil {
		return m.Sum
	}
	return 0
}

// VoteSet represents a set of vote at `height` and `round`
type VoteSet struct {
	Type         VoteType               `protobuf:"varint,1,opt,name=type,proto3,enum=tbft.VoteType" json:"type,omitempty"`
	Height       uint64                 `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	Round        int32                  `protobuf:"varint,3,opt,name=round,proto3" json:"round,omitempty"`
	Sum          uint64                 `protobuf:"varint,4,opt,name=sum,proto3" json:"sum,omitempty"`
	Maj23        []byte                 `protobuf:"bytes,5,opt,name=maj23,proto3" json:"maj23,omitempty"`
	Votes        map[string]*Vote       `protobuf:"bytes,6,rep,name=votes,proto3" json:"votes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	VotesByBlock map[string]*BlockVotes `protobuf:"bytes,7,rep,name=votes_by_block,json=votesByBlock,proto3" json:"votes_by_block,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *VoteSet) Reset()         { *m = VoteSet{} }
func (m *VoteSet) String() string { return proto.CompactTextString(m) }
func (*VoteSet) ProtoMessage()    {}
func (*VoteSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{5}
}
func (m *VoteSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VoteSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VoteSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VoteSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VoteSet.Merge(m, src)
}
func (m *VoteSet) XXX_Size() int {
	return m.Size()
}
func (m *VoteSet) XXX_DiscardUnknown() {
	xxx_messageInfo_VoteSet.DiscardUnknown(m)
}

var xxx_messageInfo_VoteSet proto.InternalMessageInfo

func (m *VoteSet) GetType() VoteType {
	if m != nil {
		return m.Type
	}
	return VoteType_VOTE_PREVOTE
}

func (m *VoteSet) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *VoteSet) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *VoteSet) GetSum() uint64 {
	if m != nil {
		return m.Sum
	}
	return 0
}

func (m *VoteSet) GetMaj23() []byte {
	if m != nil {
		return m.Maj23
	}
	return nil
}

func (m *VoteSet) GetVotes() map[string]*Vote {
	if m != nil {
		return m.Votes
	}
	return nil
}

func (m *VoteSet) GetVotesByBlock() map[string]*BlockVotes {
	if m != nil {
		return m.VotesByBlock
	}
	return nil
}

// RoundVoteSet represents voteSet of a `round`
type RoundVoteSet struct {
	Height     uint64   `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	Round      int32    `protobuf:"varint,2,opt,name=round,proto3" json:"round,omitempty"`
	Prevotes   *VoteSet `protobuf:"bytes,3,opt,name=prevotes,proto3" json:"prevotes,omitempty"`
	Precommits *VoteSet `protobuf:"bytes,4,opt,name=precommits,proto3" json:"precommits,omitempty"`
}

func (m *RoundVoteSet) Reset()         { *m = RoundVoteSet{} }
func (m *RoundVoteSet) String() string { return proto.CompactTextString(m) }
func (*RoundVoteSet) ProtoMessage()    {}
func (*RoundVoteSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{6}
}
func (m *RoundVoteSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoundVoteSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoundVoteSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoundVoteSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoundVoteSet.Merge(m, src)
}
func (m *RoundVoteSet) XXX_Size() int {
	return m.Size()
}
func (m *RoundVoteSet) XXX_DiscardUnknown() {
	xxx_messageInfo_RoundVoteSet.DiscardUnknown(m)
}

var xxx_messageInfo_RoundVoteSet proto.InternalMessageInfo

func (m *RoundVoteSet) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *RoundVoteSet) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *RoundVoteSet) GetPrevotes() *VoteSet {
	if m != nil {
		return m.Prevotes
	}
	return nil
}

func (m *RoundVoteSet) GetPrecommits() *VoteSet {
	if m != nil {
		return m.Precommits
	}
	return nil
}

// HeightRoundVoteSet represents voteSet of a `height`
type HeightRoundVoteSet struct {
	Height        uint64                  `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	Round         int32                   `protobuf:"varint,2,opt,name=round,proto3" json:"round,omitempty"`
	RoundVoteSets map[int32]*RoundVoteSet `protobuf:"bytes,3,rep,name=round_vote_sets,json=roundVoteSets,proto3" json:"round_vote_sets,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *HeightRoundVoteSet) Reset()         { *m = HeightRoundVoteSet{} }
func (m *HeightRoundVoteSet) String() string { return proto.CompactTextString(m) }
func (*HeightRoundVoteSet) ProtoMessage()    {}
func (*HeightRoundVoteSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{7}
}
func (m *HeightRoundVoteSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeightRoundVoteSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeightRoundVoteSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeightRoundVoteSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeightRoundVoteSet.Merge(m, src)
}
func (m *HeightRoundVoteSet) XXX_Size() int {
	return m.Size()
}
func (m *HeightRoundVoteSet) XXX_DiscardUnknown() {
	xxx_messageInfo_HeightRoundVoteSet.DiscardUnknown(m)
}

var xxx_messageInfo_HeightRoundVoteSet proto.InternalMessageInfo

func (m *HeightRoundVoteSet) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *HeightRoundVoteSet) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *HeightRoundVoteSet) GetRoundVoteSets() map[int32]*RoundVoteSet {
	if m != nil {
		return m.RoundVoteSets
	}
	return nil
}

// ConsensusState represents the state of tbft instance
type ConsensusState struct {
	Id                 string              `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Height             uint64              `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	Round              int32               `protobuf:"varint,3,opt,name=round,proto3" json:"round,omitempty"`
	Step               Step                `protobuf:"varint,4,opt,name=step,proto3,enum=tbft.Step" json:"step,omitempty"`
	Proposal           *Proposal           `protobuf:"bytes,5,opt,name=proposal,proto3" json:"proposal,omitempty"`
	VerifingProposal   *Proposal           `protobuf:"bytes,6,opt,name=verifing_proposal,json=verifingProposal,proto3" json:"verifing_proposal,omitempty"`
	LockedProposal     *Proposal           `protobuf:"bytes,7,opt,name=locked_proposal,json=lockedProposal,proto3" json:"locked_proposal,omitempty"`
	ValidProposal      *Proposal           `protobuf:"bytes,8,opt,name=valid_proposal,json=validProposal,proto3" json:"valid_proposal,omitempty"`
	HeightRoundVoteSet *HeightRoundVoteSet `protobuf:"bytes,9,opt,name=height_round_vote_set,json=heightRoundVoteSet,proto3" json:"height_round_vote_set,omitempty"`
}

func (m *ConsensusState) Reset()         { *m = ConsensusState{} }
func (m *ConsensusState) String() string { return proto.CompactTextString(m) }
func (*ConsensusState) ProtoMessage()    {}
func (*ConsensusState) Descriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{8}
}
func (m *ConsensusState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusState.Merge(m, src)
}
func (m *ConsensusState) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusState) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusState.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusState proto.InternalMessageInfo

func (m *ConsensusState) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ConsensusState) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *ConsensusState) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *ConsensusState) GetStep() Step {
	if m != nil {
		return m.Step
	}
	return Step_NEW_HEIGHT
}

func (m *ConsensusState) GetProposal() *Proposal {
	if m != nil {
		return m.Proposal
	}
	return nil
}

func (m *ConsensusState) GetVerifingProposal() *Proposal {
	if m != nil {
		return m.VerifingProposal
	}
	return nil
}

func (m *ConsensusState) GetLockedProposal() *Proposal {
	if m != nil {
		return m.LockedProposal
	}
	return nil
}

func (m *ConsensusState) GetValidProposal() *Proposal {
	if m != nil {
		return m.ValidProposal
	}
	return nil
}

func (m *ConsensusState) GetHeightRoundVoteSet() *HeightRoundVoteSet {
	if m != nil {
		return m.HeightRoundVoteSet
	}
	return nil
}

// FetchRoundQC defined a fetch roundQC request which can
// be gossiped to other node
type FetchRoundQC struct {
	Id     string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Height uint64 `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	Round  int32  `protobuf:"varint,3,opt,name=round,proto3" json:"round,omitempty"`
}

func (m *FetchRoundQC) Reset()         { *m = FetchRoundQC{} }
func (m *FetchRoundQC) String() string { return proto.CompactTextString(m) }
func (*FetchRoundQC) ProtoMessage()    {}
func (*FetchRoundQC) Descriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{9}
}
func (m *FetchRoundQC) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchRoundQC) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchRoundQC.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchRoundQC) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchRoundQC.Merge(m, src)
}
func (m *FetchRoundQC) XXX_Size() int {
	return m.Size()
}
func (m *FetchRoundQC) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchRoundQC.DiscardUnknown(m)
}

var xxx_messageInfo_FetchRoundQC proto.InternalMessageInfo

func (m *FetchRoundQC) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *FetchRoundQC) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *FetchRoundQC) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

// RoundQC represents the max round of qc
type RoundQC struct {
	Id     string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Height uint64   `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	Round  int32    `protobuf:"varint,3,opt,name=round,proto3" json:"round,omitempty"`
	Qc     *VoteSet `protobuf:"bytes,4,opt,name=qc,proto3" json:"qc,omitempty"`
}

func (m *RoundQC) Reset()         { *m = RoundQC{} }
func (m *RoundQC) String() string { return proto.CompactTextString(m) }
func (*RoundQC) ProtoMessage()    {}
func (*RoundQC) Descriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{10}
}
func (m *RoundQC) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoundQC) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoundQC.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoundQC) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoundQC.Merge(m, src)
}
func (m *RoundQC) XXX_Size() int {
	return m.Size()
}
func (m *RoundQC) XXX_DiscardUnknown() {
	xxx_messageInfo_RoundQC.DiscardUnknown(m)
}

var xxx_messageInfo_RoundQC proto.InternalMessageInfo

func (m *RoundQC) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *RoundQC) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *RoundQC) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *RoundQC) GetQc() *VoteSet {
	if m != nil {
		return m.Qc
	}
	return nil
}

// GossipState represents the state of tbft instance
type GossipState struct {
	Id               string        `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Height           uint64        `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	Round            int32         `protobuf:"varint,3,opt,name=round,proto3" json:"round,omitempty"`
	Step             Step          `protobuf:"varint,4,opt,name=step,proto3,enum=tbft.Step" json:"step,omitempty"`
	Proposal         []byte        `protobuf:"bytes,5,opt,name=proposal,proto3" json:"proposal,omitempty"`
	VerifingProposal []byte        `protobuf:"bytes,6,opt,name=verifing_proposal,json=verifingProposal,proto3" json:"verifing_proposal,omitempty"`
	RoundVoteSet     *RoundVoteSet `protobuf:"bytes,7,opt,name=round_vote_set,json=roundVoteSet,proto3" json:"round_vote_set,omitempty"`
}

func (m *GossipState) Reset()         { *m = GossipState{} }
func (m *GossipState) String() string { return proto.CompactTextString(m) }
func (*GossipState) ProtoMessage()    {}
func (*GossipState) Descriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{11}
}
func (m *GossipState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GossipState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GossipState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GossipState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GossipState.Merge(m, src)
}
func (m *GossipState) XXX_Size() int {
	return m.Size()
}
func (m *GossipState) XXX_DiscardUnknown() {
	xxx_messageInfo_GossipState.DiscardUnknown(m)
}

var xxx_messageInfo_GossipState proto.InternalMessageInfo

func (m *GossipState) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *GossipState) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *GossipState) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *GossipState) GetStep() Step {
	if m != nil {
		return m.Step
	}
	return Step_NEW_HEIGHT
}

func (m *GossipState) GetProposal() []byte {
	if m != nil {
		return m.Proposal
	}
	return nil
}

func (m *GossipState) GetVerifingProposal() []byte {
	if m != nil {
		return m.VerifingProposal
	}
	return nil
}

func (m *GossipState) GetRoundVoteSet() *RoundVoteSet {
	if m != nil {
		return m.RoundVoteSet
	}
	return nil
}

// TimeoutInfo represents the timeout event
type TimeoutInfo struct {
	Duration int64  `protobuf:"varint,1,opt,name=duration,proto3" json:"duration,omitempty"`
	Height   uint64 `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	Round    int32  `protobuf:"varint,3,opt,name=round,proto3" json:"round,omitempty"`
	Step     Step   `protobuf:"varint,4,opt,name=step,proto3,enum=tbft.Step" json:"step,omitempty"`
}

func (m *TimeoutInfo) Reset()         { *m = TimeoutInfo{} }
func (m *TimeoutInfo) String() string { return proto.CompactTextString(m) }
func (*TimeoutInfo) ProtoMessage()    {}
func (*TimeoutInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{12}
}
func (m *TimeoutInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimeoutInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimeoutInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimeoutInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeoutInfo.Merge(m, src)
}
func (m *TimeoutInfo) XXX_Size() int {
	return m.Size()
}
func (m *TimeoutInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeoutInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TimeoutInfo proto.InternalMessageInfo

func (m *TimeoutInfo) GetDuration() int64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *TimeoutInfo) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *TimeoutInfo) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *TimeoutInfo) GetStep() Step {
	if m != nil {
		return m.Step
	}
	return Step_NEW_HEIGHT
}

// WalEntry represents the log entry in Wal
type WalEntry struct {
	Height uint64 `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	// log entry type
	Type WalEntryType `protobuf:"varint,2,opt,name=type,proto3,enum=tbft.WalEntryType" json:"type,omitempty"`
	// data of entry
	Data []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *WalEntry) Reset()         { *m = WalEntry{} }
func (m *WalEntry) String() string { return proto.CompactTextString(m) }
func (*WalEntry) ProtoMessage()    {}
func (*WalEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{13}
}
func (m *WalEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WalEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WalEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WalEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WalEntry.Merge(m, src)
}
func (m *WalEntry) XXX_Size() int {
	return m.Size()
}
func (m *WalEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_WalEntry.DiscardUnknown(m)
}

var xxx_messageInfo_WalEntry proto.InternalMessageInfo

func (m *WalEntry) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *WalEntry) GetType() WalEntryType {
	if m != nil {
		return m.Type
	}
	return WalEntryType_TIMEOUT_ENTRY
}

func (m *WalEntry) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterEnum("tbft.TBFTMsgType", TBFTMsgType_name, TBFTMsgType_value)
	proto.RegisterEnum("tbft.VoteType", VoteType_name, VoteType_value)
	proto.RegisterEnum("tbft.Step", Step_name, Step_value)
	proto.RegisterEnum("tbft.WalEntryType", WalEntryType_name, WalEntryType_value)
	proto.RegisterType((*ValidatorSet)(nil), "tbft.ValidatorSet")
	proto.RegisterType((*TBFTMsg)(nil), "tbft.TBFTMsg")
	proto.RegisterType((*Proposal)(nil), "tbft.Proposal")
	proto.RegisterMapType((map[string]*common.TxRWSet)(nil), "tbft.Proposal.TxsRwSetEntry")
	proto.RegisterType((*Vote)(nil), "tbft.Vote")
	proto.RegisterType((*BlockVotes)(nil), "tbft.BlockVotes")
	proto.RegisterMapType((map[string]*Vote)(nil), "tbft.BlockVotes.VotesEntry")
	proto.RegisterType((*VoteSet)(nil), "tbft.VoteSet")
	proto.RegisterMapType((map[string]*BlockVotes)(nil), "tbft.VoteSet.VotesByBlockEntry")
	proto.RegisterMapType((map[string]*Vote)(nil), "tbft.VoteSet.VotesEntry")
	proto.RegisterType((*RoundVoteSet)(nil), "tbft.RoundVoteSet")
	proto.RegisterType((*HeightRoundVoteSet)(nil), "tbft.HeightRoundVoteSet")
	proto.RegisterMapType((map[int32]*RoundVoteSet)(nil), "tbft.HeightRoundVoteSet.RoundVoteSetsEntry")
	proto.RegisterType((*ConsensusState)(nil), "tbft.ConsensusState")
	proto.RegisterType((*FetchRoundQC)(nil), "tbft.FetchRoundQC")
	proto.RegisterType((*RoundQC)(nil), "tbft.RoundQC")
	proto.RegisterType((*GossipState)(nil), "tbft.GossipState")
	proto.RegisterType((*TimeoutInfo)(nil), "tbft.TimeoutInfo")
	proto.RegisterType((*WalEntry)(nil), "tbft.WalEntry")
}

func init() { proto.RegisterFile("consensus/tbft/tbft.proto", fileDescriptor_3dacd5877ec4420d) }

var fileDescriptor_3dacd5877ec4420d = []byte{
	// 1239 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x36, 0x29, 0xea, 0xc7, 0x23, 0x99, 0xa6, 0xb7, 0x49, 0xab, 0x2a, 0xad, 0x2a, 0xb0, 0x48,
	0xa0, 0x3a, 0x88, 0xdc, 0x28, 0x28, 0x1a, 0xa4, 0xa7, 0xd8, 0x61, 0x62, 0xa3, 0xb1, 0x1d, 0xaf,
	0x98, 0x18, 0xed, 0x21, 0x04, 0x2d, 0xad, 0x25, 0x36, 0x12, 0x49, 0x93, 0x2b, 0xff, 0x9c, 0xda,
	0x47, 0x28, 0xd0, 0xa2, 0x7d, 0xa5, 0x1e, 0x73, 0xec, 0xa9, 0x28, 0x92, 0x73, 0x7b, 0xe8, 0x13,
	0x14, 0xbb, 0x4b, 0x52, 0xab, 0x98, 0x06, 0x1a, 0xc4, 0xe8, 0x45, 0xd8, 0xf9, 0xdb, 0x99, 0xfd,
	0xbe, 0xd9, 0x59, 0x11, 0x3e, 0xec, 0x07, 0x7e, 0x4c, 0xfc, 0x78, 0x1a, 0xaf, 0xd1, 0x83, 0x43,
	0xca, 0x7f, 0x3a, 0x61, 0x14, 0xd0, 0x00, 0x69, 0x6c, 0xdd, 0x40, 0xfd, 0x60, 0x32, 0x09, 0xfc,
	0xb5, 0x83, 0x71, 0xd0, 0x7f, 0x21, 0x2c, 0x8d, 0x2b, 0x89, 0x2e, 0x22, 0x47, 0x53, 0x12, 0x27,
	0xfe, 0x99, 0x67, 0x74, 0x12, 0x93, 0x44, 0x67, 0x76, 0xa0, 0xf6, 0xcc, 0x1d, 0x7b, 0x03, 0x97,
	0x06, 0x51, 0x8f, 0x50, 0xd4, 0x04, 0x38, 0x4e, 0xe5, 0xb8, 0xae, 0xb4, 0x0a, 0xed, 0x45, 0x2c,
	0x69, 0xcc, 0x75, 0x28, 0xdb, 0xeb, 0x0f, 0xed, 0xed, 0x78, 0x88, 0xae, 0x83, 0x46, 0xcf, 0x42,
	0x52, 0x57, 0x5a, 0x4a, 0x5b, 0xef, 0xae, 0x74, 0x78, 0x65, 0x89, 0xd1, 0x3e, 0x0b, 0x09, 0xe6,
	0x66, 0x64, 0x40, 0x61, 0x12, 0x0f, 0xeb, 0x6a, 0x4b, 0x69, 0xd7, 0x30, 0x5b, 0x9a, 0xff, 0xa8,
	0x50, 0x79, 0x12, 0x05, 0x61, 0x10, 0xbb, 0x63, 0x74, 0x05, 0x8a, 0xc7, 0x01, 0x25, 0x11, 0xdf,
	0x66, 0x11, 0x0b, 0x01, 0xbd, 0x0f, 0xa5, 0x11, 0xf1, 0x86, 0x23, 0xca, 0xe3, 0x34, 0x9c, 0x48,
	0xcc, 0x3b, 0x0a, 0xa6, 0xfe, 0xa0, 0x5e, 0x68, 0x29, 0xed, 0x22, 0x16, 0x02, 0xba, 0x06, 0x8b,
	0x61, 0x30, 0x76, 0x84, 0x45, 0xe3, 0x96, 0x4a, 0x18, 0x8c, 0x31, 0x37, 0x7e, 0x0a, 0x45, 0x0e,
	0x4d, 0xbd, 0xd8, 0x52, 0xda, 0xd5, 0xee, 0x52, 0x47, 0xa0, 0xd0, 0x59, 0x67, 0x4a, 0x2c, 0x6c,
	0xe8, 0x1e, 0x54, 0x89, 0x3f, 0x08, 0xa2, 0x98, 0x4c, 0x88, 0x4f, 0xeb, 0x25, 0xee, 0x5a, 0x4f,
	0x5d, 0xad, 0x99, 0xc9, 0xf2, 0x69, 0x74, 0x86, 0x65, 0x67, 0x74, 0x0f, 0x80, 0x9e, 0xc6, 0x4e,
	0x74, 0xe2, 0xc4, 0x84, 0xd6, 0xcb, 0xad, 0x42, 0xbb, 0xda, 0xfd, 0x48, 0xa0, 0x91, 0x9e, 0xb2,
	0x63, 0x9f, 0xc6, 0xf8, 0xa4, 0x47, 0x92, 0xf0, 0x0a, 0x4d, 0x44, 0xd4, 0x00, 0xf5, 0xa8, 0x5f,
	0xaf, 0xf0, 0x18, 0x10, 0x31, 0xcf, 0x02, 0x4a, 0xb0, 0x7a, 0xd4, 0x6f, 0x3c, 0x86, 0xa5, 0xb9,
	0x30, 0x86, 0xe4, 0x0b, 0x72, 0x96, 0x00, 0xc5, 0x96, 0xe8, 0x3a, 0x14, 0x8f, 0xdd, 0xf1, 0x94,
	0x70, 0x94, 0xaa, 0xdd, 0xe5, 0xb4, 0x60, 0xfb, 0x14, 0xef, 0xf7, 0x08, 0xc5, 0xc2, 0x7a, 0x4f,
	0xbd, 0xab, 0x98, 0x7f, 0x28, 0xa0, 0xb1, 0xad, 0x91, 0x39, 0x47, 0x9b, 0x3e, 0x4b, 0x2a, 0x71,
	0x96, 0x91, 0xa2, 0xe6, 0x93, 0x52, 0xc8, 0x27, 0x45, 0x93, 0x49, 0x41, 0xa0, 0x8d, 0xdc, 0x78,
	0xc4, 0x61, 0xaf, 0x61, 0xbe, 0x7e, 0x27, 0x98, 0x9b, 0x00, 0x9e, 0xcf, 0x3b, 0xd1, 0x3e, 0x8d,
	0x39, 0xcc, 0x8b, 0x58, 0xd2, 0x98, 0xbf, 0x2a, 0x00, 0x9c, 0x53, 0x76, 0x96, 0x18, 0xdd, 0x16,
	0x47, 0x10, 0x3d, 0x5c, 0xed, 0x5e, 0x13, 0xe7, 0x9c, 0x39, 0xf0, 0x23, 0xc7, 0x22, 0x8f, 0xf0,
	0x64, 0xf8, 0xc6, 0xd3, 0x49, 0xd2, 0x71, 0x6c, 0xd9, 0x78, 0x00, 0x30, 0x73, 0xcb, 0xc1, 0xbf,
	0x35, 0x8f, 0xbf, 0xcc, 0xa0, 0x04, 0xfd, 0x4f, 0x05, 0x28, 0x33, 0x1d, 0x23, 0xfc, 0xbf, 0xa0,
	0xff, 0x76, 0xcd, 0x9f, 0x54, 0xad, 0x65, 0x55, 0x33, 0xbf, 0x89, 0xfb, 0x5d, 0xf7, 0x4e, 0x02,
	0xbd, 0x10, 0x50, 0x27, 0x05, 0xa4, 0xc4, 0x01, 0xa9, 0xcf, 0x52, 0xf7, 0x08, 0xcd, 0x41, 0xc3,
	0x02, 0x9d, 0x2f, 0x9c, 0x83, 0x33, 0x47, 0x5c, 0x20, 0xd1, 0xda, 0x9f, 0xe4, 0x04, 0xae, 0x9f,
	0x71, 0x60, 0x45, 0x7c, 0xed, 0x58, 0x52, 0x5d, 0x0e, 0x84, 0x8d, 0x3d, 0x58, 0x39, 0x97, 0x28,
	0x67, 0xb3, 0x1b, 0xf3, 0x9b, 0x19, 0x6f, 0x92, 0x2e, 0xb3, 0xf2, 0x8b, 0x02, 0x35, 0x3e, 0x21,
	0x52, 0x6a, 0x66, 0xb0, 0x2b, 0xf9, 0xb0, 0xab, 0x32, 0xec, 0x9f, 0x41, 0x25, 0x8c, 0x88, 0x40,
	0xb4, 0x90, 0x4c, 0x16, 0x19, 0x18, 0x9c, 0x99, 0xd1, 0x2d, 0x80, 0x30, 0x22, 0xac, 0xc9, 0x3d,
	0x1a, 0x73, 0xa2, 0xce, 0x39, 0x4b, 0x0e, 0xe6, 0x5f, 0x0a, 0xa0, 0x4d, 0x9e, 0xfa, 0x1d, 0xca,
	0xeb, 0xc1, 0x32, 0x5f, 0x38, 0xac, 0x04, 0x36, 0x98, 0x58, 0x95, 0x8c, 0xbe, 0x9b, 0x22, 0xf1,
	0xf9, 0x04, 0x1d, 0x59, 0x48, 0x5a, 0x61, 0x29, 0x92, 0x75, 0x0d, 0x1b, 0xd0, 0x79, 0x27, 0x99,
	0x86, 0xa2, 0xa0, 0xa1, 0x3d, 0x4f, 0x03, 0x12, 0x29, 0xe5, 0x50, 0x99, 0x88, 0x9f, 0x0b, 0xa0,
	0x6f, 0xa4, 0x8f, 0x5c, 0x8f, 0xba, 0x94, 0x20, 0x1d, 0x54, 0x6f, 0x90, 0x10, 0xab, 0x7a, 0x83,
	0xb7, 0xbc, 0x11, 0x4d, 0xd0, 0x62, 0x4a, 0x42, 0x8e, 0xb4, 0x9e, 0x76, 0x54, 0x8f, 0x92, 0x10,
	0x73, 0x3d, 0x5a, 0x65, 0xd4, 0x89, 0xc1, 0x9c, 0x3c, 0x0a, 0xfa, 0xfc, 0xb8, 0xc6, 0x99, 0x1d,
	0x7d, 0x05, 0x2b, 0xc7, 0x24, 0xf2, 0x0e, 0x3d, 0x7f, 0xe8, 0x64, 0x41, 0xa5, 0xdc, 0x20, 0x23,
	0x75, 0xcc, 0xde, 0xb6, 0x2f, 0x61, 0x99, 0xb5, 0x1e, 0x19, 0xcc, 0x42, 0xcb, 0xb9, 0xa1, 0xba,
	0x70, 0xcb, 0x02, 0xbf, 0x00, 0x9d, 0xcf, 0xb5, 0x59, 0x5c, 0x25, 0x37, 0x6e, 0x89, 0x7b, 0x65,
	0x61, 0x5f, 0xc3, 0x55, 0x01, 0x8c, 0x33, 0xcf, 0x7d, 0x7d, 0x31, 0x19, 0xb4, 0x17, 0x50, 0x8f,
	0xd1, 0xe8, 0x9c, 0xce, 0x7c, 0x0c, 0xb5, 0x87, 0x84, 0xf6, 0x47, 0x5c, 0xb9, 0xb7, 0xf1, 0x6e,
	0x9c, 0x98, 0x87, 0x50, 0xbe, 0x94, 0x8d, 0xd0, 0xc7, 0xfc, 0xc5, 0xcc, 0xbd, 0x44, 0xea, 0x51,
	0xdf, 0xfc, 0x5b, 0x81, 0xea, 0xa3, 0x20, 0x8e, 0xbd, 0xf0, 0xff, 0xe8, 0xa4, 0xc6, 0x1b, 0x9d,
	0x54, 0x93, 0x3a, 0xe7, 0xe6, 0x45, 0x9d, 0x53, 0xcb, 0xe9, 0x94, 0xbb, 0xa0, 0xbf, 0x41, 0x59,
	0xf9, 0xc2, 0xab, 0x53, 0x93, 0x2f, 0xa5, 0x79, 0x02, 0x55, 0xdb, 0x9b, 0x90, 0x60, 0x4a, 0xb7,
	0xfc, 0xc3, 0x80, 0x55, 0x34, 0x98, 0x46, 0x2e, 0xf5, 0x02, 0x9f, 0x9f, 0xba, 0x80, 0x33, 0xf9,
	0x72, 0xcf, 0x6e, 0x3e, 0x87, 0xca, 0xbe, 0x3b, 0x16, 0x23, 0xe0, 0xa2, 0xd9, 0x74, 0x23, 0x79,
	0xed, 0x54, 0xbe, 0x47, 0x72, 0x98, 0x34, 0x4a, 0x7a, 0xf1, 0x10, 0x68, 0x03, 0x97, 0xba, 0xbc,
	0x80, 0x1a, 0xe6, 0xeb, 0xd5, 0xef, 0xa1, 0x2a, 0xfd, 0x99, 0x44, 0xcb, 0x50, 0xdd, 0xee, 0x3d,
	0x72, 0x9e, 0xe0, 0xdd, 0x27, 0xbb, 0x3d, 0xcb, 0x58, 0x98, 0x29, 0xac, 0x67, 0xbb, 0xb6, 0x65,
	0x28, 0x68, 0x05, 0x96, 0x12, 0xc5, 0xc6, 0xee, 0xf6, 0xf6, 0x96, 0x6d, 0xa8, 0x68, 0x09, 0x16,
	0x99, 0xaa, 0x67, 0xdf, 0xb7, 0x2d, 0xa3, 0x80, 0xae, 0xc2, 0x0a, 0x13, 0x1f, 0x5a, 0xf6, 0xc6,
	0xa6, 0x83, 0x77, 0x9f, 0xee, 0x3c, 0xd8, 0xdb, 0x30, 0xb4, 0x54, 0xdd, 0xb3, 0x76, 0x1e, 0x08,
	0xad, 0xb3, 0xb7, 0x61, 0x14, 0x57, 0x3f, 0x87, 0x4a, 0xfa, 0x30, 0x23, 0x03, 0x6a, 0x2c, 0x4b,
	0x96, 0x6d, 0x01, 0x21, 0xd0, 0x53, 0x4d, 0x92, 0x4e, 0x59, 0xfd, 0x41, 0x01, 0x8d, 0x21, 0x84,
	0x74, 0x80, 0x1d, 0x6b, 0xdf, 0xd9, 0xb4, 0xb6, 0x1e, 0x6d, 0xda, 0xc6, 0x02, 0xab, 0x83, 0xc9,
	0x7c, 0x73, 0x43, 0x41, 0x55, 0x28, 0xa7, 0xe7, 0x50, 0x85, 0x20, 0x76, 0x2d, 0xb0, 0x3c, 0x89,
	0xe0, 0xec, 0xdf, 0xdf, 0xb2, 0x0d, 0x8d, 0x85, 0xce, 0x52, 0x14, 0x59, 0xda, 0x4c, 0x14, 0x2e,
	0x25, 0x04, 0x50, 0x4a, 0xec, 0xe5, 0xd5, 0xe7, 0x50, 0x93, 0xf1, 0x65, 0xa0, 0xd8, 0x5b, 0xdb,
	0xd6, 0xee, 0x53, 0xdb, 0xb1, 0x76, 0x6c, 0xfc, 0x8d, 0xa8, 0x5c, 0x64, 0xbf, 0xff, 0x38, 0xd1,
	0x29, 0xac, 0x60, 0x9e, 0x54, 0xc8, 0x2a, 0xfa, 0x00, 0xde, 0xcb, 0x7c, 0x24, 0x43, 0x61, 0x7d,
	0xf2, 0xdb, 0xab, 0xa6, 0xf2, 0xf2, 0x55, 0x53, 0xf9, 0xf3, 0x55, 0x53, 0xf9, 0xf1, 0x75, 0x73,
	0xe1, 0xe5, 0xeb, 0xe6, 0xc2, 0xef, 0xaf, 0x9b, 0x0b, 0xd0, 0x0a, 0xa2, 0x61, 0xa7, 0x3f, 0x72,
	0x3d, 0x7f, 0xe2, 0xbe, 0x20, 0x51, 0x27, 0x3c, 0xe8, 0x64, 0x9f, 0x2e, 0x9c, 0xf8, 0x6f, 0x6f,
	0x4b, 0xd6, 0x20, 0x1a, 0xae, 0xcd, 0xc4, 0xb5, 0xf0, 0xe0, 0xd6, 0x30, 0x58, 0x3b, 0xee, 0xae,
	0xcd, 0x7f, 0xed, 0x1c, 0x94, 0xf8, 0x57, 0xca, 0x9d, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x38,
	0x4a, 0xe2, 0x4c, 0x06, 0x0d, 0x00, 0x00,
}

func (m *ValidatorSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Validators) > 0 {
		for iNdEx := len(m.Validators) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Validators[iNdEx])
			copy(dAtA[i:], m.Validators[iNdEx])
			i = encodeVarintTbft(dAtA, i, uint64(len(m.Validators[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TBFTMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TBFTMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TBFTMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintTbft(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Proposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Proposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Qc) > 0 {
		for iNdEx := len(m.Qc) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Qc[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTbft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.TxsRwSet) > 0 {
		for k := range m.TxsRwSet {
			v := m.TxsRwSet[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTbft(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTbft(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTbft(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Endorsement != nil {
		{
			size, err := m.Endorsement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.PolRound != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.PolRound))
		i--
		dAtA[i] = 0x20
	}
	if m.Round != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Voter) > 0 {
		i -= len(m.Voter)
		copy(dAtA[i:], m.Voter)
		i = encodeVarintTbft(dAtA, i, uint64(len(m.Voter)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Vote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InvalidTxs) > 0 {
		for iNdEx := len(m.InvalidTxs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.InvalidTxs[iNdEx])
			copy(dAtA[i:], m.InvalidTxs[iNdEx])
			i = encodeVarintTbft(dAtA, i, uint64(len(m.InvalidTxs[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Endorsement != nil {
		{
			size, err := m.Endorsement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintTbft(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Round != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x20
	}
	if m.Height != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Voter) > 0 {
		i -= len(m.Voter)
		copy(dAtA[i:], m.Voter)
		i = encodeVarintTbft(dAtA, i, uint64(len(m.Voter)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockVotes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockVotes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockVotes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sum != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Sum))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Votes) > 0 {
		for k := range m.Votes {
			v := m.Votes[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTbft(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTbft(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTbft(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *VoteSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VoteSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VoteSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VotesByBlock) > 0 {
		for k := range m.VotesByBlock {
			v := m.VotesByBlock[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTbft(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTbft(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTbft(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Votes) > 0 {
		for k := range m.Votes {
			v := m.Votes[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTbft(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTbft(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTbft(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Maj23) > 0 {
		i -= len(m.Maj23)
		copy(dAtA[i:], m.Maj23)
		i = encodeVarintTbft(dAtA, i, uint64(len(m.Maj23)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Sum != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Sum))
		i--
		dAtA[i] = 0x20
	}
	if m.Round != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoundVoteSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoundVoteSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoundVoteSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Precommits != nil {
		{
			size, err := m.Precommits.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Prevotes != nil {
		{
			size, err := m.Prevotes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Round != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x10
	}
	if m.Height != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HeightRoundVoteSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeightRoundVoteSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeightRoundVoteSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RoundVoteSets) > 0 {
		for k := range m.RoundVoteSets {
			v := m.RoundVoteSets[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTbft(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintTbft(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintTbft(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Round != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x10
	}
	if m.Height != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HeightRoundVoteSet != nil {
		{
			size, err := m.HeightRoundVoteSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.ValidProposal != nil {
		{
			size, err := m.ValidProposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.LockedProposal != nil {
		{
			size, err := m.LockedProposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.VerifingProposal != nil {
		{
			size, err := m.VerifingProposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Proposal != nil {
		{
			size, err := m.Proposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Step != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Step))
		i--
		dAtA[i] = 0x20
	}
	if m.Round != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTbft(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FetchRoundQC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchRoundQC) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchRoundQC) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Round != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTbft(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RoundQC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoundQC) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoundQC) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Qc != nil {
		{
			size, err := m.Qc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Round != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTbft(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GossipState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GossipState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GossipState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RoundVoteSet != nil {
		{
			size, err := m.RoundVoteSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.VerifingProposal) > 0 {
		i -= len(m.VerifingProposal)
		copy(dAtA[i:], m.VerifingProposal)
		i = encodeVarintTbft(dAtA, i, uint64(len(m.VerifingProposal)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Proposal) > 0 {
		i -= len(m.Proposal)
		copy(dAtA[i:], m.Proposal)
		i = encodeVarintTbft(dAtA, i, uint64(len(m.Proposal)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Step != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Step))
		i--
		dAtA[i] = 0x20
	}
	if m.Round != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTbft(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TimeoutInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeoutInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimeoutInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Step != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Step))
		i--
		dAtA[i] = 0x20
	}
	if m.Round != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.Duration != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Duration))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WalEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WalEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WalEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTbft(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Height != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTbft(dAtA []byte, offset int, v uint64) int {
	offset -= sovTbft(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ValidatorSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Validators) > 0 {
		for _, s := range m.Validators {
			l = len(s)
			n += 1 + l + sovTbft(uint64(l))
		}
	}
	return n
}

func (m *TBFTMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTbft(uint64(m.Type))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovTbft(uint64(l))
	}
	return n
}

func (m *Proposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Voter)
	if l > 0 {
		n += 1 + l + sovTbft(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovTbft(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovTbft(uint64(m.Round))
	}
	if m.PolRound != 0 {
		n += 1 + sovTbft(uint64(m.PolRound))
	}
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovTbft(uint64(l))
	}
	if m.Endorsement != nil {
		l = m.Endorsement.Size()
		n += 1 + l + sovTbft(uint64(l))
	}
	if len(m.TxsRwSet) > 0 {
		for k, v := range m.TxsRwSet {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTbft(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTbft(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTbft(uint64(mapEntrySize))
		}
	}
	if len(m.Qc) > 0 {
		for _, e := range m.Qc {
			l = e.Size()
			n += 1 + l + sovTbft(uint64(l))
		}
	}
	return n
}

func (m *Vote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTbft(uint64(m.Type))
	}
	l = len(m.Voter)
	if l > 0 {
		n += 1 + l + sovTbft(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovTbft(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovTbft(uint64(m.Round))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovTbft(uint64(l))
	}
	if m.Endorsement != nil {
		l = m.Endorsement.Size()
		n += 1 + l + sovTbft(uint64(l))
	}
	if len(m.InvalidTxs) > 0 {
		for _, s := range m.InvalidTxs {
			l = len(s)
			n += 1 + l + sovTbft(uint64(l))
		}
	}
	return n
}

func (m *BlockVotes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Votes) > 0 {
		for k, v := range m.Votes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTbft(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTbft(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTbft(uint64(mapEntrySize))
		}
	}
	if m.Sum != 0 {
		n += 1 + sovTbft(uint64(m.Sum))
	}
	return n
}

func (m *VoteSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTbft(uint64(m.Type))
	}
	if m.Height != 0 {
		n += 1 + sovTbft(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovTbft(uint64(m.Round))
	}
	if m.Sum != 0 {
		n += 1 + sovTbft(uint64(m.Sum))
	}
	l = len(m.Maj23)
	if l > 0 {
		n += 1 + l + sovTbft(uint64(l))
	}
	if len(m.Votes) > 0 {
		for k, v := range m.Votes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTbft(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTbft(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTbft(uint64(mapEntrySize))
		}
	}
	if len(m.VotesByBlock) > 0 {
		for k, v := range m.VotesByBlock {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTbft(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTbft(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTbft(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RoundVoteSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovTbft(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovTbft(uint64(m.Round))
	}
	if m.Prevotes != nil {
		l = m.Prevotes.Size()
		n += 1 + l + sovTbft(uint64(l))
	}
	if m.Precommits != nil {
		l = m.Precommits.Size()
		n += 1 + l + sovTbft(uint64(l))
	}
	return n
}

func (m *HeightRoundVoteSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovTbft(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovTbft(uint64(m.Round))
	}
	if len(m.RoundVoteSets) > 0 {
		for k, v := range m.RoundVoteSets {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTbft(uint64(l))
			}
			mapEntrySize := 1 + sovTbft(uint64(k)) + l
			n += mapEntrySize + 1 + sovTbft(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ConsensusState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTbft(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovTbft(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovTbft(uint64(m.Round))
	}
	if m.Step != 0 {
		n += 1 + sovTbft(uint64(m.Step))
	}
	if m.Proposal != nil {
		l = m.Proposal.Size()
		n += 1 + l + sovTbft(uint64(l))
	}
	if m.VerifingProposal != nil {
		l = m.VerifingProposal.Size()
		n += 1 + l + sovTbft(uint64(l))
	}
	if m.LockedProposal != nil {
		l = m.LockedProposal.Size()
		n += 1 + l + sovTbft(uint64(l))
	}
	if m.ValidProposal != nil {
		l = m.ValidProposal.Size()
		n += 1 + l + sovTbft(uint64(l))
	}
	if m.HeightRoundVoteSet != nil {
		l = m.HeightRoundVoteSet.Size()
		n += 1 + l + sovTbft(uint64(l))
	}
	return n
}

func (m *FetchRoundQC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTbft(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovTbft(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovTbft(uint64(m.Round))
	}
	return n
}

func (m *RoundQC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTbft(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovTbft(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovTbft(uint64(m.Round))
	}
	if m.Qc != nil {
		l = m.Qc.Size()
		n += 1 + l + sovTbft(uint64(l))
	}
	return n
}

func (m *GossipState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTbft(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovTbft(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovTbft(uint64(m.Round))
	}
	if m.Step != 0 {
		n += 1 + sovTbft(uint64(m.Step))
	}
	l = len(m.Proposal)
	if l > 0 {
		n += 1 + l + sovTbft(uint64(l))
	}
	l = len(m.VerifingProposal)
	if l > 0 {
		n += 1 + l + sovTbft(uint64(l))
	}
	if m.RoundVoteSet != nil {
		l = m.RoundVoteSet.Size()
		n += 1 + l + sovTbft(uint64(l))
	}
	return n
}

func (m *TimeoutInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Duration != 0 {
		n += 1 + sovTbft(uint64(m.Duration))
	}
	if m.Height != 0 {
		n += 1 + sovTbft(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovTbft(uint64(m.Round))
	}
	if m.Step != 0 {
		n += 1 + sovTbft(uint64(m.Step))
	}
	return n
}

func (m *WalEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovTbft(uint64(m.Height))
	}
	if m.Type != 0 {
		n += 1 + sovTbft(uint64(m.Type))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTbft(uint64(l))
	}
	return n
}

func sovTbft(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTbft(x uint64) (n int) {
	return sovTbft(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ValidatorSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validators", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validators = append(m.Validators, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TBFTMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TBFTMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TBFTMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= TBFTMsgType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = append(m.Msg[:0], dAtA[iNdEx:postIndex]...)
			if m.Msg == nil {
				m.Msg = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Voter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolRound", wireType)
			}
			m.PolRound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PolRound |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &common.Block{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endorsement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endorsement == nil {
				m.Endorsement = &common.EndorsementEntry{}
			}
			if err := m.Endorsement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxsRwSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxsRwSet == nil {
				m.TxsRwSet = make(map[string]*common.TxRWSet)
			}
			var mapkey string
			var mapvalue *common.TxRWSet
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTbft
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTbft
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTbft
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTbft
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &common.TxRWSet{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTbft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTbft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TxsRwSet[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Qc = append(m.Qc, &Vote{})
			if err := m.Qc[len(m.Qc)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= VoteType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Voter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endorsement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endorsement == nil {
				m.Endorsement = &common.EndorsementEntry{}
			}
			if err := m.Endorsement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidTxs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvalidTxs = append(m.InvalidTxs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockVotes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockVotes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockVotes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Votes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Votes == nil {
				m.Votes = make(map[string]*Vote)
			}
			var mapkey string
			var mapvalue *Vote
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTbft
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTbft
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTbft
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTbft
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Vote{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTbft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTbft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Votes[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			m.Sum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VoteSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VoteSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VoteSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= VoteType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			m.Sum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maj23", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Maj23 = append(m.Maj23[:0], dAtA[iNdEx:postIndex]...)
			if m.Maj23 == nil {
				m.Maj23 = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Votes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Votes == nil {
				m.Votes = make(map[string]*Vote)
			}
			var mapkey string
			var mapvalue *Vote
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTbft
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTbft
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTbft
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTbft
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Vote{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTbft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTbft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Votes[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotesByBlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VotesByBlock == nil {
				m.VotesByBlock = make(map[string]*BlockVotes)
			}
			var mapkey string
			var mapvalue *BlockVotes
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTbft
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTbft
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTbft
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTbft
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &BlockVotes{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTbft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTbft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.VotesByBlock[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoundVoteSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoundVoteSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoundVoteSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prevotes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prevotes == nil {
				m.Prevotes = &VoteSet{}
			}
			if err := m.Prevotes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Precommits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Precommits == nil {
				m.Precommits = &VoteSet{}
			}
			if err := m.Precommits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeightRoundVoteSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeightRoundVoteSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeightRoundVoteSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundVoteSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RoundVoteSets == nil {
				m.RoundVoteSets = make(map[int32]*RoundVoteSet)
			}
			var mapkey int32
			var mapvalue *RoundVoteSet
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTbft
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTbft
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RoundVoteSet{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTbft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTbft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RoundVoteSets[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			m.Step = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Step |= Step(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proposal == nil {
				m.Proposal = &Proposal{}
			}
			if err := m.Proposal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifingProposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VerifingProposal == nil {
				m.VerifingProposal = &Proposal{}
			}
			if err := m.VerifingProposal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockedProposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LockedProposal == nil {
				m.LockedProposal = &Proposal{}
			}
			if err := m.LockedProposal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidProposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidProposal == nil {
				m.ValidProposal = &Proposal{}
			}
			if err := m.ValidProposal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeightRoundVoteSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeightRoundVoteSet == nil {
				m.HeightRoundVoteSet = &HeightRoundVoteSet{}
			}
			if err := m.HeightRoundVoteSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchRoundQC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchRoundQC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchRoundQC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoundQC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoundQC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoundQC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Qc == nil {
				m.Qc = &VoteSet{}
			}
			if err := m.Qc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GossipState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GossipState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GossipState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			m.Step = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Step |= Step(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposal = append(m.Proposal[:0], dAtA[iNdEx:postIndex]...)
			if m.Proposal == nil {
				m.Proposal = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifingProposal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerifingProposal = append(m.VerifingProposal[:0], dAtA[iNdEx:postIndex]...)
			if m.VerifingProposal == nil {
				m.VerifingProposal = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundVoteSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RoundVoteSet == nil {
				m.RoundVoteSet = &RoundVoteSet{}
			}
			if err := m.RoundVoteSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeoutInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeoutInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeoutInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			m.Step = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Step |= Step(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WalEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WalEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WalEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= WalEntryType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTbft(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTbft
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTbft
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTbft
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTbft
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTbft        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTbft          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTbft = fmt.Errorf("proto: unexpected end of group")
)
